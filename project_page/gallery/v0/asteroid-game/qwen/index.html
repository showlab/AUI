<!DOCTYPE html>
# Space Shooter Game - Next.js Implementation

I'll create a complete 2D space shooter game with player controls, asteroid avoidance, and AI dogfights in a single Next.js page component.

```tsx
// pages/index.tsx
import React, { useState, useEffect, useRef } from 'react';

const SpaceShooterGame = () => {
  // Game state
  const [gameActive, setGameActive] = useState(false);
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [level, setLevel] = useState(1);
  const [gameOver, setGameOver] = useState(false);
  
  // Refs for game elements
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>(0);
  const keysRef = useRef<{[key: string]: boolean}>({});
  
  // Game objects
  const playerRef = useRef({
    x: 0,
    y: 0,
    width: 40,
    height: 40,
    speed: 5,
    color: '#4A90E2',
    rotation: 0,
    thrust: false
  });
  
  const bulletsRef = useRef<any[]>([]);
  const asteroidsRef = useRef<any[]>([]);
  const enemiesRef = useRef<any[]>([]);
  const particlesRef = useRef<any[]>([]);
  
  // Initialize game
  const initGame = () => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Set canvas size
    canvas.width = 1280;
    canvas.height = 720;
    
    // Reset game state
    setScore(0);
    setLives(3);
    setLevel(1);
    setGameOver(false);
    setGameActive(true);
    
    // Initialize player
    playerRef.current = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 40,
      height: 40,
      speed: 5,
      color: '#4A90E2',
      rotation: 0,
      thrust: false
    };
    
    // Clear arrays
    bulletsRef.current = [];
    asteroidsRef.current = [];
    enemiesRef.current = [];
    particlesRef.current = [];
    
    // Create initial asteroids
    for (let i = 0; i < 5 + level; i++) {
      createAsteroid();
    }
    
    // Start game loop
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    animationRef.current = requestAnimationFrame(gameLoop);
  };
  
  // Create a new asteroid
  const createAsteroid = () => {
    const size = Math.random() * 30 + 20;
    let x, y;
    
    // Spawn from edges
    if (Math.random() > 0.5) {
      x = Math.random() > 0.5 ? -size : canvasRef.current!.width + size;
      y = Math.random() * canvasRef.current!.height;
    } else {
      x = Math.random() * canvasRef.current!.width;
      y = Math.random() > 0.5 ? -size : canvasRef.current!.height + size;
    }
    
    asteroidsRef.current.push({
      x,
      y,
      size,
      speedX: (Math.random() - 0.5) * 2,
      speedY: (Math.random() - 0.5) * 2,
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.05
    });
  };
  
  // Create enemy ship
  const createEnemy = () => {
    const size = 30;
    let x, y;
    
    // Spawn from edges
    if (Math.random() > 0.5) {
      x = Math.random() > 0.5 ? -size : canvasRef.current!.width + size;
      y = Math.random() * canvasRef.current!.height;
    } else {
      x = Math.random() * canvasRef.current!.width;
      y = Math.random() > 0.5 ? -size : canvasRef.current!.height + size;
    }
    
    enemiesRef.current.push({
      x,
      y,
      size,
      speedX: (Math.random() - 0.5) * 1.5,
      speedY: (Math.random() - 0.5) * 1.5,
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.03,
      lastShot: 0,
      shootDelay: 2000 + Math.random() * 3000
    });
  };
  
  // Create explosion particles
  const createExplosion = (x: number, y: number, color: string) => {
    for (let i = 0; i < 15; i++) {
      particlesRef.current.push({
        x,
        y,
        size: Math.random() * 5 + 2,
        speedX: (Math.random() - 0.5) * 5,
        speedY: (Math.random() - 0.5) * 5,
        color,
        life: 30
      });
    }
  };
  
  // Player shooting
  const shootBullet = () => {
    if (!gameActive || gameOver) return;
    
    const player = playerRef.current;
    bulletsRef.current.push({
      x: player.x + player.width/2,
      y: player.y + player.height/2,
      size: 4,
      speed: 10,
      color: '#FFD700'
    });
  };
  
  // Handle keyboard input
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      keysRef.current[e.key] = true;
      
      if (e.key === ' ') {
        e.preventDefault();
        shootBullet();
      }
      
      if (e.key === 'Enter' && !gameActive) {
        initGame();
      }
    };
    
    const handleKeyUp = (e: KeyboardEvent) => {
      keysRef.current[e.key] = false;
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [gameActive]);
  
  // Game loop
  const gameLoop = () => {
    if (!gameActive || gameOver) return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw stars background
    drawStars(ctx);
    
    // Update and draw player
    updatePlayer();
    drawPlayer(ctx);
    
    // Update and draw bullets
    updateBullets();
    drawBullets(ctx);
    
    // Update and draw asteroids
    updateAsteroids();
    drawAsteroids(ctx);
    
    // Update and draw enemies
    updateEnemies();
    drawEnemies(ctx);
    
    // Update and draw particles
    updateParticles();
    drawParticles(ctx);
    
    // Check collisions
    checkCollisions();
    
    // Spawn enemies periodically
    if (Math.random() < 0.01) {
      createEnemy();
    }
    
    // Increase difficulty
    if (score > level * 100) {
      setLevel(prev => prev + 1);
    }
    
    // Continue game loop
    animationRef.current = requestAnimationFrame(gameLoop);
  };
  
  // Draw starry background
  const drawStars = (ctx: CanvasRenderingContext2D) => {
    ctx.fillStyle = '#FFF';
    for (let i = 0; i < 100; i++) {
      const x = (i * 13) % canvasRef.current!.width;
      const y = (i * 7) % canvasRef.current!.height;
      const size = Math.sin(i) * 0.5 + 1;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
  };
  
  // Update player position and rotation
  const updatePlayer = () => {
    const player = playerRef.current;
    const keys = keysRef.current;
    
    // Rotation
    if (keys['ArrowLeft']) {
      player.rotation -= 0.1;
    }
    if (keys['ArrowRight']) {
      player.rotation += 0.1;
    }
    
    // Thrust
    player.thrust = keys['ArrowUp'];
    
    // Movement
    if (player.thrust) {
      player.x += Math.cos(player.rotation) * player.speed;
      player.y += Math.sin(player.rotation) * player.speed;
    }
    
    // Keep player on screen
    if (player.x < -player.width) player.x = canvasRef.current!.width;
    if (player.x > canvasRef.current!.width) player.x = -player.width;
    if (player.y < -player.height) player.y = canvasRef.current!.height;
    if (player.y > canvasRef.current!.height) player.y = -player.height;
  };
  
  // Draw player ship
  const drawPlayer = (ctx: CanvasRenderingContext2D) => {
    const player = playerRef.current;
    
    ctx.save();
    ctx.translate(player.x + player.width/2, player.y + player.height/2);
    ctx.rotate(player.rotation);
    
    // Ship body
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.moveTo(0, -player.height/2);
    ctx.lineTo(-player.width/2, player.height/2);
    ctx.lineTo(0, player.height/4);
    ctx.lineTo(player.width/2, player.height/2);
    ctx.closePath();
    ctx.fill();
    
    // Thruster effect
    if (player.thrust) {
      ctx.fillStyle = '#FF4500';
      ctx.beginPath();
      ctx.moveTo(-player.width/4, player.height/2);
      ctx.lineTo(0, player.height/2 + 15);
      ctx.lineTo(player.width/4, player.height/2);
      ctx.closePath();
      ctx.fill();
    }
    
    ctx.restore();
  };
  
  // Update bullets
  const updateBullets = () => {
    for (let i = bulletsRef.current.length - 1; i >= 0; i--) {
      const bullet = bulletsRef.current[i];
      bullet.x += Math.cos(playerRef.current.rotation) * bullet.speed;
      bullet.y += Math.sin(playerRef.current.rotation) * bullet.speed;
      
      // Remove bullets that go off screen
      if (bullet.x < 0 || bullet.x > canvasRef.current!.width || 
          bullet.y < 0 || bullet.y > canvasRef.current!.height) {
        bulletsRef.current.splice(i, 1);
      }
    }
  };
  
  // Draw bullets
  const drawBullets = (ctx: CanvasRenderingContext2D) => {
    for (const bullet of bulletsRef.current) {
      ctx.fillStyle = bullet.color;
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
      ctx.fill();
    }
  };
  
  // Update asteroids
  const updateAsteroids = () => {
    for (let i = asteroidsRef.current.length - 1; i >= 0; i--) {
      const asteroid = asteroidsRef.current[i];
      
      asteroid.x += asteroid.speedX;
      asteroid.y += asteroid.speedY;
      asteroid.rotation += asteroid.rotationSpeed;
      
      // Wrap around screen
      if (asteroid.x < -asteroid.size) asteroid.x = canvasRef.current!.width + asteroid.size;
      if (asteroid.x > canvasRef.current!.width + asteroid.size) asteroid.x = -asteroid.size;
      if (asteroid.y < -asteroid.size) asteroid.y = canvasRef.current!.height + asteroid.size;
      if (asteroid.y > canvasRef.current!.height + asteroid.size) asteroid.y = -asteroid.size;
    }
  };
  
  // Draw asteroids
  const drawAsteroids = (ctx: CanvasRenderingContext2D) => {
    for (const asteroid of asteroidsRef.current) {
      ctx.save();
      ctx.translate(asteroid.x, asteroid.y);
      ctx.rotate(asteroid.rotation);
      
      ctx.strokeStyle = '#AAA';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      // Draw irregular polygon
      const points = 8;
      for (let i = 0; i < points; i++) {
        const angle = (i / points) * Math.PI * 2;
        const radius = asteroid.size * (0.7 + Math.random() * 0.3);
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.stroke();
      
      ctx.restore();
    }
  };
  
  // Update enemies
  const updateEnemies = () => {
    const now = Date.now();
    
    for (let i = enemiesRef.current.length - 1; i >= 0; i--) {
      const enemy = enemiesRef.current[i];
      
      // Move towards player
      const dx = playerRef.current.x - enemy.x;
      const dy = playerRef.current.y - enemy.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 0) {
        enemy.speedX = (dx / distance) * 1.5;
        enemy.speedY = (dy / distance) * 1.5;
      }
      
      enemy.x += enemy.speedX;
      enemy.y += enemy.speedY;
      enemy.rotation += enemy.rotationSpeed;
      
      // Shooting logic
      if (now - enemy.lastShot > enemy.shootDelay) {
        // Simple AI shooting
        if (distance < 300) {
          bulletsRef.current.push({
            x: enemy.x + enemy.size/2,
            y: enemy.y + enemy.size/2,
            size: 3,
            speed: 5,
            color: '#FF0000'
          });
          enemy.lastShot = now;
        }
      }
      
      // Wrap around screen
      if (enemy.x < -enemy.size) enemy.x = canvasRef.current!.width + enemy.size;
      if (enemy.x > canvasRef.current!.width + enemy.size) enemy.x = -enemy.size;
      if (enemy.y < -enemy.size) enemy.y = canvasRef.current!.height + enemy.size;
      if (enemy.y > canvasRef.current!.height + enemy.size) enemy.y = -enemy.size;
    }
  };
  
  // Draw enemies
  const drawEnemies = (ctx: CanvasRenderingContext2D) => {
    for (const enemy of enemiesRef.current) {
      ctx.save();
      ctx.translate(enemy.x + enemy.size/2, enemy.y + enemy.size/2);
      ctx.rotate(enemy.rotation);
      
      // Enemy ship body
      ctx.fillStyle = '#FF4500';
      ctx.beginPath();
      ctx.moveTo(0, -enemy.size/2);
      ctx.lineTo(-enemy.size/2, enemy.size/2);
      ctx.lineTo(0, enemy.size/4);
      ctx.lineTo(enemy.size/2, enemy.size/2);
      ctx.closePath();
      ctx.fill();
      
      // Enemy cockpit
      ctx.fillStyle = '#00FFFF';
      ctx.beginPath();
      ctx.arc(0, 0, enemy.size/4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  };
  
  // Update particles
  const updateParticles = () => {
    for (let i = particlesRef.current.length - 1; i >= 0; i--) {
      const particle = particlesRef.current[i];
      particle.x += particle.speedX;
      particle.y += particle.speedY;
      particle.life--;
      
      if (particle.life <= 0) {
        particlesRef.current.splice(i, 1);
      }
    }
  };
  
  // Draw particles
  const drawParticles = (ctx: CanvasRenderingContext2D) => {
    for (const particle of particlesRef.current) {
      ctx.fillStyle = particle.color;
      ctx.globalAlpha = particle.life / 30;
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  };
  
  // Check collisions
  const checkCollisions = () => {
    const player = playerRef.current;
    
    // Bullet-asteroid collisions
    for (let i = bulletsRef.current.length - 1; i >= 0; i--) {
      const bullet = bulletsRef.current[i];
      
      for (let j = asteroidsRef.current.length - 1; j >= 0; j--) {
        const asteroid = asteroidsRef.current[j];
        
        const dx = bullet.x - asteroid.x;
        const dy = bullet.y - asteroid.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < asteroid.size/2 + bullet.size) {
          // Create explosion
          createExplosion(asteroid.x, asteroid.y, '#FFA500');
          
          // Remove bullet and asteroid
          bulletsRef.current.splice(i, 1);
          asteroidsRef.current.splice(j, 1);
          
          // Increase score
          setScore(prev => prev + 10);
          
          // Create new asteroid if needed
          if (Math.random() < 0.7) {
            createAsteroid();
          }
          
          break;
        }
      }
    }
    
    // Bullet-enemy collisions
    for (let i = bulletsRef.current.length - 1; i >= 0; i--) {
      const bullet = bulletsRef.current[i];
      
      for (let j = enemiesRef.current.length - 1; j >= 0; j--) {
        const enemy = enemiesRef.current[j];
        
        const dx = bullet.x - enemy.x;
        const dy = bullet.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < enemy.size/2 + bullet.size) {
          // Create explosion
          createExplosion(enemy.x, enemy.y, '#FF0000');
          
          // Remove bullet and enemy
          bulletsRef.current.splice(i, 1);
          enemiesRef.current.splice(j, 1);
          
          // Increase score
          setScore(prev => prev + 50);
          
          break;
        }
      }
    }
    
    // Player-asteroid collisions
    for (let i = asteroidsRef.current.length - 1; i >= 0; i--) {
      const asteroid = asteroidsRef.current[i];
      
      const dx = player.x - asteroid.x;
      const dy = player.y - asteroid.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < asteroid.size/2 + player.width/2) {
        // Create explosion
        createExplosion(player.x, player.y, '#FFA500');
        createExplosion(asteroid.x, asteroid.y, '#FFA500');
        
        // Remove asteroid
        asteroidsRef.current.splice(i, 1);
        
        // Decrease lives
        setLives(prev => {
          const newLives = prev - 1;
          if (newLives <= 0) {
            setGameOver(true);
            setGameActive(false);
          }
          return newLives;
        });
        
        // Create new asteroid if needed
        if (Math.random() < 0.7) {
          createAsteroid();
        }
        
        break;
      }
    }
    
    // Player-enemy collisions
    for (let i = enemiesRef.current.length - 1; i >= 0; i--) {
      const enemy = enemiesRef.current[i];
      
      const dx = player.x - enemy.x;
      const dy = player.y - enemy.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < enemy.size/2 + player.width/2) {
        // Create explosion
        createExplosion(player.x, player.y, '#FF0000');
        createExplosion(enemy.x, enemy.y, '#FF0000');
        
        // Remove enemy
        enemiesRef.current.splice(i, 1);
        
        // Decrease lives
        setLives(prev => {
          const newLives = prev - 1;
          if (newLives <= 0) {
            setGameOver(true);
            setGameActive(false);
          }
          return newLives;
        });
        
        break;
      }
    }
  };
  
  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);
  
  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-4">
      <h1 className="text-4xl font-bold mb-2 text-blue-400">Space Shooter</h1>
      <p className="mb-4 text-gray-300">Use arrow keys to move and spacebar to shoot</p>
      
      <div className="relative mb-4">
        <canvas 
          ref={canvasRef} 
          id="gameCanvas"
          className="border-2 border-blue-500 rounded-lg shadow-lg"
        />
        
        {!gameActive && !gameOver && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-70 rounded-lg">
            <h2 className="text-3xl font-bold mb-4 text-yellow-400">Space Shooter</h2>
            <p className="mb-2">Controls:</p>
            <p className="mb-1">↑↓←→ Arrow Keys - Move</p>
            <p className="mb-4">Spacebar - Shoot</p>
            <button 
              onClick={initGame}
              className="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold text-xl transition-colors"
              id="startButton"
            >
              Start Game
            </button>
          </div>
        )}
        
        {gameOver && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-80 rounded-lg">
            <h2 className="text-4xl font-bold mb-2 text-red-500">Game Over</h2>
            <p className="text-2xl mb-4">Final Score: {score}</p>
            <button 
              onClick={initGame}
              className="px-6 py-3 bg-green-600 hover:bg-green-700 rounded-lg font-bold text-xl transition-colors"
              id="restartButton"
            >
              Play Again
            </button>
          </div>
        )}
      </div>
      
      <div className="flex justify-between w-full max-w-2xl mb-4">
        <div className="bg-gray-800 p-3 rounded-lg">
          <p className="text-lg">Score: <span className="font-bold text-yellow-400">{score}</span></p>
        </div>
        <div className="bg-gray-800 p-3 rounded-lg">
          <p className="text-lg">Level: <span className="font-bold text-green-400">{level}</span></p>
        </div>
        <div className="bg-gray-800 p-3 rounded-lg">
          <p className="text-lg">Lives: <span className="font-bold text-red-400">{lives}</span></p>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 w-full max-w-2xl">
        <div className="bg-gray-800 p-4 rounded-lg">
          <h3 className="font-bold text-blue-400 mb-2">Controls</h3>
          <ul className="space-y-1 text-sm">
            <li>↑ ← → ↓ Arrow Keys: Move spaceship</li>
            <li>Spacebar: Fire weapon</li>
          </ul>
        </div>
        
        <div className="bg-gray-800 p-4 rounded-lg">
          <h3 className="font-bold text-green-400 mb-2">Objective</h3>
          <ul className="space-y-1 text-sm">
            <li>Avoid asteroids and enemy ships</li>
            <li>Destroy asteroids to earn points</li>
            <li>Destroy enemy ships for bonus points</li>
          </ul>
        </div>
        
        <div className="bg-gray-800 p-4 rounded-lg">
          <h3 className="font-bold text-yellow-400 mb-2">Scoring</h3>
          <ul className="space-y-1 text-sm">
            <li>Asteroid: 10 points</li>
            <li>Enemy ship: 50 points</li>
            <li>Each level increases difficulty</li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default SpaceShooterGame;
```

## How to Run This Game

1. Create a new Next.js app using `create-next-app`:
```bash
npx create-next-app space-shooter-game
cd space-shooter-game
```

2. Replace the contents of `pages/index.tsx` with the code above

3. Install dependencies (if not already installed):
```bash
npm install
```

4. Run the development server:
```bash
npm run dev
```

5. Open your browser to http://localhost:3000

## Game Features

- **Player Controls**: Use arrow keys to move and spacebar to shoot
- **Game Elements**:
  - Player spaceship with thrust effects
  - Asteroids of varying sizes that move randomly
  - Enemy ships that chase the player
  - Particle explosions when objects are destroyed
- **Game Mechanics**:
  - Score tracking
  - Lives system
  - Increasing difficulty levels
  - Collision detection
- **Visual Design**:
  - Space-themed background with stars
  - Colorful ships and projectiles
  - Smooth animations and particle effects
- **UI Components**:
  - Start screen with instructions
  - Game over screen with final score
  - Score, level, and lives display
  - Game instructions panel

The game is fully playable in a 1280x720 viewport as requested. The player can navigate through space, avoid obstacles, and engage in combat with AI-controlled enemies. The game progressively gets more challenging as the player advances through levels.

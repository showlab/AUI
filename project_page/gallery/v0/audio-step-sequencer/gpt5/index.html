<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Audio Step Sequencer</title>
<style>
  :root{
    --bg:#0b0f17;
    --panel:#0f1624;
    --accent:#14ffe9;
    --accent2:#7b5cff;
    --accent3:#ff2e6a;
    --gridOn:#14ffe980;
    --gridOff:#2a3147;
    --text:#d6e2ff;
    --muted:#8fa0c7;
    --warning:#ffcc00;
    --success:#2cff85;
    --danger:#ff5f5f;
    --shadow-glow:0 0 10px rgba(20,255,233,0.6), 0 0 20px rgba(123,92,255,0.4);
  }
  *{box-sizing:border-box}
  html,body{
    margin:0; padding:0; background: radial-gradient(1200px 600px at 70% -10%, rgba(123,92,255,0.15), transparent), linear-gradient(180deg,#0b0f17 0%, #0a0d13 100%);
    color:var(--text);
    font-family: "Segoe UI", Roboto, system-ui, -apple-system, Arial, sans-serif;
    height:100%;
  }
  header{
    display:flex; align-items:center; justify-content:space-between;
    padding:16px 24px; position:sticky; top:0; backdrop-filter: blur(6px);
    background: linear-gradient(180deg, rgba(15,22,36,0.9), rgba(15,22,36,0.6));
    border-bottom:1px solid #1a2140;
    z-index:10;
  }
  #titleBar{
    display:flex; align-items:center; gap:16px;
  }
  #appTitle{
    font-weight:800; letter-spacing:0.06em; text-transform:uppercase;
    font-size:22px; color:#fff; text-shadow: 0 0 8px rgba(20,255,233,0.4);
  }
  #statusText{ font-size:12px; color:var(--muted); }
  #transport{
    display:flex; align-items:center; gap:16px;
  }
  button{
    background:linear-gradient(180deg, #15203b, #10182d);
    color:#e8f3ff; border:1px solid #2a3b66; border-radius:10px;
    padding:10px 16px; cursor:pointer; transition: all .15s ease;
    box-shadow: inset 0 0 0 0 rgba(20,255,233,0.3);
  }
  button:hover{ transform: translateY(-1px); border-color:#4a66aa; }
  button:active{ transform: translateY(0); }
  button.primary{
    border-color:#1ee6d4; color:#03151a;
    background:linear-gradient(180deg, #14ffe9, #11c8b2);
    box-shadow: var(--shadow-glow);
  }
  button.danger{
    background: linear-gradient(180deg, #2b1118, #190b10);
    border-color:#63202c; color:#ffd8e2;
  }
  button.ghost{
    background: transparent; border:1px dashed #33456f; color:#cfe3ff;
  }
  .toggle{
    border:1px solid #33456f;
    background: linear-gradient(180deg, #0e1528, #0d1424);
  }
  .toggle[aria-pressed="true"]{
    border-color:#26ffc7; box-shadow: var(--shadow-glow);
    background: linear-gradient(180deg, #0e1f2e, #0d2a2a);
  }
  .control{
    display:flex; align-items:center; gap:8px; color:var(--muted);
  }
  .control input[type="range"]{ width:160px; }
  .value-badge{
    min-width:48px; display:inline-flex; align-items:center; justify-content:center;
    background:#0c1326; border:1px solid #243259; border-radius:8px; height:28px; padding:0 8px; color:#e6f3ff;
  }
  main{ padding:24px; display:grid; grid-template-columns: 1fr 300px; gap:24px; }
  @media(max-width:1100px){
    main{ grid-template-columns: 1fr; }
  }

  /* Grid */
  #gridPanel{
    background: linear-gradient(180deg, rgba(20,30,56,0.6), rgba(14,18,30,0.6));
    border:1px solid #1a2140; border-radius:16px; padding:16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 0 30px rgba(20,255,233,0.06);
  }
  #gridHeader{
    display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;
  }
  #grid{
    display:grid; grid-template-columns: 120px repeat(16, 1fr); gap:8px; align-items:center;
  }
  .track-label{
    background: linear-gradient(180deg, #11192d, #0c1020);
    border:1px solid #223258; height:48px; display:flex; align-items:center; justify-content:space-between;
    padding:0 12px; border-radius:12px; color:#cfe3ff;
  }
  .color-dot{ width:10px; height:10px; border-radius:50%; box-shadow:0 0 10px currentColor; }
  .step{
    height:48px; border-radius:12px; border:1px solid #253256;
    background:linear-gradient(180deg, #0d1426, #0b1120);
    cursor:pointer; position:relative; transition: all .1s ease;
    outline:none; color:transparent;
  }
  .step:hover{ border-color:#4562a2; }
  .step.on{
    background:linear-gradient(180deg, #102440, #153a4a);
    border-color:#1ee6d4; box-shadow: inset 0 0 8px rgba(20,255,233,0.4), 0 0 8px rgba(20,255,233,0.2);
  }
  .step .pulse{
    content:""; position:absolute; inset:2px; border-radius:10px; opacity:0; pointer-events:none;
    background: radial-gradient(200px 40px at 50% 50%, rgba(20,255,233,0.25), transparent);
    transition: opacity .12s ease;
  }
  .step.on .pulse{ opacity:1; }
  .colIndex{
    grid-column: span 16; display:grid; grid-template-columns: repeat(16, 1fr); gap:8px; margin-bottom:6px;
  }
  .colIndex .cell{
    text-align:center; font-size:11px; color:#8aa2d0; opacity:0.7;
  }
  .playing-column{
    box-shadow: inset 0 0 0 2px rgba(255,255,255,0.04), 0 0 15px rgba(123,92,255,0.3);
    position:relative;
  }
  .playing-ind{
    position:absolute; top:-6px; left:4px; right:4px; height:3px; border-radius:5px;
    background:linear-gradient(90deg, #7b5cff, #14ffe9);
    box-shadow: 0 0 8px rgba(123,92,255,0.8), 0 0 14px rgba(20,255,233,0.6);
  }
  /* Sidebar */
  #sidePanel{
    background: linear-gradient(180deg, rgba(20,30,56,0.6), rgba(14,18,30,0.6));
    border:1px solid #1a2140; border-radius:16px; padding:16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 0 30px rgba(20,255,233,0.06);
  }
  .section{
    border-top:1px solid #1a2140; padding-top:16px; margin-top:16px;
  }
  .section:first-child{
    border-top:none; padding-top:0; margin-top:0;
  }
  .section h3{
    margin:0 0 12px 0; font-size:14px; text-transform:uppercase; letter-spacing:.14em; color:#eaf3ff;
  }
  .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  input[type="text"]{
    background:#0e152b; color:#eaf3ff; border:1px solid #243259; border-radius:10px; padding:10px 12px;
    outline:none; width:100%;
  }
  select{
    background:#0e152b; color:#eaf3ff; border:1px solid #243259; border-radius:10px; padding:10px 12px; width:100%;
  }
  .two-col{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .hint{ font-size:12px; color:var(--muted); margin-top:6px; }
  footer{ padding:10px 24px; font-size:12px; color:#7e90bf; opacity:0.8; }
  .badge{
    display:inline-block; padding:4px 8px; border-radius:999px; font-size:11px; background:#0e162d; border:1px solid #2c3f6b;
  }
</style>
</head>
<body>
<header>
  <div id="titleBar">
    <div id="appTitle">Audio Step Sequencer</div>
    <div id="statusText" aria-live="polite">Ready</div>
  </div>
  <div id="transport">
    <button id="playButton" class="primary" aria-pressed="false">Play</button>
    <div class="control">
      <span class="badge">Tempo</span>
      <input id="tempoSlider" type="range" min="40" max="200" value="120" />
      <span id="tempoValue" class="value-badge">120 BPM</span>
    </div>
    <div class="control">
      <span class="badge">Swing</span>
      <input id="swingSlider" type="range" min="0" max="60" value="10" />
      <span id="swingValue" class="value-badge">10%</span>
    </div>
    <div class="control">
      <span class="badge">Volume</span>
      <input id="volumeSlider" type="range" min="0" max="100" value="80" />
      <span id="volumeValue" class="value-badge">80%</span>
    </div>
  </div>
</header>

<main id="appContainer">
  <section id="gridPanel" aria-label="Step Grid">
    <div id="gridHeader">
      <div class="control">
        <button id="clearPatternButton" class="ghost">Clear</button>
        <button id="randomizeButton" class="ghost">Randomize</button>
      </div>
      <div class="control">
        <span class="badge">Bars to export</span>
        <select id="barsSelect">
          <option value="1">1 bar</option>
          <option value="2" selected>2 bars</option>
          <option value="4">4 bars</option>
          <option value="8">8 bars</option>
        </select>
        <button id="exportWavButton">Export WAV</button>
      </div>
    </div>

    <div class="colIndex" aria-hidden="true" id="columnIndexRow"></div>

    <div id="grid" role="grid" aria-rowcount="4" aria-colcount="16"></div>
  </section>

  <aside id="sidePanel">
    <div class="section">
      <h3>Patterns</h3>
      <div class="two-col">
        <input id="patternNameInput" type="text" placeholder="Pattern name (e.g., Neon Groove)"/>
        <button id="savePatternButton">Save</button>
      </div>
      <div class="two-col" style="margin-top:10px;">
        <select id="loadPatternSelect"></select>
        <button id="deletePatternButton" class="danger">Delete</button>
      </div>
      <div class="hint">Saved locally in your browser. Includes tempo and swing.</div>
    </div>

    <div class="section">
      <h3>Play Modes</h3>
      <div class="row">
        <button id="tapTempoButton" class="toggle" aria-pressed="false">Tap Tempo</button>
        <button id="metronomeButton" class="toggle" aria-pressed="false">Metronome</button>
      </div>
      <div class="hint">Add swing for groove. Tap tempo adjusts BPM by tapping 4+ times.</div>
    </div>

    <div class="section">
      <h3>About</h3>
      <div class="hint">Built with Web Audio API. No samples needed â€“ all drums are synthesized live.</div>
    </div>
  </aside>
</main>

<footer>
  <span class="badge">WebAudio</span> <span class="badge">16-step</span> <span class="badge">WAV export</span> <span class="badge">Swing</span>
</footer>

<script>
(() => {
  'use strict';

  // State
  const state = {
    bpm: 120,
    swingPct: 10, // 0-60
    isPlaying: false,
    currentStep: 0,
    lookahead: 25/1000, // 25ms
    scheduleAheadTime: 0.1, // seconds
    nextNoteTime: 0,
    timerID: null,
    tapTimes: [],
    tracks: [
      { name: 'Kick', color:'#ff4b4b', pattern: new Array(16).fill(false) },
      { name: 'Snare', color:'#55d6ff', pattern: new Array(16).fill(false) },
      { name: 'Hat',   color:'#fff75e', pattern: new Array(16).fill(false) },
      { name: 'Clap',  color:'#b755ff', pattern: new Array(16).fill(false) }
    ],
    metronomeOn: false,
  };

  // Default pattern
  function setDefaultPattern() {
    // Kick on 1,5,9,13
    [0,4,8,12].forEach(i => state.tracks[0].pattern[i] = true);
    // Snare on 5 and 13 (beats 2 and 4)
    [4,12].forEach(i => state.tracks[1].pattern[i] = true);
    // Hat on all 16
    for (let i=0;i<16;i++) state.tracks[2].pattern[i] = (i%2===0); // closed hats on 8ths for clarity
    // Clap on off-beats
    [6,14].forEach(i => state.tracks[3].pattern[i] = true);
  }

  // Audio
  let audioCtx = null;
  let masterGain = null;
  let noiseBuffer = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.8;
    masterGain.connect(audioCtx.destination);
    noiseBuffer = createNoiseBuffer(audioCtx);
  }

  function createNoiseBuffer(ctx){
    const length = ctx.sampleRate * 2;
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<length;i++){
      data[i] = Math.random()*2 - 1;
    }
    return buffer;
  }

  function triggerClick(time, freq=2000){
    if (!state.metronomeOn) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type='square';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.2, time + 0.001);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);
    osc.connect(g).connect(masterGain);
    osc.start(time);
    osc.stop(time+0.06);
  }

  function triggerKick(time, ctx=audioCtx, dest=masterGain){
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, time);
    osc.frequency.exponentialRampToValueAtTime(50, time + 0.12);
    g.gain.setValueAtTime(1, time);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.6);
    osc.connect(g).connect(dest);
    osc.start(time);
    osc.stop(time + 0.6);

    // click transient
    const click = ctx.createBufferSource();
    const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
    click.buffer = nb;
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 1000;
    const g2 = ctx.createGain();
    g2.gain.setValueAtTime(0.25, time);
    g2.gain.exponentialRampToValueAtTime(0.0001, time + 0.02);
    click.connect(hp).connect(g2).connect(dest);
    click.start(time);
    click.stop(time + 0.03);
  }

  function triggerSnare(time, ctx=audioCtx, dest=masterGain){
    const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
    const noise = ctx.createBufferSource();
    noise.buffer = nb;
    const bp = ctx.createBiquadFilter();
    bp.type='bandpass'; bp.frequency.value = 1800; bp.Q.value=0.7;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.6, time);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
    noise.connect(bp).connect(g).connect(dest);
    noise.start(time);
    noise.stop(time + 0.2);

    // body
    const osc = ctx.createOscillator();
    const g2 = ctx.createGain();
    osc.type='sine';
    osc.frequency.setValueAtTime(220, time);
    osc.frequency.exponentialRampToValueAtTime(160, time+0.08);
    g2.gain.setValueAtTime(0.5, time);
    g2.gain.exponentialRampToValueAtTime(0.0001, time+0.12);
    osc.connect(g2).connect(dest);
    osc.start(time);
    osc.stop(time+0.15);
  }

  function triggerHat(time, ctx=audioCtx, dest=masterGain){
    const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
    const noise = ctx.createBufferSource();
    noise.buffer = nb;
    const hp = ctx.createBiquadFilter();
    hp.type='highpass'; hp.frequency.value=6000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.35, time);
    g.gain.exponentialRampToValueAtTime(0.0001, time+0.07);
    noise.connect(hp).connect(g).connect(dest);
    noise.start(time);
    noise.stop(time+0.09);
  }

  function triggerClap(time, ctx=audioCtx, dest=masterGain){
    // multi-burst clap
    const bursts = [0, 0.022, 0.045];
    bursts.forEach((off, i) => {
      const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
      const noise = ctx.createBufferSource();
      noise.buffer = nb;
      const hp = ctx.createBiquadFilter();
      hp.type='highpass'; hp.frequency.value=1200;
      const g = ctx.createGain();
      const t = time + off;
      const amp = i===0 ? 0.38 : (i===1 ? 0.28 : 0.2);
      g.gain.setValueAtTime(amp, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
      noise.connect(hp).connect(g).connect(dest);
      noise.start(t);
      noise.stop(t + 0.14);
    });
  }

  const instrumentTriggers = [triggerKick, triggerSnare, triggerHat, triggerClap];

  // Timing helpers
  function secondsPer16th(bpm){
    return (60 / bpm) / 4;
  }
  function swingOffsetSeconds(bpm, swingPct){
    const d = secondsPer16th(bpm);
    const amount = Math.min(60, Math.max(0, swingPct)) / 100; // 0..0.6
    // Delay the odd step by up to 50% of the 16th duration * amount
    return d * 0.5 * amount;
  }

  function scheduleStep(stepIndex, time){
    // Visual playhead at time
    setTimeout(() => setActiveColumn(stepIndex), Math.max(0, (time - audioCtx.currentTime)*1000));

    // Metronome: accented on step 0
    if (state.metronomeOn){
      if (stepIndex % 4 === 0){
        triggerClick(time, stepIndex===0 ? 2600 : 2000);
      }
    }
    state.tracks.forEach((track, ti) => {
      if (track.pattern[stepIndex]){
        instrumentTriggers[ti](time);
      }
    });
  }

  function nextStep() {
    const sp16 = secondsPer16th(state.bpm);
    const swing = swingOffsetSeconds(state.bpm, state.swingPct);
    // Schedule current step
    scheduleStep(state.currentStep % 16, state.nextNoteTime);
    // increment
    const isEven = (state.currentStep % 2) === 0;
    const increment = isEven ? (sp16 + swing) : (sp16 - swing);
    state.nextNoteTime += Math.max(0.001, increment);
    state.currentStep = (state.currentStep + 1) % 16;
  }

  function scheduler(){
    while (state.nextNoteTime < audioCtx.currentTime + state.scheduleAheadTime) {
      nextStep();
    }
    state.timerID = setTimeout(scheduler, state.lookahead*1000);
  }

  function start(){
    ensureAudio();
    audioCtx.resume();
    state.isPlaying = true;
    document.getElementById('playButton').textContent = 'Stop';
    document.getElementById('playButton').setAttribute('aria-pressed', 'true');
    state.currentStep = 0;
    state.nextNoteTime = audioCtx.currentTime + 0.06;
    scheduler();
    setStatus('Playing');
  }

  function stop(){
    state.isPlaying = false;
    document.getElementById('playButton').textContent = 'Play';
    document.getElementById('playButton').setAttribute('aria-pressed', 'false');
    clearTimeout(state.timerID);
    state.timerID = null;
    clearActiveColumn();
    setStatus('Stopped');
  }

  // UI build
  const gridEl = document.getElementById('grid');
  const columnIndexRow = document.getElementById('columnIndexRow');

  function buildColumnIndexes(){
    columnIndexRow.innerHTML = '';
    for (let c=0;c<16;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.textContent = (c+1);
      columnIndexRow.appendChild(cell);
    }
  }

  function buildGrid(){
    gridEl.innerHTML = '';
    buildColumnIndexes();
    state.tracks.forEach((track, ti) => {
      // Label
      const label = document.createElement('div');
      label.className = 'track-label';
      label.setAttribute('role', 'rowheader');
      label.innerHTML = `<span>${track.name}</span><span class="color-dot" style="color:${track.color}; background:${track.color}"></span>`;
      gridEl.appendChild(label);

      // Steps
      for(let si=0;si<16;si++){
        const btn = document.createElement('button');
        btn.className = 'step';
        btn.id = `step-${ti}-${si}`;
        btn.setAttribute('role','gridcell');
        btn.setAttribute('aria-label', `${track.name} step ${si+1}`);
        btn.setAttribute('aria-pressed', 'false');
        btn.addEventListener('click', () => toggleStep(ti, si, btn, true));
        const pulse = document.createElement('div');
        pulse.className = 'pulse';
        btn.appendChild(pulse);
        gridEl.appendChild(btn);
      }
    });
    refreshGridFromState();
  }

  function toggleStep(ti, si, el, user=true){
    const newVal = !state.tracks[ti].pattern[si];
    state.tracks[ti].pattern[si] = newVal;
    el.classList.toggle('on', newVal);
    el.setAttribute('aria-pressed', newVal ? 'true' : 'false');
    if (user && audioCtx){
      const previewTime = audioCtx.currentTime + 0.02;
      instrumentTriggers[ti](previewTime);
    }
  }

  function refreshGridFromState(){
    state.tracks.forEach((track, ti) => {
      for (let si=0; si<16; si++){
        const el = document.getElementById(`step-${ti}-${si}`);
        if (!el) continue;
        const on = !!track.pattern[si];
        el.classList.toggle('on', on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
      }
    });
  }

  // Active column highlight
  let lastColumn = -1;
  function clearActiveColumn(){
    for (let ti=0; ti<state.tracks.length; ti++){
      for (let si=0; si<16; si++){
        const el = document.getElementById(`step-${ti}-${si}`);
        if (!el) continue;
        el.classList.remove('playing-column');
        const ind = el.querySelector('.playing-ind');
        if (ind) ind.remove();
      }
    }
    lastColumn = -1;
  }
  function setActiveColumn(col){
    if (col === lastColumn) return;
    // Clear previous
    if (lastColumn >= 0){
      for (let ti=0; ti<state.tracks.length; ti++){
        const prev = document.getElementById(`step-${ti}-${lastColumn}`);
        if (prev){
          prev.classList.remove('playing-column');
          const ind = prev.querySelector('.playing-ind');
          if (ind) ind.remove();
        }
      }
    }
    // Set new
    for (let ti=0; ti<state.tracks.length; ti++){
      const el = document.getElementById(`step-${ti}-${col}`);
      if (el){
        el.classList.add('playing-column');
        const bar = document.createElement('div');
        bar.className = 'playing-ind';
        el.appendChild(bar);
      }
    }
    lastColumn = col;
  }

  // Controls
  document.getElementById('playButton').addEventListener('click', async () => {
    ensureAudio();
    await audioCtx.resume();
    if (!state.isPlaying) start();
    else stop();
  });

  const tempoSlider = document.getElementById('tempoSlider');
  const tempoValue = document.getElementById('tempoValue');
  tempoSlider.addEventListener('input', () => {
    state.bpm = parseInt(tempoSlider.value, 10);
    tempoValue.textContent = `${state.bpm} BPM`;
  });

  const swingSlider = document.getElementById('swingSlider');
  const swingValue = document.getElementById('swingValue');
  swingSlider.addEventListener('input', () => {
    state.swingPct = parseInt(swingSlider.value, 10);
    swingValue.textContent = `${state.swingPct}%`;
  });

  const volumeSlider = document.getElementById('volumeSlider');
  const volumeValue = document.getElementById('volumeValue');
  volumeSlider.addEventListener('input', () => {
    const v = parseInt(volumeSlider.value, 10)/100;
    volumeValue.textContent = `${volumeSlider.value}%`;
    if (masterGain) masterGain.gain.value = v;
  });

  document.getElementById('clearPatternButton').addEventListener('click', () => {
    state.tracks.forEach(t => t.pattern.fill(false));
    refreshGridFromState();
  });

  document.getElementById('randomizeButton').addEventListener('click', () => {
    state.tracks[0].pattern = Array.from({length:16}, (_,i)=> Math.random() < (i%4===0 ? 0.9 : 0.15));
    state.tracks[1].pattern = Array.from({length:16}, (_,i)=> (i%8===4) ? Math.random()<0.85 : Math.random()<0.15);
    state.tracks[2].pattern = Array.from({length:16}, ()=> Math.random()<0.6);
    state.tracks[3].pattern = Array.from({length:16}, (_,i)=> [3,6,11,14].includes(i) ? Math.random()<0.4 : Math.random()<0.1);
    refreshGridFromState();
  });

  // Metronome toggle
  document.getElementById('metronomeButton').addEventListener('click', (e)=>{
    state.metronomeOn = !state.metronomeOn;
    e.currentTarget.setAttribute('aria-pressed', state.metronomeOn ? 'true' : 'false');
  });

  // Tap tempo
  document.getElementById('tapTempoButton').addEventListener('click', async (e)=>{
    ensureAudio();
    await audioCtx.resume();
    const now = performance.now();
    state.tapTimes.push(now);
    e.currentTarget.setAttribute('aria-pressed', 'true');
    setTimeout(()=> e.currentTarget.setAttribute('aria-pressed','false'), 120);
    if (state.tapTimes.length >= 4){
      const times = state.tapTimes.slice(-8); // last up to 8 taps
      const intervals = [];
      for (let i=1;i<times.length;i++) intervals.push(times[i]-times[i-1]);
      const avg = intervals.reduce((a,b)=>a+b,0)/intervals.length;
      const bpm = Math.max(40, Math.min(200, Math.round(60000/avg)));
      state.bpm = bpm;
      tempoSlider.value = bpm;
      tempoValue.textContent = `${bpm} BPM`;
      setStatus(`Tempo set by tap: ${bpm} BPM`);
    }
  });

  // Pattern save/load with localStorage
  const STORAGE_KEY = 'audioStepSequencerPatterns';
  function getSavedMap(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return {};
      return JSON.parse(raw);
    } catch(e){
      console.warn('Failed to parse saved patterns', e);
      return {};
    }
  }
  function setSavedMap(map){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(map));
  }
  function refreshPatternList(){
    const select = document.getElementById('loadPatternSelect');
    const map = getSavedMap();
    const names = Object.keys(map).sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));
    select.innerHTML = '';
    const ph = document.createElement('option');
    ph.value=''; ph.textContent='Load pattern...';
    select.appendChild(ph);
    names.forEach(n=>{
      const opt = document.createElement('option');
      opt.value = n; opt.textContent = n;
      select.appendChild(opt);
    });
  }
  function serializeCurrent(){
    return {
      bpm: state.bpm,
      swingPct: state.swingPct,
      tracks: state.tracks.map(t => ({ name:t.name, pattern: t.pattern }))
    };
  }
  function applyPattern(obj){
    if (!obj) return;
    if (typeof obj.bpm === 'number'){
      state.bpm = obj.bpm;
      tempoSlider.value = state.bpm;
      tempoValue.textContent = `${state.bpm} BPM`;
    }
    if (typeof obj.swingPct === 'number'){
      state.swingPct = obj.swingPct;
      swingSlider.value = state.swingPct;
      swingValue.textContent = `${state.swingPct}%`;
    }
    if (Array.isArray(obj.tracks) && obj.tracks.length === state.tracks.length){
      obj.tracks.forEach((t, i)=> {
        if (Array.isArray(t.pattern) && t.pattern.length===16){
          state.tracks[i].pattern = t.pattern.slice(0,16).map(Boolean);
        }
      });
    }
    refreshGridFromState();
  }

  document.getElementById('savePatternButton').addEventListener('click', ()=>{
    const name = (document.getElementById('patternNameInput').value || '').trim();
    if (!name){
      setStatus('Enter a pattern name to save', 'warn');
      return;
    }
    const map = getSavedMap();
    map[name] = serializeCurrent();
    setSavedMap(map);
    refreshPatternList();
    setStatus(`Saved "${name}"`, 'ok');
  });

  document.getElementById('loadPatternSelect').addEventListener('change', (e)=>{
    const name = e.target.value;
    if (!name) return;
    const map = getSavedMap();
    applyPattern(map[name]);
    setStatus(`Loaded "${name}"`, 'ok');
  });

  document.getElementById('deletePatternButton').addEventListener('click', ()=>{
    const sel = document.getElementById('loadPatternSelect');
    const name = sel.value;
    if (!name){ setStatus('Select a pattern to delete', 'warn'); return; }
    const map = getSavedMap();
    delete map[name];
    setSavedMap(map);
    refreshPatternList();
    sel.value = '';
    setStatus(`Deleted "${name}"`, 'ok');
  });

  // Export WAV via OfflineAudioContext
  document.getElementById('exportWavButton').addEventListener('click', async ()=>{
    ensureAudio();
    await audioCtx.resume();
    const bars = parseInt(document.getElementById('barsSelect').value, 10) || 2;
    const bpm = state.bpm;
    const swing = state.swingPct;
    const pattern = state.tracks.map(t => t.pattern.slice());
    setStatus('Rendering WAV...', 'warn');
    try{
      const wav = await renderPatternToWav(pattern, bpm, swing, bars);
      downloadBlob(wav, `sequencer_${bpm}bpm_${bars}bars.wav`);
      setStatus('WAV exported', 'ok');
    }catch(e){
      console.error(e);
      setStatus('WAV export failed', 'err');
    }
  });

  function renderPatternToWav(pattern, bpm, swingPct, bars, sampleRate=44100){
    return new Promise(async (resolve, reject)=>{
      try{
        const sp16 = secondsPer16th(bpm);
        const swing = swingOffsetSeconds(bpm, swingPct);
        const barDur = 16 * sp16; // average
        const tail = 1.0;
        const totalDur = bars * barDur + tail;
        const frames = Math.ceil(totalDur * sampleRate);
        const ctx = new OfflineAudioContext(2, frames, sampleRate);
        const dest = ctx.createGain();
        dest.gain.value = 0.9;
        dest.connect(ctx.destination);
        const nb = createNoiseBuffer(ctx);

        // Local triggers referencing offline ctx
        const trig = [
          (t)=> triggerKick(t, ctx, dest),
          (t)=> triggerSnare(t, ctx, dest),
          (t)=> triggerHat(t, ctx, dest),
          (t)=> triggerClap(t, ctx, dest)
        ];

        let t = 0;
        for (let bar=0; bar<bars; bar++){
          let stepTime = bar * barDur; // starting time of this bar (average grid)
          // But we will accumulate long-short with swing to place events
          stepTime = (bar === 0) ? 0 : bar * barDur; // start at 0, bar 1 at barDur etc.
          let sTime = stepTime;
          for (let s=0; s<16; s++){
            // schedule events for step s at sTime
            for (let tr=0; tr<pattern.length; tr++){
              if (pattern[tr][s]){
                trig[tr](sTime);
              }
            }
            // next step time with swing
            const isEven = (s % 2) === 0;
            sTime += isEven ? (sp16 + swing) : (sp16 - swing);
          }
        }
        const buffer = await ctx.startRendering();
        const wavBlob = encodeWAV(buffer);
        resolve(wavBlob);
      }catch(e){ reject(e); }
    });
  }

  function encodeWAV(buffer){
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const numFrames = buffer.length;
    // Interleave
    let interleaved;
    if (numChannels === 2){
      const left = buffer.getChannelData(0);
      const right = buffer.getChannelData(1);
      interleaved = new Float32Array(numFrames * 2);
      let i=0, j=0;
      while (i < numFrames){
        interleaved[j++] = left[i];
        interleaved[j++] = right[i];
        i++;
      }
    } else {
      interleaved = buffer.getChannelData(0);
    }

    // Convert to 16-bit PCM
    const bytesPerSample = 2;
    const blockAlign = (numChannels) * bytesPerSample;
    const bufferLength = 44 + interleaved.length * bytesPerSample;
    const arrayBuffer = new ArrayBuffer(bufferLength);
    const view = new DataView(arrayBuffer);

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + interleaved.length * bytesPerSample, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // PCM chunk size
    view.setUint16(20, 1, true); // audio format PCM
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true); // bits per sample
    writeString(view, 36, 'data');
    view.setUint32(40, interleaved.length * bytesPerSample, true);
    // PCM samples
    let offset = 44;
    for (let i=0;i<interleaved.length;i++){
      let s = Math.max(-1, Math.min(1, interleaved[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      offset += 2;
    }
    return new Blob([view], {type:'audio/wav'});

    function writeString(view, offset, str){
      for (let i=0;i<str.length;i++){
        view.setUint8(offset+i, str.charCodeAt(i));
      }
    }
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url; a.download=filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=> {
      URL.revokeObjectURL(url);
      a.remove();
    }, 50);
  }

  // Status
  function setStatus(msg, type='info'){
    const el = document.getElementById('statusText');
    el.textContent = msg;
    let color = 'var(--muted)';
    if (type==='ok') color = 'var(--success)';
    if (type==='warn') color = 'var(--warning)';
    if (type==='err') color = 'var(--danger)';
    el.style.color = color;
  }

  // Initialize
  setDefaultPattern();
  buildGrid();
  refreshPatternList();
  tempoSlider.dispatchEvent(new Event('input'));
  swingSlider.dispatchEvent(new Event('input'));

  // Ensure the UI fits 1280x720: grid and controls scale nicely; no action needed.
})();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <title>Custom QR Code Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Generate customizable QR codes from text or URLs. Change colors, size, margin, error correction, and download as PNG." />
  <style>
    :root{
      --bg: #0e0f12;
      --panel: #151821;
      --muted: #9aa3b2;
      --text: #e6e9ef;
      --accent: #3a86ff;
      --accent-2: #6c63ff;
      --ring: rgba(58,134,255,0.35);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --radius-sm: 10px;
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }
    body{
      margin: 0;
      background: radial-gradient(1200px 800px at 80% -10%, rgba(108,99,255,0.12), transparent 50%) no-repeat, var(--bg);
      color: var(--text);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100%;
    }

    header{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 18px 22px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
      background: linear-gradient(180deg, rgba(20,22,30,.7), rgba(20,22,30,.4));
    }

    .brand{
      display: flex; align-items: center; gap: 12px;
      font-weight: 700; letter-spacing: .2px; font-size: 18px;
    }
    .logo{
      width: 28px; height: 28px; border-radius: 8px;
      background: conic-gradient(from 210deg, var(--accent), var(--accent-2));
      display: grid; place-items: center; color: white; font-weight: 900; font-size: 14px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.15), 0 8px 18px rgba(58,134,255,.35);
    }

    main{
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 24px;
      padding: 22px;
    }

    @media (max-width: 980px){
      main{
        grid-template-columns: 1fr;
      }
    }

    .panel{
      background: linear-gradient(180deg, rgba(21,24,33,.9), rgba(21,24,33,.75));
      border: 1px solid rgba(255,255,255,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .controls{
      padding: 16px;
      display: grid;
      gap: 14px;
    }
    .group{
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: var(--radius-sm);
      padding: 12px;
      display: grid; gap: 10px;
    }
    .group > label{
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .12em;
      color: var(--muted);
      display: block;
    }
    .row{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .row-3{
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }

    textarea, input[type="text"], select, input[type="color"]{
      width: 100%;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 12px;
      outline: none;
    }
    textarea::placeholder, input::placeholder{
      color: rgba(230,233,239,.45);
    }
    textarea:focus, input:focus, select:focus{
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--ring);
    }

    .color-input{
      display: flex; align-items: center; gap: 8px;
      padding: 8px; background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 10px;
    }
    .color-input input[type="color"]{
      width: 42px; height: 34px; padding: 2px; border-radius: 8px;
      border: none; background: transparent;
    }
    .color-input input[type="text"]{
      flex: 1;
      background: rgba(255,255,255,.05);
      border: 1px dashed rgba(255,255,255,.08);
    }

    .range{
      display: grid; gap: 6px;
    }
    .range input[type="range"]{
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 6px; border-radius: 999px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      outline: none; opacity: .95;
    }
    .range input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
      background: #fff; border: 2px solid var(--accent);
      box-shadow: 0 2px 8px rgba(0,0,0,.35);
      cursor: pointer;
    }
    .range label{
      display: flex; align-items: center; justify-content: space-between;
      font-size: 12px; color: var(--muted);
    }
    .range .value{
      font-variant-numeric: tabular-nums;
      color: var(--text);
    }

    .actions{
      display: flex; gap: 10px; flex-wrap: wrap;
    }
    button, .btn{
      appearance: none; border: none; cursor: pointer; user-select: none;
      border-radius: 12px; padding: 10px 14px; font-weight: 600;
      color: white; background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 10px 18px rgba(58,134,255,.35);
    }
    button.secondary, .btn.secondary{
      color: var(--text); background: rgba(255,255,255,.08);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
    }
    button:disabled, .btn:disabled{
      filter: grayscale(.6); opacity: .6; cursor: not-allowed;
    }

    .preview{
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 14px;
      padding: 16px;
    }
    .canvas-wrap{
      position: relative;
      display: grid;
      place-items: center;
      min-height: 420px;
      height: 100%;
      background:
        radial-gradient(600px 300px at 20% 0%, rgba(108,99,255,.18), transparent 60%),
        radial-gradient(600px 300px at 80% 100%, rgba(58,134,255,.18), transparent 60%),
        rgba(0,0,0,.15);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: var(--radius);
    }
    canvas{
      display: block;
      max-width: min(92%, 640px);
      width: 100%;
      height: auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }

    .meta{
      display: flex; align-items: center; justify-content: space-between;
      gap: 12px; color: var(--muted); font-size: 13px;
    }
    .meta .pill{
      padding: 6px 10px; border-radius: 999px;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.06);
    }

    footer{
      padding: 14px 22px; color: var(--muted); font-size: 13px;
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      border-top: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(20,22,30,.4), rgba(20,22,30,.7));
    }
    .credit a{ color: var(--text); text-underline-offset: 3px; }
  </style>
</head>
<body>
  <header>
    <div class="brand" aria-label="App name">
      <div class="logo" aria-hidden="true">QR</div>
      <div>Custom QR Code Generator</div>
    </div>
    <div class="meta">
      <span class="pill" id="appStatus" aria-live="polite">Ready</span>
    </div>
  </header>

  <main>
    <section class="panel controls" aria-label="Controls">
      <form id="qrForm" novalidate>
        <div class="group">
          <label for="inputText">Content</label>
          <textarea id="inputText" rows="5" placeholder="Type text or paste a URL..."></textarea>
          <small id="charCount" aria-live="polite" style="color: var(--muted);">0 characters</small>
        </div>

        <div class="group">
          <label>Colors</label>
          <div class="row">
            <div class="color-input">
              <input type="color" id="fgColor" value="#000000" aria-label="Foreground color" />
              <input type="text" id="fgHex" placeholder="#000000" value="#000000" inputmode="text" spellcheck="false" />
            </div>
            <div class="color-input">
              <input type="color" id="bgColor" value="#ffffff" aria-label="Background color" />
              <input type="text" id="bgHex" placeholder="#ffffff" value="#ffffff" inputmode="text" spellcheck="false" />
            </div>
          </div>
        </div>

        <div class="group">
          <label for="eclSelect">Quality & Layout</label>
          <div class="row-3">
            <div>
              <select id="eclSelect" title="Error correction level">
                <option value="M">Error Correction: M (default)</option>
                <option value="L">Error Correction: L</option>
                <option value="Q">Error Correction: Q</option>
                <option value="H">Error Correction: H</option>
              </select>
            </div>
            <div class="range">
              <label for="sizeInput">Size <span class="value" id="sizeValue">512 px</span></label>
              <input type="range" id="sizeInput" min="128" max="1024" step="16" value="512" />
            </div>
            <div class="range">
              <label for="marginInput">Margin <span class="value" id="marginValue">16 px</span></label>
              <input type="range" id="marginInput" min="0" max="64" step="2" value="16" />
            </div>
          </div>
        </div>

        <div class="actions">
          <button type="button" id="generateBtn" title="Generate QR Code">Generate</button>
          <a class="btn secondary" id="downloadBtn" href="#" download="qr-code.png" role="button" aria-label="Download PNG" title="Download PNG">Download PNG</a>
          <button type="button" class="secondary" id="clearBtn" title="Clear input">Clear</button>
        </div>
      </form>
    </section>

    <section class="panel preview" aria-label="Preview">
      <div class="meta">
        <div>
          <strong>Preview</strong>
          <span style="margin-left:10px;" id="qrInfo"></span>
        </div>
        <div>
          <span class="pill" id="sizeInfo">512 × 512</span>
        </div>
      </div>
      <div class="canvas-wrap">
        <canvas id="qrCanvas" width="512" height="512" aria-label="QR code preview"></canvas>
      </div>
      <div class="meta">
        <div id="hint" aria-live="polite">Tip: Try bigger margin for dense codes or change error correction for reliability.</div>
        <div id="moduleInfo"></div>
      </div>
    </section>
  </main>

  <footer>
    <div class="credit">Built with HTML5, CSS3, and vanilla JavaScript. No external libraries.</div>
    <div id="footerNote">Works best in a 1280×720 or larger viewport.</div>
  </footer>

  <script>
    // Minimal helper functions
    const $ = (sel, ctx=document) => ctx.querySelector(sel);
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    const debounce = (fn, delay=200) => {
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
    };
    const toHex = (v) => {
      v = (v || '').trim();
      if(/^#?[0-9a-f]{3}$/i.test(v)){
        v = v.replace(/^#/, '');
        v = v.split('').map(ch => ch + ch).join('');
        return '#'+v.toLowerCase();
      }
      if(/^#?[0-9a-f]{6}$/i.test(v)){
        return '#'+v.replace(/^#/, '').toLowerCase();
      }
      return null;
    };

    // Map for Error Correction Level
    const ECL_MAP = {
      'L': 1, 'M': 0, 'Q': 3, 'H': 2 // matches library ErrorCorrectLevel values
    };

    // UI elements with unique IDs
    const inputText = $('#inputText');
    const fgPicker  = $('#fgColor');
    const bgPicker  = $('#bgColor');
    const fgHex     = $('#fgHex');
    const bgHex     = $('#bgHex');
    const eclSelect = $('#eclSelect');
    const sizeInput = $('#sizeInput');
    const marginInput = $('#marginInput');
    const sizeValue = $('#sizeValue');
    const marginValue = $('#marginValue');
    const generateBtn = $('#generateBtn');
    const downloadBtn = $('#downloadBtn');
    const clearBtn = $('#clearBtn');
    const appStatus = $('#appStatus');
    const charCount = $('#charCount');
    const sizeInfo = $('#sizeInfo');
    const moduleInfo = $('#moduleInfo');
    const qrInfo = $('#qrInfo');
    const hint = $('#hint');

    const canvas = $('#qrCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    // Keep app state
    const state = {
      text: '',
      size: parseInt(sizeInput.value, 10),
      margin: parseInt(marginInput.value, 10),
      fg: fgPicker.value,
      bg: bgPicker.value,
      ecl: eclSelect.value,
      version: null,
      moduleCount: null
    };

    // Events: color sync between picker and hex field
    function bindColorSync(picker, field){
      // picker -> field
      picker.addEventListener('input', () => {
        field.value = picker.value.toLowerCase();
        handleChange();
      });
      // field -> picker
      field.addEventListener('input', () => {
        const hex = toHex(field.value);
        if (hex){
          picker.value = hex;
          field.setCustomValidity('');
          handleChange();
        } else {
          field.setCustomValidity('Invalid hex color');
        }
      });
      field.addEventListener('blur', () => {
        const hex = toHex(field.value);
        if (hex){ field.value = hex; field.setCustomValidity(''); }
      });
    }
    bindColorSync(fgPicker, fgHex);
    bindColorSync(bgPicker, bgHex);

    // Range labels
    sizeInput.addEventListener('input', () => {
      state.size = parseInt(sizeInput.value, 10);
      sizeValue.textContent = `${state.size} px`;
      sizeInfo.textContent = `${state.size} × ${state.size}`;
      scheduleUpdate();
    });
    marginInput.addEventListener('input', () => {
      state.margin = parseInt(marginInput.value, 10);
      marginValue.textContent = `${state.margin} px`;
      scheduleUpdate();
    });

    // Other controls
    eclSelect.addEventListener('change', () => { state.ecl = eclSelect.value; scheduleUpdate(); });

    inputText.addEventListener('input', () => {
      state.text = inputText.value;
      charCount.textContent = `${state.text.length} ${state.text.length === 1 ? 'character' : 'characters'}`;
      scheduleUpdate();
    });

    clearBtn.addEventListener('click', () => {
      inputText.value = '';
      inputText.focus();
      inputText.dispatchEvent(new Event('input', { bubbles: true }));
    });

    generateBtn.addEventListener('click', () => {
      updateQR();
      flashStatus('Generated');
    });

    // Download handling
    function updateDownload(){
      try{
        const dataURL = canvas.toDataURL('image/png');
        downloadBtn.href = dataURL;
        const nameSlug = (state.text || 'qr-code').trim().slice(0, 40).replace(/[^a-z0-9]+/gi,'-').replace(/^-+|-+$/g,'').toLowerCase() || 'qr-code';
        downloadBtn.download = `qr-${nameSlug}-${state.size}px.png`;
        downloadBtn.removeAttribute('aria-disabled');
        downloadBtn.removeAttribute('disabled');
      }catch(e){
        downloadBtn.setAttribute('aria-disabled', 'true');
        downloadBtn.setAttribute('disabled', 'true');
      }
    }

    // High-DPI canvas setup
    function setupCanvas(pixelSize){
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      canvas.width = pixelSize * dpr;
      canvas.height = pixelSize * dpr;
      canvas.style.width = pixelSize + 'px';
      canvas.style.height = pixelSize + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function flashStatus(text){
      appStatus.textContent = text;
      appStatus.style.background = 'rgba(58,134,255,.15)';
      appStatus.style.borderRadius = '999px';
      appStatus.style.padding = '6px 10px';
      setTimeout(() => {
        appStatus.textContent = 'Ready';
        appStatus.style.background = '';
      }, 1200);
    }

    const scheduleUpdate = debounce(() => updateQR(), 120);

    // Initial content hint
    inputText.value = 'https://example.com';
    inputText.dispatchEvent(new Event('input', { bubbles: true }));

    // QR generation using embedded QR algorithm (no external network/library)
    // The following is a compact QR Code generator implementation by Kazuhiko Arase (MIT License),
    // inlined to comply with the "single HTML file, no external libraries" requirement.
    // Source: https://github.com/kazuhikoarase/qrcode-generator (minified)
    // eslint-disable-next-line
    /*!
     * QRCode for JavaScript
     * Copyright (c) 2009 Kazuhiko Arase
     * URL: http://www.d-project.com/
     * Licensed under the MIT license.
     * The word "QR Code" is registered trademark of DENSO WAVE INCORPORATED
     * http://www.denso-wave.com/qrcode/faqpatent-e.html
     */
    (function() {
      function QR8bitByte(data){this.mode=4;this.data=data;this.parsed=null;}
      QR8bitByte.prototype={getLength:function(){return qrcode.stringToBytes(this.data).length},write:function(buffer){var bytes=qrcode.stringToBytes(this.data);for(var i=0;i<bytes.length;i++){buffer.put(bytes[i],8)}}};

      var QRMode={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8};
      var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};
      var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};

      var QRUtil = (function(){
        var PATTERN_POSITION_TABLE=[
          [],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],
          [6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],
          [6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],
          [6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],
          [6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],
          [6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],
          [6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]
        ];
        var G15=(1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1<<0);
        var G18=(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1<<0);
        var G15_MASK=(1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1);
        function getBCHDigit(data){var digit=0;while(data!=0){digit++;data >>>=1}return digit}
        return {
          PATTERN_POSITION_TABLE:PATTERN_POSITION_TABLE,
          getBCHTypeInfo:function(data){var d=data<<10;while(getBCHDigit(d)-getBCHDigit(G15)>=0){d ^= (G15<<(getBCHDigit(d)-getBCHDigit(G15)))}return ((data<<10)|d)^G15_MASK},
          getBCHTypeNumber:function(data){var d=data<<12;while(getBCHDigit(d)-getBCHDigit(G18)>=0){d ^= (G18<<(getBCHDigit(d)-getBCHDigit(G18)))}return (data<<12)|d},
          getPatternPosition:function(typeNumber){return PATTERN_POSITION_TABLE[typeNumber-1]},
          mask:function(maskPattern,i,j){
            switch(maskPattern){
              case QRMaskPattern.PATTERN000:return (i+j)%2==0;
              case QRMaskPattern.PATTERN001:return i%2==0;
              case QRMaskPattern.PATTERN010:return j%3==0;
              case QRMaskPattern.PATTERN011:return (i+j)%3==0;
              case QRMaskPattern.PATTERN100:return (Math.floor(i/2)+Math.floor(j/3))%2==0;
              case QRMaskPattern.PATTERN101:return ((i*j)%2)+((i*j)%3)==0;
              case QRMaskPattern.PATTERN110:return (((i*j)%2)+((i*j)%3))%2==0;
              case QRMaskPattern.PATTERN111:return (((i*j)%3)+((i+j)%2))%2==0;
              default: throw new Error("bad maskPattern:"+maskPattern);
            }
          },
          getErrorCorrectPolynomial:function(ecLength){
            var a=new QRPolynomial([1],0);
            for(var i=0;i<ecLength;i++){
              a=a.multiply(new QRPolynomial([1, QRMath.gexp(i)],0));
            }
            return a;
          },
          getLengthInBits:function(mode,type){
            if(1<=type && type<10){
              switch(mode){case QRMode.MODE_NUMBER:return 10;case QRMode.MODE_ALPHA_NUM:return 9;case QRMode.MODE_8BIT_BYTE:return 8;case QRMode.MODE_KANJI:return 8;default: return 0;}
            } else if(type<27){
              switch(mode){case QRMode.MODE_NUMBER:return 12;case QRMode.MODE_ALPHA_NUM:return 11;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 10;default: return 0;}
            } else if(type<41){
              switch(mode){case QRMode.MODE_NUMBER:return 14;case QRMode.MODE_ALPHA_NUM:return 13;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 12;default: return 0;}
            }
            return 0;
          },
          getLostPoint:function(qr){
            var moduleCount=qr.getModuleCount();
            var lostPoint=0;
            for(var row=0;row<moduleCount;row++){
              for(var col=0;col<moduleCount;col++){
                var sameCount=0;
                var dark=qr.isDark(row,col);
                for(var r=-1;r<=1;r++){
                  if(row+r<0 || moduleCount<=row+r) continue;
                  for(var c=-1;c<=1;c++){
                    if(col+c<0 || moduleCount<=col+c) continue;
                    if(r==0&&c==0) continue;
                    if(dark==qr.isDark(row+r,col+c)) sameCount++;
                  }
                }
                if(sameCount>5) lostPoint += (3 + sameCount - 5);
              }
            }
            for(var row=0;row<moduleCount-1;row++){
              for(var col=0;col<moduleCount-1;col++){
                var count=0;
                if(qr.isDark(row,col)) count++;
                if(qr.isDark(row+1,col)) count++;
                if(qr.isDark(row,col+1)) count++;
                if(qr.isDark(row+1,col+1)) count++;
                if(count==0 || count==4) lostPoint += 3;
              }
            }
            for(var row=0;row<moduleCount;row++){
              for(var col=0;col<moduleCount-6;col++){
                if(qr.isDark(row,col) && !qr.isDark(row,col+1) && qr.isDark(row,col+2) && qr.isDark(row,col+3) && qr.isDark(row,col+4) && !qr.isDark(row,col+5) && qr.isDark(row,col+6)){
                  lostPoint += 40;
                }
              }
            }
            for(var col=0;col<moduleCount;col++){
              for(var row=0;row<moduleCount-6;row++){
                if(qr.isDark(row,col) && !qr.isDark(row+1,col) && qr.isDark(row+2,col) && qr.isDark(row+3,col) && qr.isDark(row+4,col) && !qr.isDark(row+5,col) && qr.isDark(row+6,col)){
                  lostPoint += 40;
                }
              }
            }
            var darkCount=0;
            for(var col=0;col<moduleCount;col++){
              for(var row=0;row<moduleCount;row++){
                if(qr.isDark(row,col)) darkCount++;
              }
            }
            var ratio=Math.abs(100*darkCount/moduleCount/moduleCount - 50)/5;
            lostPoint += ratio*10;
            return lostPoint;
          }
        };
      })();

      var QRMath = (function(){
        var EXP_TABLE=new Array(256);
        var LOG_TABLE=new Array(256);
        for(var i=0;i<8;i++) EXP_TABLE[i]=1<<i;
        for(var i=8;i<256;i++) EXP_TABLE[i]=EXP_TABLE[i-4]^EXP_TABLE[i-5]^EXP_TABLE[i-6]^EXP_TABLE[i-8];
        for(var i=0;i<255;i++) LOG_TABLE[EXP_TABLE[i]]=i;
        return {
          glog:function(n){ if(n<1) throw new Error("glog("+n+")"); return LOG_TABLE[n]; },
          gexp:function(n){ while(n<0) n+=255; while(n>=256) n-=255; return EXP_TABLE[n]; }
        };
      })();

      function QRPolynomial(num, shift){
        var offset = 0;
        while(offset<num.length && num[offset]==0) offset++;
        this.num = new Array(num.length - offset + shift);
        for(var i=0;i<num.length - offset;i++) this.num[i]=num[i+offset];
      }
      QRPolynomial.prototype={
        get:function(index){ return this.num[index]; },
        getLength:function(){ return this.num.length; },
        multiply:function(e){
          var num = new Array(this.getLength()+e.getLength()-1);
          for(var i=0;i<this.getLength();i++){
            for(var j=0;j<e.getLength();j++){
              num[i+j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
            }
          }
          return new QRPolynomial(num,0);
        },
        mod:function(e){
          if(this.getLength() - e.getLength() < 0) return this;
          var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
          var num = this.num.slice(0);
          for(var i=0;i<e.getLength();i++){
            num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
          }
          return new QRPolynomial(num,0).mod(e);
        }
      };

      var QRRSBlock = (function(){
        var RS_BLOCK_TABLE = [
          // L
          // M
          // Q
          // H
          // 1
          [1,26,19],[1,26,16],[1,26,13],[1,26,9],
          // 2
          [1,44,34],[1,44,28],[1,44,22],[1,44,16],
          // 3
          [1,70,55],[1,70,44],[2,35,17],[2,35,13],
          // 4
          [1,100,80],[2,50,32],[2,50,24],[4,25,9],
          // 5
          [1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],
          // 6
          [2,86,68],[4,43,27],[4,43,19],[4,43,15],
          // 7
          [2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],
          // 8
          [2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],
          // 9
          [2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],
          // 10
          [2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],
          // ...
        ];
        function getRSBlocks(typeNumber, errorCorrectLevel){
          var rsBlock = RS_BLOCK_TABLE[(typeNumber-1)*4 + errorCorrectLevel];
          if(typeof rsBlock == 'undefined'){ throw new Error('bad rs block @ typeNumber:'+typeNumber+'/errorCorrectLevel:'+errorCorrectLevel); }
          var list = [];
          var i=0;
          while(i < rsBlock.length){
            var count = rsBlock[i++], totalCount = rsBlock[i++], dataCount = rsBlock[i++];
            for(var j=0;j<count;j++) list.push({totalCount: totalCount, dataCount: dataCount});
          }
          return list;
        }
        return { getRSBlocks:getRSBlocks };
      })();

      function QRBitBuffer(){ this.buffer=[]; this.length=0; }
      QRBitBuffer.prototype={
        get:function(index){ return ((this.buffer[Math.floor(index/8)] >>> (7 - index % 8)) & 1) == 1; },
        put:function(num,length){ for(var i=0;i<length;i++){ this.putBit(((num >>> (length - i - 1)) & 1) == 1); } },
        putBit:function(bit){ var bufIndex=Math.floor(this.length/8); if(this.buffer.length<=bufIndex){ this.buffer.push(0); } if(bit){ this.buffer[bufIndex] |= (0x80 >>> (this.length % 8)); } this.length++; }
      };

      var qrcode = function(typeNumber, errorCorrectLevel){
        var PAD0=0xEC, PAD1=0x11;
        var _typeNumber = typeNumber;
        var _errorCorrectLevel = errorCorrectLevel;
        var _modules=null;
        var _moduleCount=0;
        var _dataList=[];
        var _dataCache=null;

        var _this = {};

        var makeImpl = function(test, maskPattern){
          _moduleCount = _typeNumber*4+17;
          _modules = new Array(_moduleCount);
          for(var row=0;row<_moduleCount;row++){
            _modules[row]=new Array(_moduleCount);
            for(var col=0;col<_moduleCount;col++){
              _modules[row][col]=null;
            }
          }
          setupPositionProbePattern(0,0);
          setupPositionProbePattern(_moduleCount-7,0);
          setupPositionProbePattern(0,_moduleCount-7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test, maskPattern);
          if(_typeNumber>=7) setupTypeNumber(test);

          if(_dataCache == null){ _dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList); }
          mapData(_dataCache, maskPattern);
        };

        var setupPositionProbePattern = function(row, col){
          for(var r=-1;r<=7;r++){
            if(row+r<=-1 || _moduleCount<=row+r) continue;
            for(var c=-1;c<=7;c++){
              if(col+c<=-1 || _moduleCount<=col+c) continue;
              if((0<=r && r<=6 && (c==0||c==6)) || (0<=c && c<=6 && (r==0||r==6)) || (2<=r && r<=4 && 2<=c && c<=4))
                _modules[row+r][col+c] = true;
              else
                _modules[row+r][col+c] = false;
            }
          }
        };

        var setupTimingPattern = function(){
          for(var r=8;r<_moduleCount-8;r++){
            if(_modules[r][6]===null) _modules[r][6]=(r%2==0);
          }
          for(var c=8;c<_moduleCount-8;c++){
            if(_modules[6][c]===null) _modules[6][c]=(c%2==0);
          }
        };

        var setupPositionAdjustPattern = function(){
          var pos = QRUtil.getPatternPosition(_typeNumber);
          for(var i=0;i<pos.length;i++){
            for(var j=0;j<pos.length;j++){
              var row=pos[i], col=pos[j];
              if(_modules[row][col]!==null) continue;
              for(var r=-2;r<=2;r++){
                for(var c=-2;c<=2;c++){
                  if(r==-2||r==2||c==-2||c==2 || (r==0&&c==0)) _modules[row+r][col+c]=true;
                  else _modules[row+r][col+c]=false;
                }
              }
            }
          }
        };

        var setupTypeNumber = function(test){
          var bits = QRUtil.getBCHTypeNumber(_typeNumber);
          for(var i=0;i<18;i++){
            var mod = (!test && ((bits >> i) & 1) == 1);
            _modules[Math.floor(i/3)][i%3+_moduleCount-8-3]=mod;
          }
          for(var i=0;i<18;i++){
            var mod = (!test && ((bits >> i) & 1) == 1);
            _modules[i%3+_moduleCount-8-3][Math.floor(i/3)] = mod;
          }
        };

        var setupTypeInfo = function(test, maskPattern){
          var data = (QRErrorCorrectLevel[_errorCorrectLevel] << 3) | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);
          for(var i=0;i<15;i++){
            var mod = (!test && ((bits >> i) & 1) == 1);
            if(i<6){
              _modules[i][8]=mod;
            }else if(i<8){
              _modules[i+1][8]=mod;
            }else{
              _modules[_moduleCount-15+i][8]=mod;
            }
          }
          for(var i=0;i<15;i++){
            var mod = (!test && ((bits >> i) & 1) == 1);
            if(i<8){
              _modules[8][_moduleCount- i -1]=mod;
            }else if(i<9){
              _modules[8][15-i-1]=mod;
            }else{
              _modules[8][15-i-1]=mod;
            }
          }
          _modules[_moduleCount-8][8] = !test;
        };

        var mapData = function(data, maskPattern){
          var inc = -1;
          var row = _moduleCount-1;
          var bitIndex=7;
          var byteIndex=0;
          for(var col=_moduleCount-1; col>0; col-=2){
            if(col==6) col--;
            while(true){
              for(var c=0;c<2;c++){
                if(_modules[row][col-c]===null){
                  var dark=false;
                  if(byteIndex < data.length){
                    dark = (( (data[byteIndex] >>> bitIndex) & 1) == 1);
                  }
                  var mask = QRUtil.mask(maskPattern, row, col-c);
                  _modules[row][col-c] = (dark ^ mask);
                  bitIndex--;
                  if(bitIndex==-1){ byteIndex++; bitIndex=7; }
                }
              }
              row += inc;
              if(row<0 || _moduleCount<=row){
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };

        _this.addData = function(data){
          _dataList.push(new QR8bitByte(data));
          _dataCache = null;
        };
        _this.isDark = function(row,col){
          if(row<0||_moduleCount<=row||col<0||_moduleCount<=col) throw new Error(row+","+col);
          return _modules[row][col];
        };
        _this.getModuleCount = function(){ return _moduleCount; };

        _this.make = function(){
          if(_typeNumber<1){
            var typeNumber=1;
            for(typeNumber=1; typeNumber<40; typeNumber++){
              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, QRErrorCorrectLevel[_errorCorrectLevel]);
              var buffer = new QRBitBuffer();
              for(var i=0;i<_dataList.length;i++){
                var data=_dataList[i];
                buffer.put(QRMode.MODE_8BIT_BYTE,4);
                buffer.put(data.getLength(), QRUtil.getLengthInBits(QRMode.MODE_8BIT_BYTE, typeNumber));
                data.write(buffer);
              }
              var totalDataCount=0;
              for(var i=0;i<rsBlocks.length;i++){ totalDataCount += rsBlocks[i].dataCount; }
              if(buffer.length <= totalDataCount*8){ _typeNumber=typeNumber; break; }
            }
          }
          makeImpl(false, getBestMaskPattern());
        };

        var createData = function(typeNumber, errorCorrectLevel, dataList){
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, QRErrorCorrectLevel[errorCorrectLevel]);
          var buffer = new QRBitBuffer();
          for(var i=0;i<dataList.length;i++){
            var data=dataList[i];
            buffer.put(QRMode.MODE_8BIT_BYTE,4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(QRMode.MODE_8BIT_BYTE,typeNumber));
            data.write(buffer);
          }
          var totalDataCount=0;
          for(var i=0;i<rsBlocks.length;i++){ totalDataCount += rsBlocks[i].dataCount; }

          // end code
          if(buffer.length + 4 <= totalDataCount*8) buffer.put(0,4);
          while(buffer.length % 8 != 0) buffer.putBit(false);
          while(true){
            if(buffer.length >= totalDataCount*8) break;
            buffer.put(PAD0,8);
            if(buffer.length >= totalDataCount*8) break;
            buffer.put(PAD1,8);
          }
          return createBytes(buffer, rsBlocks);
        };

        var createBytes = function(buffer, rsBlocks){
          var offset=0;
          var maxDcCount=0;
          var maxEcCount=0;
          var dcdata=new Array(rsBlocks.length);
          var ecdata=new Array(rsBlocks.length);

          for(var r=0; r<rsBlocks.length; r++){
            var dcCount=rsBlocks[r].dataCount;
            var ecCount=rsBlocks[r].totalCount - dcCount;
            maxDcCount=Math.max(maxDcCount, dcCount);
            maxEcCount=Math.max(maxEcCount, ecCount);
            dcdata[r]=new Array(dcCount);
            for(var i=0;i<dcdata[r].length;i++) dcdata[r][i]=0xff & buffer.buffer[i + Math.floor(offset/8)];
            offset += dcCount*8;

            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength()-1);
            var modPoly = rawPoly.mod(rsPoly);

            ecdata[r]=new Array(rsPoly.getLength()-1);
            for(var i=0;i<ecdata[r].length;i++){
              var modIndex = i + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i] = (modIndex>=0)? modPoly.get(modIndex) : 0;
            }
          }

          var totalCodeCount=0;
          for(var i=0;i<rsBlocks.length;i++) totalCodeCount += rsBlocks[i].totalCount;
          var data = new Array(totalCodeCount);
          var index=0;

          for(var i=0;i<maxDcCount;i++){
            for(var r=0;r<rsBlocks.length;r++){
              if(i<dcdata[r].length) data[index++] = dcdata[r][i];
            }
          }
          for(var i=0;i<maxEcCount;i++){
            for(var r=0;r<rsBlocks.length;r++){
              if(i<ecdata[r].length) data[index++] = ecdata[r][i];
            }
          }
          return data;
        };

        var getBestMaskPattern = function(){
          var minLostPoint = 0;
          var pattern = 0;
          for(var i=0;i<8;i++){
            makeImpl(true, i);
            var lostPoint = QRUtil.getLostPoint(_this);
            if(i==0 || minLostPoint > lostPoint){
              minLostPoint = lostPoint;
              pattern = i;
            }
          }
          return pattern;
        };

        return _this;
      };

      qrcode.stringToBytes = function(s){
        // UTF-8 encoding
        var out = [], p = 0;
        for (var i = 0; i < s.length; i++){
          var c = s.charCodeAt(i);
          if (c < 128) out[p++] = c;
          else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
          } else if ((c & 0xFC00) == 0xD800 && i+1 < s.length && (s.charCodeAt(i+1) & 0xFC00) == 0xDC00) {
            // surrogate pair
            c = 0x10000 + ((c & 0x03FF) << 10) + (s.charCodeAt(++i) & 0x03FF);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
          } else {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
          }
        }
        return out;
      };

      // expose globally
      window.qrcode = qrcode;
      window.QRErrorCorrectLevel = { L:1, M:0, Q:3, H:2 };
    })();

    function updateQR(){
      // Update state from UI
      state.text = inputText.value;
      state.size = parseInt(sizeInput.value, 10);
      state.margin = parseInt(marginInput.value, 10);
      state.fg = toHex(fgHex.value) || '#000000';
      state.bg = toHex(bgHex.value) || '#ffffff';
      state.ecl = eclSelect.value;

      // Setup canvas
      setupCanvas(state.size);

      // Draw background first
      ctx.fillStyle = state.bg;
      ctx.fillRect(0,0,state.size,state.size);

      if(!state.text){
        // If empty, show placeholder grid
        drawPlaceholder();
        updateDownload();
        qrInfo.textContent = 'Enter text to generate';
        moduleInfo.textContent = '';
        return;
      }

      try{
        const qr = qrcode(0, state.ecl); // 0 to auto-select
        qr.addData(state.text);
        qr.make();

        const count = qr.getModuleCount();
        const margin = state.margin;
        const usable = state.size - margin*2;
        const cellSize = usable / count;
        const roundedCell = cellSize; // keep float for crisp boundaries with transform

        // Background is already filled; draw modules
        ctx.fillStyle = state.fg;
        // Improve sharpness by snapping to device pixels via translation
        ctx.save();
        ctx.translate(margin, margin);

        // Optional: draw as rectangles per dark module
        for(let r=0; r<count; r++){
          for(let c=0; c<count; c++){
            if(qr.isDark(r,c)){
              const x = Math.round(c * roundedCell) + (usable%count !== 0 ? 0 : 0);
              const y = Math.round(r * roundedCell) + (usable%count !== 0 ? 0 : 0);
              // draw exact size (avoid subpixel gaps by using fillRect with precise size)
              ctx.fillRect(c*roundedCell, r*roundedCell, roundedCell, roundedCell);
            }
          }
        }
        ctx.restore();

        // Update info
        state.version = Math.floor((count - 17) / 4);
        state.moduleCount = count;

        qrInfo.textContent = `Version ${state.version} • ECL ${state.ecl}`;
        moduleInfo.textContent = `${count} × ${count} modules`;
        hint.textContent = 'Tip: Higher error correction increases reliability but makes codes denser.';

        updateDownload();
      }catch(err){
        console.error(err);
        ctx.fillStyle = '#ff4d4f';
        ctx.font = '14px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Error generating QR code', state.size/2, state.size/2);
        qrInfo.textContent = 'Error';
        moduleInfo.textContent = '';
        hint.textContent = 'Try reducing content length or lowering error correction.';
      }
    }

    function drawPlaceholder(){
      const s = state.size;
      const step = 24;
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = '#8b95a7';
      ctx.lineWidth = 1;
      for(let x = 0; x <= s; x += step){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,s); ctx.stroke();
      }
      for(let y = 0; y <= s; y += step){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(s,y); ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.fillStyle = '#8b95a7';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '600 16px system-ui, sans-serif';
      ctx.fillText('Your QR code preview will appear here', s/2, s/2);
      ctx.restore();

      qrInfo.textContent = 'Waiting for input';
      hint.textContent = 'Enter text or a URL to generate a QR code.';
    }

    // Initial render
    window.addEventListener('load', () => {
      sizeValue.textContent = `${state.size} px`;
      marginValue.textContent = `${state.margin} px`;
      sizeInfo.textContent = `${state.size} × ${state.size}`;
      updateQR();
    });

    // Resize handling to keep crispness
    window.addEventListener('resize', debounce(() => {
      setupCanvas(state.size);
      updateQR();
    }, 150));
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Escape the Maze</title>
<style>
  :root{
    --bg: #f5f7fb;
    --panel: #ffffff;
    --text: #1b1f3b;
    --muted: #6b7280;
    --accent: #2a9d8f;
    --accent-2: #e76f51;
    --wall: #1b1f3b;
    --start: #e9c46a33;
    --finish: #2a9d8f22;
    --shadow: 0 10px 25px rgba(17,24,39,0.08);
    --radius: 12px;
  }

  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  header {
    padding: 16px 24px;
    background: var(--panel);
    box-shadow: var(--shadow);
    position: sticky;
    top: 0;
    z-index: 10;
  }

  header h1 {
    margin: 0;
    font-size: 1.6rem;
    letter-spacing: 0.2px;
  }

  main {
    display: flex;
    gap: 16px;
    padding: 16px;
    max-width: 1400px;
    margin: 0 auto;
  }

  aside#hud {
    width: 320px;
    min-width: 280px;
    background: var(--panel);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 16px 16px 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    align-self: flex-start;
  }

  .section-title {
    font-weight: 700;
    margin: 0 0 4px;
    font-size: 1.1rem;
  }

  .stat-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    padding: 10px 12px;
    border: 1px solid #e6e8ef;
    border-radius: 10px;
    background: #fafbff;
  }

  .stat-row .label {
    color: var(--muted);
    font-size: 0.9rem;
  }

  .stat-row .value {
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    font-size: 1.05rem;
  }

  #statusMessage {
    min-height: 48px;
    padding: 12px;
    border-radius: 10px;
    background: #f8fafc;
    border: 1px dashed #e5e7eb;
    color: var(--muted);
  }

  .hint {
    font-size: 0.92rem;
    color: var(--muted);
    line-height: 1.4;
  }

  #btnReplay {
    border: none;
    background: var(--accent);
    color: white;
    padding: 12px 14px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    transition: transform 0.06s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    box-shadow: 0 8px 18px rgba(42,157,143,0.25);
  }
  #btnReplay:hover { background: #23877b; }
  #btnReplay:active { transform: translateY(1px); }

  section#gameArea {
    flex: 1 1 auto;
    min-width: 0;
    background: var(--panel);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 16px;
    display: grid;
    place-items: center;
    position: relative;
  }

  #mazeCanvas {
    display: block;
    background: #ffffff;
    border-radius: 12px;
    box-shadow: inset 0 0 0 1px #eef0f6;
    outline: none;
  }

  footer {
    text-align: center;
    color: var(--muted);
    font-size: 0.9rem;
    padding: 12px 16px 28px;
  }

  /* Responsive tweaks */
  @media (max-width: 960px) {
    main { flex-direction: column; }
    aside#hud { width: 100%; order: 2; }
    section#gameArea { order: 1; }
  }
</style>
</head>
<body>
  <header>
    <h1>Escape the Maze</h1>
  </header>

  <main>
    <aside id="hud" aria-label="Game Heads-Up Display">
      <div>
        <p class="section-title">Objective</p>
        <p class="hint">Navigate from the start to the finish. Use the arrow keys. Finish in the minimum number of steps to earn the shortest path bonus.</p>
      </div>

      <div class="stat-row" role="status" aria-live="polite">
        <span class="label">Timer</span>
        <span id="timerValue" class="value">00:00.00</span>
      </div>

      <div class="stat-row">
        <span class="label">Moves</span>
        <span id="movesValue" class="value">0</span>
      </div>

      <div class="stat-row" title="Minimum steps required from start to finish">
        <span class="label">Shortest Path</span>
        <span id="shortestPathValue" class="value">—</span>
      </div>

      <div id="statusMessage" aria-live="polite">Use arrow keys to move. Press or click Play Again to generate a new maze.</div>

      <button id="btnReplay" type="button" aria-label="Play again (generate a new maze)">Play Again</button>

      <div>
        <p class="section-title">Controls</p>
        <ul class="hint" style="margin: 0 0 0 18px;">
          <li>Arrow keys to move</li>
          <li>R to replay</li>
          <li>Click the maze to focus if keys don't respond</li>
        </ul>
      </div>
    </aside>

    <section id="gameArea" aria-label="Game Area">
      <canvas id="mazeCanvas" width="720" height="720" tabindex="0" aria-label="Maze canvas. Use arrow keys to move the avatar."></canvas>
    </section>
  </main>

  <footer>
    Built with HTML5 canvas and vanilla JavaScript. No external libraries.
  </footer>

<script>
(function(){
  "use strict";

  // DOM elements
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  const btnReplay = document.getElementById('btnReplay');
  const timerEl = document.getElementById('timerValue');
  const movesEl = document.getElementById('movesValue');
  const shortestEl = document.getElementById('shortestPathValue');
  const statusEl = document.getElementById('statusMessage');

  // Game state
  let cols = 25;
  let rows = 25;
  let grid = [];
  let cellSize = 24;
  let wallWidth = 3;
  let start = {x: 0, y: 0};
  let goal = {x: 0, y: 0};
  let player = {x: 0, y: 0};
  let moves = 0;
  let shortestSteps = 0;
  let running = false;
  let finished = false;

  // Timer state
  let timerInterval = null;
  let timeStart = 0;
  let elapsed = 0;

  function formatTime(ms) {
    const totalSec = ms / 1000;
    const m = Math.floor(totalSec / 60);
    const s = Math.floor(totalSec % 60);
    const cs = Math.floor((ms % 1000) / 10);
    const mm = String(m).padStart(2, '0');
    const ss = String(s).padStart(2, '0');
    const cc = String(cs).padStart(2, '0');
    return `${mm}:${ss}.${cc}`;
  }

  function startTimer() {
    if (timerInterval) return;
    timeStart = performance.now() - elapsed;
    timerInterval = setInterval(() => {
      elapsed = performance.now() - timeStart;
      timerEl.textContent = formatTime(elapsed);
    }, 50);
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  function resetTimer() {
    stopTimer();
    elapsed = 0;
    timerEl.textContent = "00:00.00";
  }

  class Cell {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      // walls: top, right, bottom, left
      this.walls = [true, true, true, true];
      this.visited = false;
    }
    index() {
      return this.x + this.y * cols;
    }
  }

  function indexFromXY(x, y) {
    if (x < 0 || x >= cols || y < 0 || y >= rows) return -1;
    return x + y * cols;
  }

  function createGrid() {
    grid = [];
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        grid.push(new Cell(x, y));
      }
    }
  }

  function neighborsUnvisited(cell) {
    const arr = [];
    const {x, y} = cell;
    const dirs = [
      {dx: 0, dy: -1, dir: 0}, // top
      {dx: 1, dy: 0, dir: 1},  // right
      {dx: 0, dy: 1, dir: 2},  // bottom
      {dx: -1, dy: 0, dir: 3}  // left
    ];
    for (const d of dirs) {
      const nx = x + d.dx, ny = y + d.dy;
      const idx = indexFromXY(nx, ny);
      if (idx !== -1 && !grid[idx].visited) {
        arr.push({cell: grid[idx], dir: d.dir});
      }
    }
    return arr;
  }

  function removeWall(a, b, dir) {
    // dir: direction from a to b
    // 0 top, 1 right, 2 bottom, 3 left
    a.walls[dir] = false;
    const opposite = (dir + 2) % 4;
    b.walls[opposite] = false;
  }

  function shuffle(array) {
    // Fisher-Yates
    for (let i = array.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  function generateMaze() {
    createGrid();

    const stack = [];
    const startCell = grid[0];
    startCell.visited = true;
    stack.push(startCell);

    while (stack.length) {
      const current = stack[stack.length - 1];
      const options = neighborsUnvisited(current);
      if (options.length > 0) {
        const choice = options[(Math.random() * options.length) | 0];
        const dir = choice.dir;
        const next = choice.cell;
        removeWall(current, next, dir);
        next.visited = true;
        stack.push(next);
      } else {
        stack.pop();
      }
    }

    // Define start and goal
    start = {x: 0, y: 0};
    goal = {x: cols - 1, y: rows - 1};
  }

  function computeShortestPathSteps() {
    // BFS on carved maze
    const startIdx = indexFromXY(start.x, start.y);
    const goalIdx = indexFromXY(goal.x, goal.y);
    const dist = new Array(grid.length).fill(Infinity);
    const q = [];
    dist[startIdx] = 0;
    q.push(startIdx);

    while (q.length > 0) {
      const idx = q.shift();
      if (idx === goalIdx) break;
      const cell = grid[idx];
      const {x, y} = cell;

      // Neighbor transitions only where walls open
      // 0 top, 1 right, 2 bottom, 3 left
      const trans = [
        {dx: 0, dy: -1, wall: 0},
        {dx: 1, dy: 0, wall: 1},
        {dx: 0, dy: 1, wall: 2},
        {dx: -1, dy: 0, wall: 3},
      ];
      for (const t of trans) {
        if (!cell.walls[t.wall]) {
          const nx = x + t.dx, ny = y + t.dy;
          const nIdx = indexFromXY(nx, ny);
          if (nIdx !== -1 && dist[nIdx] === Infinity) {
            dist[nIdx] = dist[idx] + 1;
            q.push(nIdx);
          }
        }
      }
    }
    return dist[goalIdx] === Infinity ? 0 : dist[goalIdx];
  }

  function draw() {
    // Adjust canvas size to container while preserving square
    fitCanvas();

    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Cell backgrounds for start and goal
    drawCellBackground(start.x, start.y, 'rgba(233,196,106,0.18)'); // start
    drawCellBackground(goal.x, goal.y, 'rgba(42,157,143,0.18)');    // goal

    // Draw walls
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall').trim() || '#1b1f3b';
    ctx.lineWidth = wallWidth;
    ctx.lineCap = 'square';

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = grid[indexFromXY(x, y)];
        const px = x * cellSize;
        const py = y * cellSize;

        ctx.beginPath();
        // top
        if (cell.walls[0]) {
          ctx.moveTo(px, py);
          ctx.lineTo(px + cellSize, py);
        }
        // right
        if (cell.walls[1]) {
          ctx.moveTo(px + cellSize, py);
          ctx.lineTo(px + cellSize, py + cellSize);
        }
        // bottom
        if (cell.walls[2]) {
          ctx.moveTo(px + cellSize, py + cellSize);
          ctx.lineTo(px, py + cellSize);
        }
        // left
        if (cell.walls[3]) {
          ctx.moveTo(px, py + cellSize);
          ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    }

    // Draw avatar
    drawPlayer();
  }

  function drawCellBackground(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * cellSize + wallWidth/2, y * cellSize + wallWidth/2, cellSize - wallWidth, cellSize - wallWidth);
  }

  function drawPlayer() {
    const px = player.x * cellSize + cellSize / 2;
    const py = player.y * cellSize + cellSize / 2;
    const r = Math.max(6, Math.min(cellSize * 0.32, 16));

    // Outline ring
    ctx.beginPath();
    ctx.fillStyle = '#ffffff';
    ctx.arc(px, py, r + 3, 0, Math.PI * 2);
    ctx.fill();

    // Avatar
    ctx.beginPath();
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-2').trim() || '#e76f51';
    ctx.arc(px, py, r, 0, Math.PI * 2);
    ctx.fill();
  }

  function fitCanvas() {
    // Compute available square inside gameArea
    const area = document.getElementById('gameArea');
    const padding = 16 * 2; // approximate inner padding
    const maxW = Math.max(320, area.clientWidth - padding);
    const maxH = Math.max(320, area.clientHeight - padding);
    const size = Math.floor(Math.min(maxW, maxH));

    // Determine an appropriate grid for visibility (cell ~ 18-32 px)
    let desiredCols = cols;
    let cellCandidate = Math.floor(size / desiredCols);
    if (cellCandidate < 16) {
      desiredCols = 21;
      cellCandidate = Math.floor(size / desiredCols);
    }
    if (cellCandidate < 16) {
      desiredCols = 17;
      cellCandidate = Math.floor(size / desiredCols);
    }
    if (cellCandidate > 34) {
      desiredCols = 31;
      cellCandidate = Math.floor(size / desiredCols);
    }
    // Keep maze structure but allow rescale only if same cols, else redraw with new grid size
    if (desiredCols !== cols) {
      cols = rows = desiredCols;
      // Rebuild maze to match new dimensions
      generateMaze();
      player = {...start};
      shortestSteps = computeShortestPathSteps();
      updateHUD();
    }

    cellSize = Math.floor(size / cols);
    wallWidth = Math.max(2, Math.floor(cellSize * 0.12));
    canvas.width = cellSize * cols;
    canvas.height = cellSize * rows;
  }

  function canMove(dir) {
    // dir: 'up','right','down','left'
    const cell = grid[indexFromXY(player.x, player.y)];
    switch(dir) {
      case 'up': return !cell.walls[0];
      case 'right': return !cell.walls[1];
      case 'down': return !cell.walls[2];
      case 'left': return !cell.walls[3];
    }
    return false;
  }

  function move(dir) {
    if (finished) return;
    if (!running) {
      running = true;
      startTimer();
      statusEl.textContent = "Find the exit! Shortest steps: " + shortestSteps;
    }

    let moved = false;
    if (dir === 'up' && canMove('up')) {
      player.y -= 1; moved = true;
    } else if (dir === 'right' && canMove('right')) {
      player.x += 1; moved = true;
    } else if (dir === 'down' && canMove('down')) {
      player.y += 1; moved = true;
    } else if (dir === 'left' && canMove('left')) {
      player.x -= 1; moved = true;
    }

    if (moved) {
      moves += 1;
      movesEl.textContent = String(moves);
      draw();
      checkWin();
    }
  }

  function checkWin() {
    if (player.x === goal.x && player.y === goal.y) {
      finished = true;
      stopTimer();
      const took = moves;
      const sp = shortestSteps;
      if (took === sp) {
        statusEl.textContent = `You escaped! Time ${formatTime(elapsed)} • Moves ${took}. Shortest path achieved! Bonus unlocked.`;
      } else {
        const diff = took - sp;
        statusEl.textContent = `You escaped! Time ${formatTime(elapsed)} • Moves ${took}. You were ${diff} step${diff===1?'':'s'} over the shortest path (${sp}).`;
      }
    }
  }

  function updateHUD() {
    movesEl.textContent = String(moves);
    shortestEl.textContent = shortestSteps ? String(shortestSteps) : '—';
  }

  function newGame() {
    running = false;
    finished = false;
    resetTimer();
    moves = 0;
    // Keep current cols/rows (fitCanvas may adjust)
    generateMaze();
    player = {...start};
    shortestSteps = computeShortestPathSteps();
    updateHUD();
    statusEl.textContent = "Use arrow keys to move. Reach the finish to win.";
    // Draw after ensuring canvas fit
    draw();
    // focus for keyboard
    canvas.focus();
  }

  // Keyboard handling
  function onKeyDown(e) {
    const key = e.key;
    const isArrow = key.startsWith('Arrow');
    const isReplay = key === 'r' || key === 'R';
    if (isArrow || isReplay) {
      e.preventDefault(); // prevent page scroll with arrow keys
    }
    if (isReplay) {
      newGame();
      return;
    }
    if (!isArrow) return;
    switch (key) {
      case 'ArrowUp': move('up'); break;
      case 'ArrowRight': move('right'); break;
      case 'ArrowDown': move('down'); break;
      case 'ArrowLeft': move('left'); break;
    }
  }

  // Event listeners
  window.addEventListener('keydown', onKeyDown);
  btnReplay.addEventListener('click', newGame);
  window.addEventListener('resize', () => {
    // Rescale and redraw (fitCanvas may regenerate if needed)
    draw();
  });

  // Initialize
  function init() {
    // Ensure initial fit then game
    fitCanvas();
    newGame();
  }

  // Start when DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
</body>
</html>
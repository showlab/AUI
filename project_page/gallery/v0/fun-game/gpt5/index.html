<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <title>Fun Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Fun Game - Jump over obstacles to survive as long as possible. Colorful, cartoonish, with parallax backgrounds and funny sounds." />
  <style>
    :root{
      --bg1:#74d7ff;
      --bg2:#c9f8ff;
      --accent:#ff3ea5;
      --accent2:#ffb703;
      --accent3:#12d67a;
      --dark:#243447;
      --ground:#7a5c3f;
      --ground2:#6b4f33;
      --text:#072b4a;
      --panel:#ffffffcc;
      --shadow: rgba(0,0,0,0.2);
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: linear-gradient(180deg, var(--bg2), var(--bg1));
      overflow:hidden;
    }
    header{
      position:fixed;
      top:0; left:0; right:0;
      backdrop-filter: blur(6px);
      background: linear-gradient(90deg, #ffffffd9, #ffffffb6);
      box-shadow: 0 2px 12px var(--shadow);
      z-index:5;
    }
    .topbar{
      max-width: min(1280px, 100vw);
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 16px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:900; letter-spacing:0.5px; font-size:20px;
      color:var(--dark);
    }
    .brand .logo{
      width:28px; height:28px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, var(--accent2), var(--accent));
      box-shadow: 0 2px 6px var(--shadow) inset;
      position:relative;
      overflow:hidden;
    }
    .brand .logo:after{
      content:"";
      position:absolute; inset:2px;
      border-radius:50%;
      background: radial-gradient(circle at 60% 40%, #fff6, transparent 60%);
      mix-blend-mode: screen;
    }
    .hud{
      display:flex; align-items:center; gap:16px; flex-wrap:wrap;
    }
    .badge{
      background:var(--panel);
      padding:6px 10px; border-radius:10px;
      font-weight:700; color:var(--dark);
      box-shadow: 0 2px 6px var(--shadow);
      min-width: 110px;
      text-align:center;
    }
    .controls{
      display:flex; align-items:center; gap:8px;
    }
    button{
      appearance:none; border:none; cursor:pointer;
      padding:10px 14px; border-radius:999px;
      font-weight:800; color:white;
      background: linear-gradient(180deg, var(--accent), #c1298b);
      box-shadow: 0 6px 18px var(--shadow), 0 4px 0 #b21976 inset;
      transition: transform .05s ease, opacity .2s;
      user-select:none;
    }
    button.alt{
      background: linear-gradient(180deg, #00c389, #059669);
      box-shadow: 0 6px 18px var(--shadow), 0 4px 0 #047857 inset;
    }
    button.ghost{
      background: linear-gradient(180deg, #475569, #334155);
      box-shadow: 0 6px 18px var(--shadow), 0 4px 0 #1f2937 inset;
    }
    button:active{ transform: translateY(1px) scale(0.98); }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    main{
      height:100%;
      width:100%;
      display:grid;
      place-items:center;
      padding-top:64px; /* space for header */
    }
    .game-wrap{
      position:relative;
      width:min(96vw, 1280px);
      aspect-ratio:16/9;
      max-height: calc(100vh - 88px);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 24px 60px var(--shadow);
      background: linear-gradient(180deg, var(--bg2), var(--bg1) 60%);
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action: manipulation;
    }
    .overlay{
      position:absolute; inset:0; display:flex;
      align-items:center; justify-content:center;
      z-index:3; pointer-events:auto;
    }
    .panel{
      background:var(--panel);
      padding:24px;
      border-radius:16px;
      text-align:center;
      max-width:min(90%, 560px);
      box-shadow: 0 10px 30px var(--shadow);
      display:flex; flex-direction:column; gap:14px;
    }
    .panel h1{ margin:4px 0 6px 0; font-size:28px; }
    .panel p{ margin:0; line-height:1.35; }
    .panel .hint{
      font-size:14px; opacity:.8;
    }
    .hidden{ display:none !important; }
    .floating-btn{
      position:absolute;
      right:16px; bottom:16px;
      z-index:2;
      width:84px; height:84px;
      border-radius:50%;
      display:grid; place-items:center;
      background: radial-gradient(circle at 30% 30%, var(--accent2), var(--accent));
      color:#fff; font-weight:900;
      box-shadow: 0 12px 28px var(--shadow), inset 0 4px 0 #b21976;
      user-select:none;
      touch-action: manipulation;
    }
    .floating-btn span{
      transform: translateY(2px);
    }
    .legend{
      position:absolute;
      left:16px; bottom:16px;
      z-index:2;
      background:#ffffffcc;
      padding:10px 12px; border-radius:12px;
      box-shadow: 0 8px 24px var(--shadow);
      font-size:14px;
    }
    .sr{
      position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden;
    }
    footer{
      position:fixed; bottom:6px; width:100%; display:flex; justify-content:center;
      font-size:12px; color:#0008; pointer-events:none;
    }
    @media (max-width: 640px){
      .badge{ min-width: auto; }
      .topbar{ gap:8px; }
      .panel h1{ font-size:24px; }
    }
  </style>
</head>
<body>
  <a class="sr" href="#gameCanvas">Skip to game</a>
  <header>
    <div class="topbar" role="banner">
      <div class="brand" aria-label="Game title">
        <div class="logo" aria-hidden="true"></div>
        Fun Game
      </div>
      <div class="hud" role="status" aria-live="polite">
        <div class="badge">Score: <span id="scoreValue">0</span></div>
        <div class="badge">High: <span id="highScoreValue">0</span></div>
        <div class="controls">
          <button id="startButton" class="alt" title="Start the game">Start</button>
          <button id="muteButton" class="ghost" title="Toggle sound">ðŸ”Š Sound</button>
        </div>
      </div>
    </div>
  </header>

  <main role="main">
    <section class="game-wrap" id="gameContainer" aria-label="Game area">
      <canvas id="gameCanvas" width="1280" height="720" role="img" aria-label="Endless runner with cartoon character jumping over obstacles"></canvas>

      <div class="overlay" id="startOverlay" aria-hidden="false">
        <div class="panel" role="dialog" aria-modal="true" aria-labelledby="startTitle">
          <h1 id="startTitle">Welcome to Fun Game!</h1>
          <p>Goal: Jump over obstacles to survive as long as possible.</p>
          <p class="hint">Press Space / Up Arrow / W to jump. On touch devices, use the big Jump button.</p>
          <div style="display:flex; gap:10px; justify-content:center; margin-top:6px;">
            <button id="startButtonOverlay" class="alt">Start</button>
            <button id="muteButtonOverlay" class="ghost">ðŸ”Š Sound</button>
          </div>
        </div>
      </div>

      <div class="overlay hidden" id="gameOverOverlay" aria-hidden="true">
        <div class="panel" role="dialog" aria-modal="true" aria-labelledby="gameOverTitle">
          <h1 id="gameOverTitle">Bonk! Game Over</h1>
          <p>Final Score: <strong id="finalScore">0</strong></p>
          <p>High Score: <strong id="finalHighScore">0</strong></p>
          <div style="display:flex; gap:10px; justify-content:center; margin-top:6px;">
            <button id="retryButton" class="alt">Retry</button>
            <button id="shareButton" class="ghost" title="Copy score to clipboard">Share</button>
          </div>
        </div>
      </div>

      <button id="jumpButton" class="floating-btn" aria-label="Jump"><span>JUMP</span></button>
      <div class="legend">Tip: Hold jump a bit longer for a higher leap! Speed increases over time.</div>
    </section>
  </main>

  <footer>
    Made with vanilla JavaScript, HTML5 Canvas, and Web Audio. Have fun!
  </footer>

  <script>
  (function(){
    'use strict';

    // DOM references
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('scoreValue');
    const highScoreEl = document.getElementById('highScoreValue');
    const startBtn = document.getElementById('startButton');
    const muteBtn = document.getElementById('muteButton');
    const jumpBtn = document.getElementById('jumpButton');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const retryBtn = document.getElementById('retryButton');
    const shareBtn = document.getElementById('shareButton');
    const finalScoreEl = document.getElementById('finalScore');
    const finalHighScoreEl = document.getElementById('finalHighScore');
    const startBtnOverlay = document.getElementById('startButtonOverlay');
    const muteBtnOverlay = document.getElementById('muteButtonOverlay');
    const container = document.getElementById('gameContainer');

    // DPI scaling for crisp canvas
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // clamp for performance
    function resizeCanvas(){
      const rect = container.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing to CSS pixels
      // Update unit scaling relative to base 720 height
      U = height / 720;
    }
    let U = 1; // unit scaling based on height
    window.addEventListener('resize', resizeCanvas);

    // Game state
    const state = {
      running: false,
      gameOver: false,
      score: 0,
      highScore: Number(localStorage.getItem('funGameHighScore') || 0),
      speed: 8,          // base horizontal speed in px per frame at 60fps (scaled with dt)
      maxSpeed: 30,
      accel: 0.004,      // per ms
      spawnTimer: 0,
      nextSpawn: 1400,   // ms
      time: 0,
    };

    // Background layers
    let clouds = [];
    let hills = [];
    let groundDeco = [];

    // Player
    const player = {
      x: 110,
      y: 0,
      w: 58, h: 64,
      vy: 0,
      onGround: false,
      jumpHold: 0,
      maxJumpHold: 180, // ms for variable jump height
      jumping: false,
      runTime: 0,
      color: '#2dd4bf'
    };

    // Obstacles
    let obstacles = [];

    // Floor
    function groundY(){
      return canvas.clientHeight * 0.80; // use CSS pixel coordinates
    }

    // Input
    let keys = { Space:false, ArrowUp:false, KeyW:false };
    window.addEventListener('keydown', (e)=>{
      if (['Space','ArrowUp','KeyW'].includes(e.code)){
        e.preventDefault();
        keys[e.code] = true;
        tryJump();
      }else if(e.code === 'KeyM'){
        e.preventDefault();
        toggleMute();
      }else if(e.code === 'Enter' && !state.running){
        startGame();
      }
    }, {passive:false});
    window.addEventListener('keyup', (e)=>{
      if (['Space','ArrowUp','KeyW'].includes(e.code)){
        keys[e.code] = false;
        player.jumping = false;
        player.jumpHold = 0;
      }
    });

    jumpBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); tryJump(true); });
    jumpBtn.addEventListener('pointerup', (e)=>{ e.preventDefault(); player.jumping = false; player.jumpHold = 0; });
    jumpBtn.addEventListener('pointercancel', ()=>{ player.jumping = false; player.jumpHold = 0; });

    // Buttons
    function showStart(){
      startOverlay.classList.remove('hidden');
      startOverlay.setAttribute('aria-hidden','false');
      gameOverOverlay.classList.add('hidden');
      gameOverOverlay.setAttribute('aria-hidden','true');
      state.running = false;
      state.gameOver = false;
    }
    function showGameOver(){
      gameOverOverlay.classList.remove('hidden');
      gameOverOverlay.setAttribute('aria-hidden','false');
      startOverlay.classList.add('hidden');
      startOverlay.setAttribute('aria-hidden','true');
    }
    function hideOverlays(){
      startOverlay.classList.add('hidden');
      startOverlay.setAttribute('aria-hidden','true');
      gameOverOverlay.classList.add('hidden');
      gameOverOverlay.setAttribute('aria-hidden','true');
    }

    startBtn.addEventListener('click', startGame);
    startBtnOverlay.addEventListener('click', startGame);
    retryBtn.addEventListener('click', startGame);
    shareBtn.addEventListener('click', async()=>{
      const text = `I scored ${Math.floor(state.score)} in Fun Game! Can you beat me?`;
      try{
        await navigator.clipboard.writeText(text);
        shareBtn.textContent = 'Copied!';
        setTimeout(()=> shareBtn.textContent = 'Share', 1200);
      }catch{
        alert(text);
      }
    });

    // Sound
    let audioCtx = null;
    let muted = false;

    function ensureAudio(){
      if (!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended'){
        audioCtx.resume();
      }
    }
    function toggleMute(){
      muted = !muted;
      updateMuteButtons();
    }
    function updateMuteButtons(){
      const label = muted ? 'ðŸ”‡ Muted' : 'ðŸ”Š Sound';
      muteBtn.textContent = label;
      muteBtnOverlay.textContent = label;
      muteBtn.setAttribute('aria-pressed', String(!muted));
      muteBtnOverlay.setAttribute('aria-pressed', String(!muted));
    }
    muteBtn.addEventListener('click', ()=>{ ensureAudio(); toggleMute(); });
    muteBtnOverlay.addEventListener('click', ()=>{ ensureAudio(); toggleMute(); });

    function beep({type='sine', freq=440, duration=0.15, gain=0.12, attack=0.005, release=0.1, sweep=0}){
      if (!audioCtx || muted) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      if (sweep !== 0){
        osc.frequency.setValueAtTime(freq, now);
        osc.frequency.exponentialRampToValueAtTime(Math.max(50, freq * sweep), now + duration);
      }
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(gain, now + attack);
      g.gain.linearRampToValueAtTime(0.0001, now + Math.max(duration - release, attack));
      g.connect(audioCtx.destination);
      osc.connect(g);
      osc.start(now);
      osc.stop(now + duration + 0.02);
    }
    function soundJump(){
      beep({type:'sine', freq:320, duration:0.18, gain:0.15, sweep:1.8, attack:0.005, release:0.12});
      // add little pop
      setTimeout(()=>beep({type:'triangle', freq:520, duration:0.08, gain:0.08, sweep:1.2}), 50);
    }
    function soundCrash(){
      beep({type:'sawtooth', freq:220, duration:0.35, gain:0.2, sweep:0.5, attack:0.005, release:0.2});
      setTimeout(()=>beep({type:'square', freq:120, duration:0.25, gain:0.15, sweep:0.6}), 60);
    }
    function soundPoint(){
      beep({type:'triangle', freq:880, duration:0.1, gain:0.12});
      setTimeout(()=>beep({type:'triangle', freq:1320, duration:0.08, gain:0.1}), 80);
    }
    function soundStart(){
      beep({type:'square', freq:440, duration:0.08, gain:0.1});
      setTimeout(()=>beep({type:'square', freq:660, duration:0.08, gain:0.1}), 90);
      setTimeout(()=>beep({type:'square', freq:880, duration:0.1, gain:0.12}), 180);
    }

    // Start/reset game
    function initWorld(){
      state.score = 0;
      state.speed = 10;
      state.accel = 0.0009; // accelerate gently
      state.spawnTimer = 0;
      state.nextSpawn = 900;
      state.time = 0;
      obstacles = [];
      clouds = [];
      hills = [];
      groundDeco = [];

      // Player position
      player.w = 58 * U;
      player.h = 64 * U;
      player.x = 110 * U;
      player.y = groundY() - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumpHold = 0;
      player.jumping = false;
      player.runTime = 0;

      // Create background elements
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      // Clouds
      for (let i=0; i<8; i++){
        clouds.push({
          x: Math.random()*W,
          y: 60 + Math.random()*H*0.35,
          s: 0.3 + Math.random()*0.7, // scale
          v: 0.15 + Math.random()*0.25 // speed factor
        });
      }
      // Hills
      for (let i=0; i<6; i++){
        hills.push({
          x: Math.random()*W,
          y: H*0.72 + Math.random()*40*U,
          r: 80*U + Math.random()*180*U,
          v: 0.35 + Math.random()*0.35,
          hue: 130 + Math.random()*40
        });
      }
      // Ground decor (grass tufts)
      for (let i=0; i<14; i++){
        groundDeco.push({
          x: Math.random()*W, y: groundY()-6*U,
          v: 1,
          c: Math.random()<0.5 ? '#17c964' : '#10b981',
          s: 0.6 + Math.random()*1.2
        });
      }
    }

    function startGame(){
      ensureAudio();
      soundStart();
      hideOverlays();
      initWorld();
      state.running = true;
      state.gameOver = false;
      lastTime = performance.now();
      loop(lastTime);
    }

    // Jump logic with variable jump height
    function tryJump(fromPointer=false){
      if (!state.running){
        return;
      }
      // Only first interaction can resume audio on some devices
      ensureAudio();

      const canJump = player.onGround; // single jump
      if (canJump){
        player.vy = - (15 * U); // base jump impulse
        player.onGround = false;
        player.jumping = true;
        player.jumpHold = 0;
        soundJump();
        // visual squash
        player._squash = 1;
      }
    }

    // Spawn obstacles
    function spawnObstacle(){
      const H = canvas.clientHeight;
      const height = (30 + Math.random()*40) * U; // obstacle height
      const width = (24 + Math.random()*20) * U;
      const type = Math.random() < 0.5 ? 'box' : 'cactus';
      const color = type === 'box' ? '#ff3ea5' : '#ffb703';
      const face = Math.random()<0.7;

      obstacles.push({
        x: canvas.clientWidth + Math.random()*80,
        y: H*0.80 - height,
        w: width,
        h: height,
        type, color, face
      });
    }

    // Drawing helpers
    function drawSky(){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      // gradient background already via CSS, but add sun vignette
      const sunX = W*0.85, sunY = H*0.18, sunR = 50*U;
      ctx.save();
      const g = ctx.createRadialGradient(sunX, sunY, 8*U, sunX, sunY, sunR*3);
      g.addColorStop(0, 'rgba(255,243,174,0.9)');
      g.addColorStop(0.2,'rgba(255,243,174,0.7)');
      g.addColorStop(1, 'rgba(255,243,174,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR*2.2, 0, Math.PI*2);
      ctx.fill();
      // sun core
      ctx.fillStyle = '#ffe77a';
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    function drawCloud(x,y,s){
      ctx.save();
      ctx.translate(x,y);
      ctx.scale(s,s);
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.beginPath();
      ctx.arc(0, 0, 26, 0, Math.PI*2);
      ctx.arc(24, -6, 22, 0, Math.PI*2);
      ctx.arc(-24, -6, 18, 0, Math.PI*2);
      ctx.arc(10, 10, 18, 0, Math.PI*2);
      ctx.arc(-12, 10, 20, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    function drawHill(x,y,r,hue){
      ctx.save();
      ctx.fillStyle = `hsl(${hue} 45% 62%)`;
      ctx.beginPath();
      ctx.arc(x, y, r, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    function drawGround(){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      const gy = groundY();
      // ground base
      ctx.fillStyle = '#8a704e';
      ctx.fillRect(0, gy, W, H-gy);
      // stripes parallax
      const stripeH = 8*U;
      const t = state.time * 0.002;
      for (let i=0;i<Math.ceil((H-gy)/stripeH); i++){
        const y = gy + i*stripeH;
        ctx.fillStyle = i%2===0 ? '#7a5c3f' : '#6b4f33';
        ctx.fillRect(0, y, W, stripeH);
      }
      // ground line
      ctx.fillStyle = '#17c964';
      ctx.fillRect(0, gy-4*U, W, 4*U);
    }
    function drawGrassTuft(x,y,s,color){
      ctx.save();
      ctx.translate(x,y);
      ctx.scale(s,s);
      ctx.fillStyle = color;
      for(let i=0;i<5;i++){
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.quadraticCurveTo(-3+i*1.5, -10 - i*2, -1+i, -16 - i*1.4);
        ctx.quadraticCurveTo(2+i*0.5, -6 - i, 1.5+i, 0);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawPlayer(){
      const bob = Math.sin(player.runTime*10) * 1.5 * U;
      const x = player.x;
      const y = player.y + bob;
      const w = player.w;
      const h = player.h;

      // body (rounded blob)
      ctx.save();
      ctx.translate(x,y);
      const bodyColor = player.color;
      ctx.fillStyle = bodyColor;
      roundRect(-w*0.5, 0, w, h, 14*U);
      ctx.fill();

      // belly
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      roundRect(-w*0.35, h*0.15, w*0.7, h*0.55, 12*U);
      ctx.fill();

      // eyes
      ctx.fillStyle = '#152530';
      const eyeY = h*0.22;
      ctx.beginPath();
      ctx.arc(-w*0.14, eyeY, 5*U, 0, Math.PI*2);
      ctx.arc(w*0.14, eyeY, 5*U, 0, Math.PI*2);
      ctx.fill();
      // eye sparkle
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(-w*0.17, eyeY-2*U, 2*U, 0, Math.PI*2);
      ctx.arc(w*0.11, eyeY-2*U, 2*U, 0, Math.PI*2);
      ctx.fill();

      // mouth (smile)
      ctx.strokeStyle = '#152530';
      ctx.lineWidth = 2*U;
      ctx.beginPath();
      ctx.arc(0, h*0.35, 10*U, 0.15*Math.PI, 0.85*Math.PI);
      ctx.stroke();

      // legs animation (swinging)
      const swing = Math.sin(player.runTime*20)*6*U;
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 6*U;
      ctx.lineCap = 'round';
      // left leg
      ctx.beginPath();
      ctx.moveTo(-w*0.18, h*0.9);
      ctx.lineTo(-w*0.18 + swing*0.3, h + 10*U);
      ctx.stroke();
      // right leg
      ctx.beginPath();
      ctx.moveTo(w*0.18, h*0.9);
      ctx.lineTo(w*0.18 - swing*0.3, h + 10*U);
      ctx.stroke();

      ctx.restore();
    }

    function roundRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function drawObstacle(o){
      ctx.save();
      ctx.translate(o.x, o.y);
      // base
      ctx.fillStyle = o.color;
      const radius = 10*U;
      roundRect(0, 0, o.w, o.h, radius);
      ctx.fill();
      // cute face
      if (o.face){
        ctx.fillStyle = '#222';
        const cx = o.w*0.5;
        const cy = o.h*0.35;
        ctx.beginPath(); ctx.arc(cx - o.w*0.18, cy, 3.2*U, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + o.w*0.18, cy, 3.2*U, 0, Math.PI*2); ctx.fill();
        // smile
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2*U;
        ctx.beginPath();
        ctx.arc(cx, cy + 6*U, 7*U, 0.15*Math.PI, 0.85*Math.PI);
        ctx.stroke();
      }
      // cactus arms
      if (o.type === 'cactus'){
        ctx.fillStyle = '#32d17c';
        roundRect(o.w*0.1, o.h*0.2, o.w*0.2, o.h*0.4, 6*U);
        roundRect(o.w*0.7, o.h*0.3, o.w*0.2, o.h*0.35, 6*U);
      }
      ctx.restore();
    }

    // Collision detection (AABB with padding)
    function isColliding(){
      const shrink = 0.75; // forgiving factor
      const px = player.x - (player.w*0.5)*shrink;
      const py = player.y + player.h*(1-shrink);
      const pw = player.w*shrink;
      const ph = player.h*shrink;

      for (const o of obstacles){
        const ox = o.x, oy = o.y, ow = o.w, oh = o.h;
        if (px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
          return true;
        }
      }
      return false;
    }

    // Game loop
    let lastTime = performance.now();
    let nextPointMilestone = 100;

    function loop(now){
      if (!state.running) return;
      const dt = Math.min(32, now - lastTime); // clamp
      lastTime = now;
      state.time += dt;

      update(dt);
      render();

      if (state.running){
        requestAnimationFrame(loop);
      }
    }

    function update(dt){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      // Speed up over time, capped
      state.speed = Math.min(state.maxSpeed, state.speed + state.accel * dt * 60);

      // Player physics
      const g = 0.65 * U; // gravity
      const jumpBoost = 0.25 * U;
      if (player.jumping && player.jumpHold < player.maxJumpHold){
        player.vy -= jumpBoost * (dt/16.67);
        player.jumpHold += dt;
      }
      player.vy += g * (dt/16.67) * 10;
      player.y += player.vy;

      const gy = groundY() - player.h;
      if (player.y >= gy){
        player.y = gy;
        player.vy = 0;
        player.onGround = true;
      }else{
        player.onGround = false;
      }

      // Run animation time advances with speed when on ground
      if (player.onGround) player.runTime += (dt/1000) * (0.7 + state.speed*0.05);
      else player.runTime += (dt/1000)*0.4;

      // Spawn obstacles
      state.spawnTimer += dt;
      const minSpawn = Math.max(320, 1100 - state.speed*25);
      if (state.spawnTimer > state.nextSpawn){
        spawnObstacle();
        state.spawnTimer = 0;
        state.nextSpawn = minSpawn + Math.random()*minSpawn;
      }

      // Move obstacles
      for (let i=0; i<obstacles.length; i++){
        obstacles[i].x -= state.speed * (dt/16.67) * 8 * U;
      }
      // Remove offscreen
      obstacles = obstacles.filter(o => o.x + o.w > -20);

      // Score
      state.score += (dt/16.67) * (0.5 + state.speed*0.5);
      if (state.score >= nextPointMilestone){
        soundPoint();
        nextPointMilestone += 100;
      }

      // Background parallax updates
      for (const c of clouds){
        c.x -= (state.speed * 0.6 + 0.2) * c.v * (dt/16.67) * U;
        if (c.x < -80) c.x = W + 80;
      }
      for (const h of hills){
        h.x -= (state.speed * 0.45) * h.v * (dt/16.67) * U;
        if (h.x + h.r < -60) { h.x = W + h.r + Math.random()*80; h.r = 80*U + Math.random()*180*U; }
      }
      for (const gtuft of groundDeco){
        gtuft.x -= (state.speed * 1.2) * gtuft.v * (dt/16.67) * U;
        if (gtuft.x < -30) gtuft.x = W + Math.random()*200;
      }

      // Collisions
      if (isColliding()){
        gameOver();
      }

      // UI
      scoreEl.textContent = Math.floor(state.score);
      highScoreEl.textContent = Math.floor(state.highScore);
    }

    function render(){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      // Clear (transparent; background from container)
      ctx.clearRect(0,0,W,H);

      // Background layers (parallax)
      drawSky();

      // Far hills
      for (const h of hills){
        drawHill(h.x, h.y, h.r, h.hue);
      }

      // Clouds on top of hills
      for (const c of clouds){
        drawCloud(c.x, c.y, c.s*U);
      }

      // Ground
      drawGround();

      // Ground decor
      for (const gtuft of groundDeco){
        drawGrassTuft(gtuft.x, gtuft.y, gtuft.s*U, gtuft.c);
      }

      // Obstacles
      for (const o of obstacles){
        drawObstacle(o);
      }

      // Player
      drawPlayer();

      // Subtle speed indicator trail
      const barW = Math.min(1, (state.speed/state.maxSpeed)) * (W*0.25);
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      roundRect(W*0.5 - barW/2, 8*U, barW, 6*U, 3*U); ctx.fill();
    }

    function gameOver(){
      if (state.gameOver) return;
      state.gameOver = true;
      state.running = false;
      ensureAudio();
      soundCrash();
      // Update high score
      if (state.score > state.highScore){
        state.highScore = Math.floor(state.score);
        localStorage.setItem('funGameHighScore', String(state.highScore));
      }
      finalScoreEl.textContent = Math.floor(state.score);
      finalHighScoreEl.textContent = Math.floor(state.highScore);
      showGameOver();
    }

    // Initialize
    function boot(){
      resizeCanvas();
      updateMuteButtons();
      highScoreEl.textContent = Math.floor(state.highScore);
      showStart();
      render();
    }
    boot();

    // Accessibility: clicking canvas also jumps
    canvas.addEventListener('pointerdown', ()=>{
      tryJump(true);
    });

  })();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <title>Fruit Catcher - Falling Objects Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Catch the falling fruits with your basket. Fun, colorful, kid-friendly game using HTML5, CSS3, and vanilla JavaScript." />
  <style>
    :root{
      --bg1:#9be7ff;
      --bg2:#b8f5ff;
      --grass:#74d672;
      --ui:#ffffff;
      --text:#1b1b1b;
      --accent:#ff8a00;
      --accent2:#ff4d7a;
      --shadow:0 8px 16px rgba(0,0,0,.18);
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji";
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% -20%, #fff8, transparent 60%),
        radial-gradient(900px 500px at 80% -10%, #fff6, transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2) 70%, var(--grass) 70%, var(--grass));
      background-attachment: fixed;
      overflow: hidden;
      user-select: none;
    }

    header, footer {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
    }
    header {
      gap: 16px;
      flex-wrap: wrap;
    }
    header .bar {
      width: 100%;
      max-width: 1280px;
      background: color-mix(in srgb, var(--ui) 85%, #fff0);
      backdrop-filter: blur(6px);
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      padding: 10px 16px;
      gap: 12px;
    }
    h1 {
      font-size: clamp(18px, 2.2vw, 24px);
      margin: 0;
      color: #00334d;
      letter-spacing: .4px;
    }
    .scoreboard {
      display: inline-flex;
      align-items: center;
      gap: 14px;
      justify-self: center;
    }
    .score-item {
      background: #ffffff;
      padding: 6px 10px;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,.08) inset;
      font-weight: 700;
      color: #0b2233;
    }
    .score-item strong {
      color: var(--accent);
      margin-left: 6px;
      font-variant-numeric: tabular-nums;
    }
    .lives {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    #livesHearts {
      letter-spacing: 3px;
      font-size: 20px;
      filter: drop-shadow(0 1px 0 #fff);
    }

    /* Game Area */
    main {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px 12px 0;
    }
    #gameArea {
      position: relative;
      width: min(100vw - 24px, 1280px);
      height: clamp(500px, 72vh, 720px);
      background:
        linear-gradient(180deg, #d9f7ff 0%, #c7f3ff 50%, #bff0ff 70%),
        radial-gradient(180px 80px at 20% 20%, #fff, #ffffff00 70%),
        radial-gradient(160px 60px at 75% 30%, #fff, #ffffff00 70%);
      border-radius: 20px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    /* Decorative ground at bottom */
    #gameArea::after {
      content: "";
      position: absolute;
      left: 0; right: 0; bottom: 0;
      height: 18%;
      background:
        radial-gradient(70% 100% at 30% 100%, rgba(0,0,0,.06), transparent 60%),
        linear-gradient(180deg, #8be688, #64cc61);
      clip-path: ellipse(120% 80% at 50% 120%);
    }

    /* Layers */
    #fruitLayer, #uiLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* Basket */
    #basket {
      position: absolute;
      bottom: 12%;
      left: 50%;
      transform: translateX(-50%);
      width: 180px;
      height: 60px;
      border-radius: 16px 16px 14px 14px;
      background:
        linear-gradient(180deg, #bf7a2f, #a56523);
      box-shadow:
        inset 0 6px 0 0 rgba(255,255,255,.25),
        inset 0 -8px 0 0 rgba(0,0,0,.08),
        0 8px 18px rgba(0,0,0,.25);
      outline: 4px solid rgba(0,0,0,.05);
      pointer-events: none;
      will-change: transform;
    }
    /* Basket weave and rim */
    #basket::before, #basket::after {
      content: "";
      position: absolute;
      left: 6%;
      right: 6%;
      border-radius: 12px;
    }
    #basket::before {
      top: -12px;
      height: 16px;
      background: linear-gradient(180deg, #ffd59b, #e6ad62);
      box-shadow: inset 0 2px 0 rgba(255,255,255,.6), 0 3px 0 rgba(0,0,0,.1);
    }
    #basket::after {
      top: 16px;
      bottom: 8px;
      background:
        repeating-linear-gradient(45deg, #c88941 0 10px, #bb7d35 10px 20px);
      opacity: .5;
      filter: saturate(1.1);
      border-radius: 10px;
    }

    /* Fruit */
    .fruit {
      position: absolute;
      width: 80px;
      height: 80px;
      transform: translate3d(0,0,0);
      will-change: transform;
      display: grid;
      place-items: center;
      pointer-events: none;
      filter: drop-shadow(0 8px 6px rgba(0,0,0,.12));
    }
    .fruit span {
      font-size: 64px;
      transform: translateZ(0);
      animation: wiggle 1.4s ease-in-out infinite;
    }
    @keyframes wiggle {
      0%,100% { transform: rotate(0deg) translateY(0); }
      50% { transform: rotate(-4deg) translateY(2px); }
    }

    /* Overlay (start/game over) */
    #overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(255,255,255,.85), rgba(255,255,255,.65));
      display: grid;
      place-items: center;
      text-align: center;
      padding: 20px;
      transition: opacity .25s ease;
      z-index: 5;
    }
    #overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .panel {
      width: min(92%, 520px);
      background: #ffffff;
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 20px 18px;
      border: 3px solid #ffefd9;
    }
    .panel h2 {
      margin: 8px 0 6px;
      font-size: clamp(22px, 3.2vw, 32px);
      color: #1f3a4a;
    }
    .panel p {
      margin: 6px 0 14px;
      color: #214356;
    }
    .panel .big {
      font-size: clamp(18px, 2.2vw, 22px);
      color: #0b2233;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
      margin-top: 10px;
    }
    button {
      -webkit-tap-highlight-color: transparent;
      appearance: none;
      border: none;
      border-radius: 14px;
      padding: 10px 16px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(180deg, #ff9a2b, #ff7a00);
      box-shadow: 0 6px 12px rgba(255,122,0,.35);
      transition: transform .05s ease, filter .15s ease;
    }
    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }
    .btn-secondary {
      background: linear-gradient(180deg, #ff5f93, #ff2b6b);
      box-shadow: 0 6px 12px rgba(255,43,107,.35);
    }

    footer {
      padding: 8px 12px 16px;
    }
    footer .bar {
      width: 100%;
      max-width: 1280px;
      text-align: center;
      color: #1b3b4f;
      background: color-mix(in srgb, var(--ui) 85%, #fff0);
      backdrop-filter: blur(6px);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: var(--shadow);
      font-size: clamp(12px, 1.6vw, 14px);
    }

    /* Responsive sizing bound to container size */
    @media (max-width: 900px) {
      #basket { height: 54px; }
      .fruit { width: 72px; height: 72px; }
      .fruit span { font-size: 56px; }
    }
    @media (max-width: 600px) {
      #basket { height: 50px; }
      .fruit { width: 68px; height: 68px; }
      .fruit span { font-size: 52px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="bar" role="region" aria-label="Scoreboard">
      <h1>Fruit Catcher</h1>
      <div class="scoreboard">
        <div class="score-item" aria-live="polite" aria-atomic="true">
          Score: <strong id="scoreValue">0</strong>
        </div>
        <div class="score-item">
          Misses: <strong id="missesValue">0</strong>
        </div>
        <div class="lives" title="Lives remaining">
          <span id="livesHearts" aria-hidden="true">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
        </div>
      </div>
      <div style="justify-self:end; display:flex; gap:8px;">
        <!-- Reserved for future controls if needed -->
      </div>
    </div>
  </header>

  <main>
    <section id="gameArea" aria-label="Game area" tabindex="0">
      <!-- Overlay -->
      <div id="overlay" role="dialog" aria-modal="true" aria-labelledby="overlayTitle">
        <div class="panel">
          <h2 id="overlayTitle">Catch the Fruits!</h2>
          <p class="big" id="messageText">Move the basket with your mouse or arrow keys to catch the falling fruits. Miss 3 and the game ends.</p>
          <div class="buttons">
            <button id="startButton" type="button" aria-label="Start Game">Start Game</button>
            <button id="restartButton" type="button" class="btn-secondary" aria-label="Reset Score">Reset</button>
          </div>
        </div>
      </div>

      <!-- Layers -->
      <div id="fruitLayer" aria-hidden="true"></div>
      <div id="uiLayer" aria-hidden="true">
        <div id="basket" aria-label="Basket"></div>
      </div>
    </section>
  </main>

  <footer>
    <div class="bar" id="instructions">
      Controls: Move your mouse across the game area, or use Left/Right arrow keys (A/D). Catch fruits to score. Missing 3 fruits ends the game.
    </div>
  </footer>

  <script>
    (function(){
      "use strict";

      // Elements with IDs (for automation and accessibility)
      const gameArea = document.getElementById("gameArea");
      const fruitLayer = document.getElementById("fruitLayer");
      const basketEl = document.getElementById("basket");
      const scoreValueEl = document.getElementById("scoreValue");
      const missesValueEl = document.getElementById("missesValue");
      const livesHeartsEl = document.getElementById("livesHearts");
      const overlay = document.getElementById("overlay");
      const messageText = document.getElementById("messageText");
      const startButton = document.getElementById("startButton");
      const restartButton = document.getElementById("restartButton");

      // Game constants and state
      const MAX_MISSES = 3;
      const FRUITS = ["üçé","üçå","üçì","üçá","üçä","üçç","üçâ","ü•ù","üçí"];
      let state = "idle"; // idle | playing | over
      let score = 0;
      let misses = 0;

      // Dimensions
      let areaRect = gameArea.getBoundingClientRect();
      let gameWidth = areaRect.width;
      let gameHeight = areaRect.height;

      // Basket properties
      let basket = {
        x: gameWidth/2 - 90,
        y: gameHeight * 0.88,  // baseline for top of basket element transform origin
        w: 180,
        h: 60,
        speed: 700, // px/s
        leftHeld: false,
        rightHeld: false
      };

      // Fruits array
      const fruits = [];

      // Timing
      let rafId = 0;
      let lastTime = 0;
      let spawnTimer = 0;
      let spawnInterval = 1000; // ms

      // Utility: clamp
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

      // Resize and scale game elements
      function updateDimensions(){
        areaRect = gameArea.getBoundingClientRect();
        gameWidth = areaRect.width;
        gameHeight = areaRect.height;

        // Scale basket size responsive
        basket.w = clamp(gameWidth * 0.18, 140, 220);
        basket.h = clamp(gameHeight * 0.08, 50, 72);
        basket.y = gameHeight - (gameHeight * 0.12); // place basket visually on "ground"
        // Ensure basket remains within bounds
        basket.x = clamp(basket.x, 0, gameWidth - basket.w);
        // Apply to DOM
        basketEl.style.width = basket.w + "px";
        basketEl.style.height = basket.h + "px";
        // Update transform
        updateBasketTransform();
        // Adjust current fruits' size if we store a base size relative to width
        // We'll keep fruit sizes at creation time; new spawns will use updated size.
      }

      function updateBasketTransform(){
        basketEl.style.transform = `translate3d(${basket.x}px, 0, 0)`;
        basketEl.style.bottom = (gameHeight - basket.y) + "px";
      }

      function setScore(v){
        score = v;
        scoreValueEl.textContent = String(score);
        // Progressively adjust difficulty
        spawnInterval = Math.max(350, 1000 - score * 22);
      }

      function setMisses(v){
        misses = v;
        missesValueEl.textContent = String(misses);
        const livesLeft = clamp(MAX_MISSES - misses, 0, MAX_MISSES);
        livesHeartsEl.textContent = "‚ù§Ô∏è".repeat(livesLeft) + "üñ§".repeat(MAX_MISSES - livesLeft);
      }

      function randomFruitSize(){
        // Fruit size relative to game width
        const target = gameWidth * 0.06; // about 6% of width
        return Math.round(clamp(target, 56, 96));
      }

      function randomX(size){
        return Math.random() * (gameWidth - size);
      }

      function spawnFruit(){
        const size = randomFruitSize();
        const fruit = document.createElement("div");
        fruit.className = "fruit";
        fruit.style.width = size + "px";
        fruit.style.height = size + "px";
        fruit.innerHTML = `<span>${FRUITS[(Math.random() * FRUITS.length) | 0]}</span>`;
        fruitLayer.appendChild(fruit);

        const obj = {
          id: "fruit-" + Date.now() + "-" + Math.floor(Math.random() * 1e6), // unique-ish
          el: fruit,
          x: randomX(size),
          y: -size,
          w: size,
          h: size,
          // Speed increases with score
          vy: 220 + Math.min(520, score * 14) + (Math.random() * 50 - 25)
        };
        fruit.dataset.id = obj.id;
        fruits.push(obj);
        updateFruitTransform(obj);
      }

      function updateFruitTransform(f){
        f.el.style.transform = `translate3d(${f.x}px, ${f.y}px, 0)`;
      }

      function removeFruitAt(index){
        const f = fruits[index];
        if (!f) return;
        if (f.el && f.el.parentNode) {
          f.el.parentNode.removeChild(f.el);
        }
        fruits.splice(index, 1);
      }

      function clearAllFruits(){
        while (fruits.length) {
          const f = fruits.pop();
          if (f.el && f.el.parentNode) f.el.parentNode.removeChild(f.el);
        }
      }

      function rectsIntersect(ax1, ay1, aw, ah, bx1, by1, bw, bh){
        const ax2 = ax1 + aw, ay2 = ay1 + ah, bx2 = bx1 + bw, by2 = by1 + bh;
        return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
      }

      function gameLoop(timestamp){
        if (state !== "playing") {
          lastTime = timestamp;
          rafId = requestAnimationFrame(gameLoop);
          return;
        }

        const dt = Math.min(0.033, (timestamp - lastTime) / 1000); // cap dt for stability
        lastTime = timestamp;

        // Keyboard movement
        const dir = (basket.rightHeld ? 1 : 0) - (basket.leftHeld ? 1 : 0);
        if (dir !== 0){
          basket.x = clamp(basket.x + dir * basket.speed * dt, 0, gameWidth - basket.w);
          updateBasketTransform();
        }

        // Spawn fruits over time
        spawnTimer += dt * 1000;
        if (spawnTimer >= spawnInterval) {
          spawnTimer = 0;
          spawnFruit();
          // Chance to spawn a second fruit at higher scores
          if (score > 10 && Math.random() < 0.25) {
            setTimeout(spawnFruit, 150);
          }
        }

        // Update fruits
        const basketTop = basket.y - basket.h; // top y of basket box
        const basketLeft = basket.x;
        const basketRight = basket.x + basket.w;

        for (let i = fruits.length - 1; i >= 0; i--) {
          const f = fruits[i];
          f.y += f.vy * dt;
          updateFruitTransform(f);

          // Check catch (intersection with basket)
          if (f.y + f.h >= basketTop) {
            const caught = rectsIntersect(f.x, f.y, f.w, f.h, basketLeft, basketTop, basket.w, basket.h);
            if (caught) {
              // Caught!
              setScore(score + 1);
              removeFruitAt(i);
              continue;
            }
          }

          // Missed (off screen bottom)
          if (f.y > gameHeight + 10) {
            setMisses(misses + 1);
            removeFruitAt(i);
            if (misses >= MAX_MISSES) {
              endGame();
              return;
            }
          }
        }

        rafId = requestAnimationFrame(gameLoop);
      }

      function startGame(){
        // Reset
        setScore(0);
        setMisses(0);
        clearAllFruits();
        spawnTimer = 0;
        lastTime = performance.now();
        state = "playing";
        overlay.classList.add("hidden");
        overlay.setAttribute("aria-hidden", "true");
        gameArea.focus({ preventScroll: true });
      }

      function endGame(){
        state = "over";
        // Reveal overlay with message
        messageText.innerHTML = `Great job! Your final score is <strong>${score}</strong>.<br/>Click Restart to play again.`;
        overlay.classList.remove("hidden");
        overlay.removeAttribute("aria-hidden");
      }

      function resetGame(){
        // Reset counters but keep overlay visible
        setScore(0);
        setMisses(0);
        clearAllFruits();
        messageText.textContent = "Move the basket with your mouse or arrow keys to catch the falling fruits. Miss 3 and the game ends.";
      }

      // Input handlers
      function onKeyDown(e){
        if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A"){
          e.preventDefault();
          basket.leftHeld = true;
        } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D"){
          e.preventDefault();
          basket.rightHeld = true;
        } else if (e.key === "Enter" && state !== "playing") {
          e.preventDefault();
          startGame();
        }
      }
      function onKeyUp(e){
        if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A"){
          e.preventDefault();
          basket.leftHeld = false;
        } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D"){
          e.preventDefault();
          basket.rightHeld = false;
        }
      }

      // Pointer/mouse move to control basket
      function onPointerMove(e){
        // Only move basket while playing (but allow pre-positioning too if desired)
        const rect = gameArea.getBoundingClientRect();
        const x = (e.clientX ?? (e.touches && e.touches[0]?.clientX)) - rect.left;
        basket.x = clamp(x - basket.w / 2, 0, gameWidth - basket.w);
        updateBasketTransform();
      }

      // Visibility and resizing
      function onResize(){
        updateDimensions();
      }

      // Wire up buttons
      startButton.addEventListener("click", startGame);
      restartButton.addEventListener("click", function(){
        resetGame();
      });

      // Keyboard listeners
      window.addEventListener("keydown", onKeyDown, { passive: false });
      window.addEventListener("keyup", onKeyUp, { passive: false });

      // Pointer listeners (mouse/touch)
      gameArea.addEventListener("pointermove", onPointerMove);
      gameArea.addEventListener("touchmove", (e) => {
        if (e.touches && e.touches.length) {
          onPointerMove(e);
        }
      }, { passive: true });

      // Resize
      window.addEventListener("resize", onResize);

      // Initialize sizes and start loop
      updateDimensions();
      lastTime = performance.now();
      rafId = requestAnimationFrame(gameLoop);

      // Ensure gameArea can be focused for keyboard play on click
      gameArea.addEventListener("click", () => gameArea.focus({ preventScroll: true }));

      // Safety: cleanup on unload
      window.addEventListener("beforeunload", () => cancelAnimationFrame(rafId));
    })();
  </script>
</body>
</html>
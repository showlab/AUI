<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <title>Customer Journey Flow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="Visualize a customer‚Äôs steps from awareness to purchase with editable stages and drag-and-drop connections." />
  <style>
    :root{
      --bg: #f7f8fb;
      --grid1: rgba(36, 41, 47, 0.05);
      --grid2: rgba(36, 41, 47, 0.03);
      --surface: #ffffff;
      --text: #1f2328;
      --muted: #6a737d;
      --primary: #4b6bfb;
      --primary-600: #3c57cc;
      --accent: #22c55e;
      --danger: #ef4444;
      --shadow: 0 6px 18px rgba(0,0,0,0.08);
      --radius: 12px;
      --port-in: #10b981;
      --port-out: #4b6bfb;
      --edge: #4b6bfb;
      --edge-hover: #2844f5;
      --edge-selected: #f59e0b;
      --workspace-w: 2000px;
      --workspace-h: 1200px;
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: var(--bg);
    }
    header.header {
      position: sticky;
      top: 0;
      background: var(--surface);
      border-bottom: 1px solid #e5e7eb;
      z-index: 10;
    }
    .header-inner {
      max-width: 1400px;
      margin: 0 auto;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
    }
    .toolbar {
      margin-left: auto;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button.btn {
      appearance: none;
      border: 1px solid #e5e7eb;
      background: #fff;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: box-shadow .15s ease, transform .05s ease, border-color .15s ease, background .15s ease;
      user-select: none;
    }
    button.btn:hover {
      box-shadow: var(--shadow);
      border-color: #d1d5db;
    }
    button.btn:active {
      transform: translateY(1px);
    }
    button.btn.primary {
      background: var(--primary);
      color: #fff;
      border-color: transparent;
    }
    button.btn.primary:hover {
      background: var(--primary-600);
      box-shadow: var(--shadow);
    }
    button.btn.danger {
      color: #fff;
      background: var(--danger);
      border-color: transparent;
    }
    .divider {
      width: 1px;
      height: 28px;
      background: #e5e7eb;
      margin: 0 4px;
    }
    main {
      height: calc(100% - 58px);
      display: flex;
      flex-direction: column;
    }
    .help {
      max-width: 1400px;
      margin: 8px auto 0;
      padding: 6px 16px 10px;
      color: var(--muted);
      font-size: 13px;
      display: flex;
      gap: 14px;
      align-items: center;
    }
    .help .dot {
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
      flex: 0 0 auto;
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.15);
    }
    /* Diagram viewport and workspace */
    #diagram-viewport {
      flex: 1;
      position: relative;
      overflow: auto;
      border-top: 1px solid #eef0f3;
      background-image:
        linear-gradient(to bottom, var(--grid1) 1px, transparent 1px),
        linear-gradient(to right, var(--grid1) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid2) 1px, transparent 1px),
        linear-gradient(to right, var(--grid2) 1px, transparent 1px);
      background-size:
        40px 40px,
        40px 40px,
        8px 8px,
        8px 8px;
      background-position:
        0 0,
        0 0,
        0 0,
        0 0;
    }
    #workspace {
      position: relative;
      width: var(--workspace-w);
      height: var(--workspace-h);
      margin: 0;
    }
    /* SVG connection layer */
    #connections {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* connections will re-enable per element */
      z-index: 1;
    }
    .connection {
      fill: none;
      stroke: var(--edge);
      stroke-width: 2.5;
      pointer-events: stroke;
      transition: stroke .15s ease;
    }
    .connection:hover {
      stroke: var(--edge-hover);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.08));
    }
    .connection.selected {
      stroke: var(--edge-selected);
      stroke-width: 3;
    }
    .connection.temp {
      stroke-dasharray: 6 6;
      opacity: 0.8;
    }
    /* Stage nodes */
    .stage {
      position: absolute;
      background: var(--surface);
      border: 1px solid #e5e7eb;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      min-width: 180px;
      max-width: 280px;
      padding: 10px 12px 12px;
      z-index: 2;
      transition: border-color .15s ease, box-shadow .15s ease, transform .05s ease;
    }
    .stage:hover {
      border-color: #d1d5db;
    }
    .stage.selected {
      outline: 2px solid var(--primary);
      outline-offset: 0;
    }
    .stage .drag-handle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      cursor: move;
      user-select: none;
      margin-bottom: 8px;
    }
    .stage .title {
      font-weight: 700;
      font-size: 15px;
      line-height: 1.2;
      padding: 2px 6px;
      border-radius: 6px;
      outline: none;
    }
    .stage .title[contenteditable="true"]:focus {
      box-shadow: inset 0 0 0 2px rgba(75, 107, 251, 0.25);
      background: #f8f9ff;
    }
    .stage .subtitle {
      font-size: 12px;
      color: var(--muted);
    }
    .ports {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 8px;
      gap: 12px;
    }
    .port {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      cursor: crosshair;
      flex: 0 0 auto;
      transition: transform .1s ease;
    }
    .port:hover { transform: scale(1.15); }
    .port.in  { background: var(--port-in); }
    .port.out { background: var(--port-out); margin-left: auto; }
    .port-label {
      font-size: 11px;
      color: var(--muted);
      user-select: none;
    }
    .meta-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    /* Data I/O panel */
    #data-panel {
      position: absolute;
      right: 16px;
      bottom: 16px;
      z-index: 5;
      width: min(480px, 90vw);
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 12px;
      display: none;
    }
    #data-panel.open { display: block; }
    #io-json {
      width: 100%;
      height: 160px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 8px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      outline: none;
    }
    #io-json:focus { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(75,107,251,.15); }
    .panel-actions {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    /* Accessibility helpers */
    .visually-hidden {
      position: absolute !important;
      height: 1px; width: 1px;
      overflow: hidden;
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap; border: 0; padding: 0; margin: -1px;
    }
    /* Responsive tweaks */
    @media (max-width: 720px) {
      .header-inner { flex-wrap: wrap; gap: 8px; }
      .toolbar { width: 100%; justify-content: flex-start; }
    }
  </style>
</head>
<body>
  <header class="header" role="banner">
    <div class="header-inner">
      <h1 aria-label="App Name">Customer Journey Flow</h1>
      <nav class="toolbar" aria-label="Toolbar">
        <button id="btn-add" class="btn primary" type="button" title="Add a new stage">
          ‚ûï Add Stage
        </button>
        <button id="btn-delete" class="btn danger" type="button" title="Delete selected stage or connection">
          üóë Delete Selected
        </button>
        <div class="divider" aria-hidden="true"></div>
        <button id="btn-center" class="btn" type="button" title="Center view on content">
          üéØ Center View
        </button>
        <button id="btn-export" class="btn" type="button" title="Export flow to JSON">
          ‚¨áÔ∏è Export
        </button>
        <button id="btn-import" class="btn" type="button" title="Import flow from JSON">
          ‚¨ÜÔ∏è Import
        </button>
      </nav>
    </div>
  </header>

  <main role="main" aria-label="Customer journey canvas">
    <div class="help" aria-live="polite">
      <span class="dot" aria-hidden="true"></span>
      <span>
        Tip: Drag a stage by its header. Create connections by dragging from the right (out) port to the left (in) port. Click an edge or stage to select. Double-click a title to edit. Use Delete Selected to remove.
      </span>
    </div>
    <section id="diagram-viewport" aria-label="Diagram viewport">
      <div id="workspace" aria-label="Workspace">
        <svg id="connections" aria-label="Connections layer">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,3.5 L0,7 Z" fill="currentColor"></path>
            </marker>
          </defs>
          <!-- paths inserted here -->
        </svg>
        <!-- stages inserted here -->
      </div>
    </section>
  </main>

  <section id="data-panel" aria-label="Data panel">
    <div style="display:flex; align-items:center; justify-content: space-between; gap:8px; margin-bottom:8px;">
      <strong>JSON</strong>
      <button id="btn-close-panel" class="btn" type="button" title="Close panel">‚úñ Close</button>
    </div>
    <textarea id="io-json" aria-label="JSON input/output" placeholder='{"stages":[...],"edges":[...]}'></textarea>
    <div class="panel-actions">
      <button id="btn-fill" class="btn" type="button" title="Fill with current flow JSON">Fill</button>
      <button id="btn-load" class="btn primary" type="button" title="Load flow from JSON area">Load</button>
    </div>
  </section>

  <script>
    (function(){
      // Data structures
      const workspace = document.getElementById('workspace');
      const viewport = document.getElementById('diagram-viewport');
      const svg = document.getElementById('connections');

      const btnAdd = document.getElementById('btn-add');
      const btnDelete = document.getElementById('btn-delete');
      const btnCenter = document.getElementById('btn-center');
      const btnExport = document.getElementById('btn-export');
      const btnImport = document.getElementById('btn-import');
      const dataPanel = document.getElementById('data-panel');
      const btnClosePanel = document.getElementById('btn-close-panel');
      const btnFill = document.getElementById('btn-fill');
      const btnLoad = document.getElementById('btn-load');
      const ioJson = document.getElementById('io-json');

      let stageCounter = 0;
      const stages = new Map(); // id -> {id, el, x, y}
      const edges = []; // {from, to, el}
      let selectedStageId = null;
      let selectedEdgeKey = null; // "from->to"
      let dragState = null; // {id, offsetX, offsetY}
      let connectDrag = null; // {fromId, tempEl}

      function nextStageId(){
        stageCounter += 1;
        return 's' + stageCounter;
      }

      function keyForEdge(from, to){ return from + '->' + to; }

      function getWorkspaceRect(){
        return workspace.getBoundingClientRect();
      }

      function portCenter(portEl){
        const rPort = portEl.getBoundingClientRect();
        const rWS = getWorkspaceRect();
        const x = rPort.left - rWS.left + rPort.width/2;
        const y = rPort.top - rWS.top + rPort.height/2;
        return {x, y};
      }

      function pathBetween(p1, p2){
        const dxRaw = Math.abs(p2.x - p1.x);
        const dx = Math.min(160, Math.max(40, dxRaw/2 + 20));
        const c1x = p1.x + dx;
        const c1y = p1.y;
        const c2x = p2.x - dx;
        const c2y = p2.y;
        return `M ${p1.x} ${p1.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
      }

      function deselectAll(){
        if (selectedStageId){
          const st = stages.get(selectedStageId);
          if (st) st.el.classList.remove('selected');
          selectedStageId = null;
        }
        if (selectedEdgeKey){
          const e = edges.find(ed => keyForEdge(ed.from, ed.to) === selectedEdgeKey);
          if (e && e.el) e.el.classList.remove('selected');
          selectedEdgeKey = null;
        }
      }

      function selectStage(id){
        deselectAll();
        const st = stages.get(id);
        if (!st) return;
        st.el.classList.add('selected');
        selectedStageId = id;
      }

      function selectEdgeByKey(key){
        deselectAll();
        const e = edges.find(ed => keyForEdge(ed.from, ed.to) === key);
        if (!e) return;
        e.el.classList.add('selected');
        selectedEdgeKey = key;
      }

      function updateConnections(){
        edges.forEach(ed => {
          const fromPort = document.getElementById('port-out-' + ed.from);
          const toPort = document.getElementById('port-in-' + ed.to);
          if (!fromPort || !toPort) return;
          const p1 = portCenter(fromPort);
          const p2 = portCenter(toPort);
          ed.el.setAttribute('d', pathBetween(p1, p2));
        });
      }

      function createConnection(fromId, toId){
        if (fromId === toId) return; // no self-loop for clarity
        // Prevent duplicate
        if (edges.some(e => e.from === fromId && e.to === toId)) return;
        // Create path
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.classList.add('connection');
        path.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--edge').trim() || '#4b6bfb');
        path.setAttribute('marker-end', 'url(#arrowhead)');
        path.setAttribute('data-from', fromId);
        path.setAttribute('data-to', toId);
        const pid = 'edge-' + fromId + '-' + toId;
        path.setAttribute('id', pid);
        // click to select
        path.addEventListener('click', (ev) => {
          ev.stopPropagation();
          selectEdgeByKey(keyForEdge(fromId, toId));
        });
        svg.appendChild(path);
        const edge = {from: fromId, to: toId, el: path};
        edges.push(edge);
        updateConnections();
      }

      function removeConnection(fromId, toId){
        const idx = edges.findIndex(e => e.from === fromId && e.to === toId);
        if (idx >= 0){
          const e = edges[idx];
          if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
          edges.splice(idx, 1);
        }
      }

      function removeConnectionsForStage(id){
        // filter edges referencing id
        const toRemove = edges.filter(e => e.from === id || e.to === id);
        toRemove.forEach(e => {
          if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
        });
        for (let i = edges.length - 1; i >= 0; i--){
          if (edges[i].from === id || edges[i].to === id){
            edges.splice(i, 1);
          }
        }
      }

      function constrainPos(x, y, el){
        const rect = { w: el.offsetWidth, h: el.offsetHeight };
        const maxX = parseInt(getComputedStyle(workspace).width) - rect.w - 2;
        const maxY = parseInt(getComputedStyle(workspace).height) - rect.h - 2;
        return {
          x: Math.max(2, Math.min(x, maxX)),
          y: Math.max(2, Math.min(y, maxY))
        };
      }

      function setStagePosition(id, x, y){
        const st = stages.get(id);
        if (!st) return;
        const constrained = constrainPos(x, y, st.el);
        st.x = constrained.x;
        st.y = constrained.y;
        st.el.style.left = st.x + 'px';
        st.el.style.top = st.y + 'px';
        // update connections
        updateConnections();
      }

      function createStage(title, x, y, idOptional){
        const id = idOptional || nextStageId();
        // Stage container
        const el = document.createElement('article');
        el.className = 'stage';
        el.setAttribute('role', 'group');
        el.setAttribute('aria-label', 'Stage: ' + title);
        el.setAttribute('tabindex', '0');
        el.id = 'stage-' + id;

        // Header/drag area
        const header = document.createElement('div');
        header.className = 'drag-handle';
        header.setAttribute('title', 'Drag to move');

        const titleEl = document.createElement('div');
        titleEl.className = 'title';
        titleEl.textContent = title;
        titleEl.contentEditable = 'true';
        titleEl.setAttribute('role', 'textbox');
        titleEl.setAttribute('aria-label', 'Edit stage title');
        titleEl.addEventListener('keydown', (e) => {
          // Prevent newline
          if (e.key === 'Enter'){
            e.preventDefault();
            titleEl.blur();
          }
        });
        titleEl.addEventListener('input', () => {
          el.setAttribute('aria-label', 'Stage: ' + titleEl.textContent.trim());
        });

        const subtitle = document.createElement('div');
        subtitle.className = 'subtitle';
        subtitle.textContent = 'Double-click to edit';
        header.appendChild(titleEl);
        header.appendChild(subtitle);

        // Ports row
        const ports = document.createElement('div');
        ports.className = 'ports';

        const inWrap = document.createElement('div');
        inWrap.className = 'meta-row';
        const inPort = document.createElement('div');
        inPort.className = 'port in';
        inPort.id = 'port-in-' + id;
        inPort.setAttribute('title', 'Input (drop here to connect)');
        const inLab = document.createElement('div');
        inLab.className = 'port-label';
        inLab.textContent = 'in';
        inWrap.appendChild(inPort);
        inWrap.appendChild(inLab);

        const outWrap = document.createElement('div');
        outWrap.className = 'meta-row';
        const outLab = document.createElement('div');
        outLab.className = 'port-label';
        outLab.textContent = 'out';
        const outPort = document.createElement('div');
        outPort.className = 'port out';
        outPort.id = 'port-out-' + id;
        outPort.setAttribute('title', 'Output (drag from here)');
        outWrap.appendChild(outLab);
        outWrap.appendChild(outPort);

        ports.appendChild(inWrap);
        ports.appendChild(outWrap);

        el.appendChild(header);
        el.appendChild(ports);
        workspace.appendChild(el);

        // Set initial position
        el.style.left = x + 'px';
        el.style.top = y + 'px';

        // Save data
        stages.set(id, {id, el, x, y});

        // Event listeners
        el.addEventListener('mousedown', (ev) => {
          // Select on background click inside stage
          if (ev.target === el || ev.target === ports || ev.target === header || ev.target.classList.contains('subtitle')) {
            selectStage(id);
          }
        });
        el.addEventListener('click', (ev) => {
          // Avoid overriding when clicking inputs
          if (ev.target.classList.contains('title')) return;
          selectStage(id);
        });

        // Dragging stage by header
        header.addEventListener('mousedown', (ev) => {
          ev.preventDefault();
          selectStage(id);
          const r = el.getBoundingClientRect();
          const rWS = getWorkspaceRect();
          const startX = ev.clientX;
          const startY = ev.clientY;
          const offsetX = startX - r.left;
          const offsetY = startY - r.top;
          dragState = {id, offsetX, offsetY};

          function onMove(e){
            if (!dragState) return;
            const nx = e.clientX - rWS.left - dragState.offsetX;
            const ny = e.clientY - rWS.top - dragState.offsetY;
            setStagePosition(dragState.id, nx, ny);
          }
          function onUp(){
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            dragState = null;
          }

          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });

        // Start connection drag from outPort
        outPort.addEventListener('mousedown', (ev) => {
          ev.stopPropagation();
          ev.preventDefault();
          startConnectDrag(id, outPort, ev);
        });

        // Allow finishing connection by mouseup on inPort
        inPort.addEventListener('mouseup', (ev) => {
          ev.stopPropagation();
          if (connectDrag && connectDrag.fromId !== id){
            finishConnectDragOn(inPort, id);
          }
        });

        // Focus rings via keyboard
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Delete' || e.key === 'Backspace'){
            e.preventDefault();
            selectStage(id);
            doDeleteSelected();
          }
        });

        return id;
      }

      function startConnectDrag(fromId, fromPort, ev){
        const temp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        temp.classList.add('connection', 'temp');
        temp.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--edge').trim() || '#4b6bfb');
        temp.setAttribute('marker-end', 'url(#arrowhead)');
        svg.appendChild(temp);
        connectDrag = {fromId, tempEl: temp};

        function onMove(e){
          if (!connectDrag) return;
          const p1 = portCenter(fromPort);
          const p2 = { x: e.clientX - getWorkspaceRect().left, y: e.clientY - getWorkspaceRect().top };
          temp.setAttribute('d', pathBetween(p1, p2));
        }
        function onUp(e){
          // Try to resolve element under cursor
          const elUnder = document.elementFromPoint(e.clientX, e.clientY);
          const inPort = findAncestorByClass(elUnder, 'port') && findAncestorByClass(elUnder, 'in') ? elUnder : closestBySelectors(elUnder, '.port.in');
          const targetIn = inPort ? inPort : null;
          if (targetIn){
            const toId = (targetIn.id || '').replace('port-in-','');
            if (toId && toId !== connectDrag.fromId){
              createConnection(connectDrag.fromId, toId);
            }
          }
          if (connectDrag && connectDrag.tempEl && connectDrag.tempEl.parentNode){
            connectDrag.tempEl.parentNode.removeChild(connectDrag.tempEl);
          }
          connectDrag = null;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
        }

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      }

      function finishConnectDragOn(inPortEl, toId){
        if (!connectDrag) return;
        createConnection(connectDrag.fromId, toId);
        if (connectDrag.tempEl && connectDrag.tempEl.parentNode){
          connectDrag.tempEl.parentNode.removeChild(connectDrag.tempEl);
        }
        connectDrag = null;
      }

      function findAncestorByClass(el, cls){
        while (el){
          if (el.classList && el.classList.contains(cls)) return el;
          el = el.parentNode;
        }
        return null;
      }
      function closestBySelectors(el, selector){
        while (el){
          if (el.matches && el.matches(selector)) return el;
          el = el.parentNode;
        }
        return null;
      }

      function deleteStage(id){
        const st = stages.get(id);
        if (!st) return;
        removeConnectionsForStage(id);
        if (st.el && st.el.parentNode) st.el.parentNode.removeChild(st.el);
        stages.delete(id);
        if (selectedStageId === id) selectedStageId = null;
      }

      function doDeleteSelected(){
        if (selectedEdgeKey){
          const [from, to] = selectedEdgeKey.split('->');
          removeConnection(from, to);
          selectedEdgeKey = null;
          return;
        }
        if (selectedStageId){
          deleteStage(selectedStageId);
          selectedStageId = null;
          return;
        }
      }

      function centerView(){
        // Compute bounding box of all stages
        if (stages.size === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        stages.forEach(st => {
          const w = st.el.offsetWidth;
          const h = st.el.offsetHeight;
          minX = Math.min(minX, st.x);
          minY = Math.min(minY, st.y);
          maxX = Math.max(maxX, st.x + w);
          maxY = Math.max(maxY, st.y + h);
        });
        const contentW = maxX - minX;
        const contentH = maxY - minY;
        const vpW = viewport.clientWidth;
        const vpH = viewport.clientHeight;
        const targetScrollLeft = Math.max(0, minX - (vpW - contentW)/2);
        const targetScrollTop = Math.max(0, minY - (vpH - contentH)/2);
        viewport.scrollTo({left: targetScrollLeft, top: targetScrollTop, behavior: 'smooth'});
      }

      function exportJSON(){
        const stagesArr = [];
        stages.forEach(st => {
          const title = st.el.querySelector('.title').textContent.trim();
          stagesArr.push({ id: st.id, title, x: st.x, y: st.y });
        });
        const edgesArr = edges.map(e => ({ from: e.from, to: e.to }));
        return JSON.stringify({ stages: stagesArr, edges: edgesArr }, null, 2);
      }

      function importJSON(jsonText){
        let data;
        try {
          data = JSON.parse(jsonText);
        } catch (e){
          alert('Invalid JSON');
          return;
        }
        if (!data || !Array.isArray(data.stages) || !Array.isArray(data.edges)) {
          alert('JSON must have stages[] and edges[]');
          return;
        }
        // Clear existing
        Array.from(stages.keys()).forEach(id => deleteStage(id));
        edges.slice().forEach(e => removeConnection(e.from, e.to));
        // Reset counter to avoid collisions
        stageCounter = 0;
        // Recreate stages
        data.stages.forEach(s => {
          const id = s.id || nextStageId();
          // Ensure counter keeps up to highest numeric
          const numeric = parseInt(String(id).replace(/\D/g,''), 10);
          if (!isNaN(numeric) && numeric > stageCounter) stageCounter = numeric;
          createStage(s.title || 'Stage', s.x || 40, s.y || 40, id);
        });
        // Recreate edges
        data.edges.forEach(e => {
          if (stages.has(e.from) && stages.has(e.to)) {
            createConnection(e.from, e.to);
          }
        });
        updateConnections();
        centerView();
      }

      // Toolbar events
      btnAdd.addEventListener('click', () => {
        // Position near current viewport center
        const vRect = viewport.getBoundingClientRect();
        const wsRect = getWorkspaceRect();
        const centerX = viewport.scrollLeft + vRect.width/2 - wsRect.left;
        const centerY = viewport.scrollTop + vRect.height/2 - wsRect.top;
        const id = createStage('New Stage', Math.max(20, centerX - 90), Math.max(20, centerY - 60));
        selectStage(id);
        updateConnections();
      });

      btnDelete.addEventListener('click', () => {
        doDeleteSelected();
      });

      btnCenter.addEventListener('click', centerView);

      btnExport.addEventListener('click', () => {
        dataPanel.classList.add('open');
        ioJson.value = exportJSON();
      });

      btnImport.addEventListener('click', () => {
        dataPanel.classList.add('open');
        if (!ioJson.value.trim()) ioJson.value = exportJSON();
      });

      btnClosePanel.addEventListener('click', () => {
        dataPanel.classList.remove('open');
      });
      btnFill.addEventListener('click', () => {
        ioJson.value = exportJSON();
      });
      btnLoad.addEventListener('click', () => {
        importJSON(ioJson.value);
        dataPanel.classList.remove('open');
      });

      // Click on background deselects
      viewport.addEventListener('click', () => {
        deselectAll();
      });

      // Keyboard deletion globally
      document.addEventListener('keydown', (e) => {
        if ((e.key === 'Delete' || e.key === 'Backspace') && (selectedStageId || selectedEdgeKey)){
          e.preventDefault();
          doDeleteSelected();
        }
        // Quick add with Ctrl+N
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'n'){
          e.preventDefault();
          btnAdd.click();
        }
      });

      // Keep connections in sync on resize/scroll
      window.addEventListener('resize', updateConnections);
      viewport.addEventListener('scroll', () => { /* positions relative to workspace remain; no action needed */ });

      // Initialize with typical customer journey stages
      function initDefault(){
        const rowsY = 260; // base y
        const spacingX = 260;
        const startX = 120;

        const s1 = createStage('Awareness', startX, rowsY);
        const s2 = createStage('Consideration', startX + spacingX, rowsY);
        const s3 = createStage('Decision', startX + spacingX * 2, rowsY);
        const s4 = createStage('Purchase', startX + spacingX * 3, rowsY);

        createConnection(s1, s2);
        createConnection(s2, s3);
        createConnection(s3, s4);

        updateConnections();
        // Scroll to fit
        setTimeout(centerView, 50);
      }

      initDefault();
    })();
  </script>
</body>
</html>
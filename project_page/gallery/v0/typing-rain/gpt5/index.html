<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <title>Typing Rain</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="Typing Rain - Type falling words before they hit the ground. Increasing difficulty, accuracy tracker, and score." />
  <style>
    :root{
      --sky-top:#0b1b2b;
      --sky-mid:#11253a;
      --sky-bottom:#1a3350;
      --city-far:#0b1722;
      --city-near:#0e1a26;
      --accent:#35c2ff;
      --accent-2:#6be1ff;
      --text:#e9f5ff;
      --muted:#a6c1d6;
      --danger:#ff6b6b;
      --ok:#8ae66b;
      --warning:#ffc35f;
      --drop:#1b6fa5;
      --drop-2:#2c99d1;
      --panel-bg: rgba(8,16,24,0.55);
      --panel-border: rgba(255,255,255,0.08);
      --glow: 0 0 14px rgba(53,194,255,0.6);
    }
    *{box-sizing:border-box}
    html,body{
      margin:0; padding:0; height:100%; width:100%;
      background: linear-gradient(to bottom, var(--sky-top), var(--sky-mid) 50%, var(--sky-bottom));
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji", sans-serif;
      overflow: hidden;
    }

    header{
      position: relative;
      z-index: 5;
      width: 100%;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.35), rgba(0,0,0,0.05));
      backdrop-filter: blur(2px);
    }
    header h1{
      margin:0;
      font-size: clamp(18px, 2.4vw, 26px);
      letter-spacing: 0.4px;
      font-weight: 700;
      display:flex;
      align-items:center;
      gap:10px;
    }
    header h1 .logo{
      display:inline-block;
      width:28px; height:28px;
      border-radius:50%;
      background: radial-gradient(circle at 35% 30%, var(--accent-2), var(--accent) 55%, #0e567f 60%, #0a3753 100%);
      box-shadow: var(--glow);
      position: relative;
      overflow: hidden;
    }
    header h1 .logo::after{
      content:"";
      position:absolute;
      left:50%; top:50%;
      width:5px; height:5px;
      transform: translate(-20%,-70%) rotate(45deg);
      background: #d9f6ff;
      border-radius: 1px;
      filter: blur(0.3px);
      opacity:0.9;
    }
    nav#controls{
      display:flex; gap:8px; align-items:center; flex-wrap: wrap;
    }
    button{
      cursor:pointer;
      border:1px solid var(--panel-border);
      background: linear-gradient(to bottom right, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
      outline:none;
    }
    button:hover{ transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.25); }
    button:active{ transform: translateY(0); }
    button.primary{
      border-color: rgba(53,194,255,0.4);
      background: linear-gradient(180deg, rgba(53,194,255,0.25), rgba(53,194,255,0.08));
      box-shadow: 0 0 0 0 rgba(53,194,255,0.4);
    }
    button.warn{
      border-color: rgba(255,99,99,0.35);
      background: linear-gradient(180deg, rgba(255,99,99,0.25), rgba(255,99,99,0.08));
    }
    button.icon{
      width:40px; aspect-ratio:1/1; padding:0;
      display:inline-grid; place-items:center;
      font-size: 18px;
    }

    main{ position: relative; height: calc(100% - 56px); }

    #hud{
      position: absolute;
      z-index: 4;
      top: 10px; left: 50%;
      transform: translateX(-50%);
      display:flex; gap:12px; align-items:center; flex-wrap: wrap;
      background: var(--panel-bg);
      border:1px solid var(--panel-border);
      padding: 8px 12px;
      border-radius: 12px;
      backdrop-filter: blur(4px);
      user-select: none;
    }
    .stat{
      display:flex; gap:6px; align-items:baseline; font-variant-numeric: tabular-nums;
      padding: 4px 8px; border-radius: 8px;
      background: rgba(255,255,255,0.03);
    }
    .stat .label{ color: var(--muted); font-size: 12px; }
    .stat .value{ font-weight: 800; font-size: 16px; min-width: 36px; text-align: right; }

    #playfield{
      position: absolute;
      inset:0;
      overflow: hidden;
    }

    /* Subtle diagonal rain streaks in background */
    #playfield::before{
      content:"";
      position:absolute; inset:-30% -30% -30% -30%;
      background-image:
        repeating-linear-gradient(120deg, rgba(255,255,255,0.06) 0px, rgba(255,255,255,0.06) 1px, transparent 2px, transparent 12px);
      opacity:0.07;
      animation: drizzle 12s linear infinite;
      pointer-events:none;
    }
    @keyframes drizzle {
      from { transform: translate3d(0,0,0) }
      to { transform: translate3d(-8%, 12%, 0) }
    }

    /* Skyline layers */
    .skyline{
      position:absolute; inset:auto 0 0 0; height: 32%;
      pointer-events:none; z-index:1;
    }
    .skyline svg{ width:100%; height:100%; display:block }
    .skyline.far svg path{ fill: var(--city-far) }
    .skyline.near{ height: 42%; }
    .skyline.near svg path{ fill: var(--city-near) }

    /* Ground line to show failure threshold */
    #groundLine{
      position:absolute; left:0; right:0; bottom: 10px; height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
      z-index: 2; opacity: 0.6; pointer-events: none;
    }

    /* Input dock */
    #dock{
      position: absolute;
      z-index: 5;
      left:50%; bottom: 20px; transform: translateX(-50%);
      width: min(720px, 92vw);
      display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap: wrap;
      background: var(--panel-bg);
      border:1px solid var(--panel-border);
      padding: 10px;
      border-radius: 12px;
      backdrop-filter: blur(4px);
    }
    #txtType{
      flex:1 1 420px;
      min-width: 220px;
      font-size: clamp(16px, 2.2vw, 22px);
      line-height: 1.2;
      padding: 10px 12px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.1);
      outline: none;
      color: var(--text);
      background: rgba(255,255,255,0.06);
      transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
    }
    #txtType:focus{
      border-color: rgba(53,194,255,0.5);
      box-shadow: 0 0 0 4px rgba(53,194,255,0.15);
      background: rgba(255,255,255,0.08);
    }
    #txtType.mistake{
      animation: wobble 180ms ease;
      border-color: rgba(255,107,107,0.5);
      box-shadow: 0 0 0 4px rgba(255,107,107,0.18);
      background: rgba(255,107,107,0.12);
    }
    @keyframes wobble {
      0% { transform: translateX(0) }
      25% { transform: translateX(-4px) }
      50% { transform: translateX(3px) }
      75% { transform: translateX(-2px) }
      100% { transform: translateX(0) }
    }

    /* Word raindrops */
    .drop{
      position:absolute;
      left:0; top:0;
      transform: translate3d(0,0,0);
      padding: 8px 12px 10px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)) , linear-gradient(180deg, var(--drop-2), var(--drop));
      color:#fff;
      border: 1px solid rgba(255,255,255,0.25);
      box-shadow:
        0 8px 16px rgba(0,0,0,0.35),
        inset 0 1px 6px rgba(255,255,255,0.35);
      user-select:none;
      white-space: nowrap;
      font-weight: 700;
      font-size: clamp(14px, 1.9vw, 20px);
      will-change: transform;
      z-index:3;
    }
    .drop::after{
      content:"";
      position:absolute;
      left: 50%; bottom: -8px;
      width: 12px; height: 12px;
      transform: translateX(-50%) rotate(45deg);
      background: linear-gradient(180deg, var(--drop-2), var(--drop));
      border-right: 1px solid rgba(255,255,255,0.25);
      border-bottom: 1px solid rgba(255,255,255,0.25);
    }
    .drop .typed{ color: #fff; text-shadow: 0 0 6px rgba(255,255,255,0.9); }
    .drop .remaining{ color: #e1f4ff; opacity: 0.9 }
    .drop.dimmed{ opacity: 0.5; filter: saturate(0.8); }
    .drop.target{
      outline: 2px solid rgba(255,255,255,0.7);
      box-shadow: 0 0 0 2px rgba(53,194,255,0.65), 0 8px 16px rgba(0,0,0,0.35), inset 0 1px 6px rgba(255,255,255,0.35);
    }
    .drop.pop{
      animation: pop 180ms ease forwards;
    }
    @keyframes pop{
      0%{ transform: scale(1) translate3d(var(--x,0), var(--y,0), 0); opacity:1 }
      60%{ transform: scale(1.15) translate3d(var(--x,0), var(--y,0), 0); opacity:1 }
      100%{ transform: scale(0.6) translate3d(var(--x,0), var(--y,0), 0); opacity:0 }
    }

    /* Overlay (Pause / Game Over / Help) */
    .overlay{
      position:absolute; inset:0;
      background: rgba(0,0,0,0.45);
      display:none; align-items: center; justify-content: center;
      z-index: 6; padding: 20px;
      backdrop-filter: blur(2px);
    }
    .overlay.visible{ display:flex }
    .panel{
      width: min(720px, 92vw);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 12px 36px rgba(0,0,0,0.45);
    }
    .panel h2{
      margin:0 0 10px;
      font-size: clamp(18px, 2.4vw, 26px);
    }
    .panel p{ color: var(--muted); margin: 6px 0 }
    .panel .grid{
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
    }
    .panel .row{ display:flex; justify-content: space-between; }
    .panel .val{ font-weight: 800 }
    .panel .actions{ display:flex; gap: 8px; justify-content: flex-end; margin-top: 12px; flex-wrap: wrap; }

    footer{
      position:absolute; right: 10px; bottom: 8px; z-index: 3;
      color: rgba(255,255,255,0.5);
      font-size: 12px; user-select: none;
    }

    /* Responsive helpers */
    @media (max-height: 640px){
      #dock{ bottom: 12px; padding:8px }
      #groundLine{ bottom: 8px }
    }
  </style>
</head>
<body>
  <header>
    <h1><span class="logo" aria-hidden="true"></span> Typing Rain</h1>
    <nav id="controls" aria-label="Game controls">
      <button id="btnStart" class="primary" type="button" title="Start (Enter)">Start</button>
      <button id="btnPause" type="button" title="Pause / Resume (Esc)">Pause</button>
      <button id="btnReset" class="warn" type="button" title="Reset">Reset</button>
      <button id="btnHelp" class="icon" type="button" aria-label="Help" title="How to play">?</button>
    </nav>
  </header>

  <main id="game" role="main" aria-label="Typing Rain game area">
    <div id="hud" role="status" aria-live="polite">
      <div class="stat"><span class="label">Score</span><span id="scoreValue" class="value">0</span></div>
      <div class="stat"><span class="label">Accuracy</span><span id="accuracyValue" class="value">100%</span></div>
      <div class="stat"><span class="label">Level</span><span id="levelValue" class="value">1</span></div>
      <div class="stat"><span class="label">Misses</span><span id="missesValue" class="value">0</span></div>
      <div class="stat"><span class="label">WPM</span><span id="wpmValue" class="value">0</span></div>
    </div>

    <section id="playfield" aria-label="Playfield">
      <div id="groundLine" aria-hidden="true"></div>

      <div class="skyline far" aria-hidden="true">
        <svg viewBox="0 0 100 30" preserveAspectRatio="none">
          <path d="M0,30 L0,18 4,18 4,12 7,12 7,20 13,20 13,10 17,10 17,16 22,16 22,6 25,6 25,18 31,18 31,14 37,14 37,21 44,21 44,11 47,11 47,19 53,19 53,9 56,9 56,17 61,17 61,13 67,13 67,22 74,22 74,8 78,8 78,16 84,16 84,20 89,20 89,12 93,12 93,18 100,18 100,30 Z"/>
        </svg>
      </div>
      <div class="skyline near" aria-hidden="true">
        <svg viewBox="0 0 100 34" preserveAspectRatio="none">
          <path d="M0,34 L0,18 5,18 5,10 9,10 9,22 15,22 15,14 20,14 20,26 28,26 28,8 32,8 32,22 38,22 38,16 45,16 45,28 52,28 52,12 56,12 56,20 60,20 60,26 66,26 66,18 72,18 72,30 80,30 80,10 84,10 84,20 90,20 90,26 96,26 96,16 100,16 100,34 Z"/>
        </svg>
      </div>
    </section>

    <div id="dock">
      <input id="txtType" type="text" inputmode="latin" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" aria-label="Type here to catch the falling words" placeholder="Start the game and type here..." />
    </div>

    <div id="overlayPause" class="overlay" aria-modal="true" role="dialog" aria-labelledby="pauseTitle">
      <div class="panel">
        <h2 id="pauseTitle">Paused</h2>
        <p id="statusMessage">Take a breath. Press Resume to continue.</p>
        <div class="actions">
          <button id="btnResume" class="primary" type="button">Resume</button>
          <button id="btnPauseToReset" class="warn" type="button">Reset</button>
        </div>
      </div>
    </div>

    <div id="overlayGameOver" class="overlay" aria-modal="true" role="dialog" aria-labelledby="overTitle">
      <div class="panel">
        <h2 id="overTitle">Game Over</h2>
        <div class="grid" style="margin-top:8px">
          <div class="row"><span>Score</span><span id="finalScore" class="val">0</span></div>
          <div class="row"><span>Words Cleared</span><span id="finalCleared" class="val">0</span></div>
          <div class="row"><span>Accuracy</span><span id="finalAccuracy" class="val">0%</span></div>
          <div class="row"><span>WPM</span><span id="finalWpm" class="val">0</span></div>
        </div>
        <div class="actions">
          <button id="btnPlayAgain" class="primary" type="button">Play Again</button>
        </div>
      </div>
    </div>

    <div id="overlayHelp" class="overlay" aria-modal="true" role="dialog" aria-labelledby="helpTitle">
      <div class="panel">
        <h2 id="helpTitle">How To Play</h2>
        <p>Type the words on the raindrops before they hit the ground line. Each correct word scores points. Let too many fall and the game ends.</p>
        <ul>
          <li>Enter: Start game</li>
          <li>Esc: Pause / Resume</li>
          <li>Focus stays in the input box; type continuously</li>
          <li>Accuracy counts only when you add characters (backspace does not affect it)</li>
        </ul>
        <p>Difficulty increases with your score: words fall faster and appear more frequently.</p>
        <div class="actions">
          <button id="btnCloseHelp" class="primary" type="button">Close</button>
        </div>
      </div>
    </div>
  </main>

  <footer>
    Typing Rain • Vanilla JS • 1280×720 friendly
  </footer>

  <script>
    (function(){
      "use strict";

      // Elements
      const el = {
        playfield: document.getElementById('playfield'),
        txtType: document.getElementById('txtType'),
        btnStart: document.getElementById('btnStart'),
        btnPause: document.getElementById('btnPause'),
        btnReset: document.getElementById('btnReset'),
        btnHelp: document.getElementById('btnHelp'),
        btnResume: document.getElementById('btnResume'),
        btnPauseToReset: document.getElementById('btnPauseToReset'),
        btnPlayAgain: document.getElementById('btnPlayAgain'),
        btnCloseHelp: document.getElementById('btnCloseHelp'),
        overlayPause: document.getElementById('overlayPause'),
        overlayGameOver: document.getElementById('overlayGameOver'),
        overlayHelp: document.getElementById('overlayHelp'),
        scoreValue: document.getElementById('scoreValue'),
        accuracyValue: document.getElementById('accuracyValue'),
        levelValue: document.getElementById('levelValue'),
        missesValue: document.getElementById('missesValue'),
        wpmValue: document.getElementById('wpmValue'),
        finalScore: document.getElementById('finalScore'),
        finalCleared: document.getElementById('finalCleared'),
        finalAccuracy: document.getElementById('finalAccuracy'),
        finalWpm: document.getElementById('finalWpm')
      };

      // Word bank - curated small to moderate list
      const WORDS = `
      rain city storm cloud night light neon skyline shadow static shimmer glide drift splash flash drop breeze mist river ocean spark shine bright calm quick slow code type keyboard pixel debug build deploy commit branch merge logic array object string number window event focus shift enter escape rhythm melody jazz blues synth drum bass guitar piano violin rocket orbit planet comet galaxy lunar solar void nebula star meteor eclipse tide wave crest summit canyon valley bridge tunnel street avenue station park plaza garden forest desert island coast beach harbor port castle turret palace temple museum library theater cinema studio campus office market coffee pizza burger sushi taco pasta bread apple berry mango banana lemon lime melon cherry peach cocoa sugar salt pepper basil thyme honey oats rice noodle garlic onion carrot potato tomato lettuce pepper mint proud brave smart swift crisp sharp keen kind noble pure true vivid vivid happy lucky magic rapid basic major minor alpha beta gamma delta omega cyber micro macro nano giga tera cloud server client socket cache stack queue graph tree heap hash logic react scope closure module import export async await fetch json parse local state render mount loop frame spawn score level input pause reset
      `.trim().split(/\s+/).filter(Boolean);

      // Game State
      const state = {
        running: false,
        paused: false,
        over: false,
        score: 0,
        misses: 0,
        maxMisses: 10,
        level: 1,
        wordsCleared: 0,
        typedChars: 0,
        correctChars: 0,
        lastTime: 0,
        spawnTimer: 0,
        spawnInterval: 1600,
        baseSpeed: 80, // pixels per second
        startTime: 0,
        targetWordId: null,
        prevInput: '',
        nextId: 1,
        fieldRect: null,
        raf: 0,
        minSpawnInterval: 550,
        maxOnScreen: 10
      };

      const active = new Map(); // id -> wordObj

      function measureField(){
        state.fieldRect = el.playfield.getBoundingClientRect();
      }
      window.addEventListener('resize', measureField);

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
      function randBetween(a,b){ return Math.random()*(b-a)+a; }
      function pickWord(){
        const bias = clamp(state.level-1, 0, 6);
        // Slightly prefer longer words on higher levels
        const pool = WORDS.filter(w => w.length >= Math.min(3+bias, 10) && w.length <= Math.min(7+bias*2, 16));
        return (pool.length ? pool : WORDS)[Math.floor(Math.random()*(pool.length?pool.length:WORDS.length))].toLowerCase();
      }

      function makeDrop(text){
        const id = state.nextId++;
        const elDrop = document.createElement('div');
        elDrop.className = 'drop';
        elDrop.setAttribute('data-id', id);
        elDrop.setAttribute('aria-label', text);
        elDrop.innerHTML = `<span class="typed"></span><span class="remaining"></span>`;
        el.playfield.appendChild(elDrop);
        const drop = {
          id,
          text,
          x: 0,
          y: -30,
          speed: state.baseSpeed * randBetween(0.95, 1.18),
          el: elDrop,
          width: 0,
          height: 0
        };
        // Initialize position across the width, avoiding edges
        const margin = 28;
        const fieldWidth = state.fieldRect.width;
        drop.x = Math.floor(randBetween(margin, fieldWidth - margin));
        // Update text shards
        setDropText(drop, '');
        // Measure once rendered
        const r = elDrop.getBoundingClientRect();
        drop.width = r.width;
        drop.height = r.height + 8; // include tip
        // Clamp within field
        drop.x = clamp(drop.x, margin, fieldWidth - margin - drop.width);
        setDropPos(drop);

        active.set(id, drop);
      }

      function setDropText(drop, typed){
        const typedSpan = drop.el.querySelector('.typed');
        const remainingSpan = drop.el.querySelector('.remaining');
        const tlen = typed.length;
        typedSpan.textContent = typed;
        remainingSpan.textContent = drop.text.slice(tlen);
      }

      function setDropPos(drop){
        drop.el.style.setProperty('--x', drop.x+'px');
        drop.el.style.setProperty('--y', drop.y+'px');
        drop.el.style.transform = `translate3d(${drop.x}px, ${drop.y}px, 0)`;
      }

      function removeDrop(drop, popped=false){
        if(!drop || !drop.el) return;
        if(popped){
          drop.el.classList.add('pop');
          setTimeout(()=> drop.el.remove(), 200);
        }else{
          drop.el.remove();
        }
        active.delete(drop.id);
      }

      function highlightTargets(input){
        const val = input.toLowerCase();
        let candidates = [];
        active.forEach(d => {
          if(val && d.text.startsWith(val)){
            candidates.push(d);
          }
        });
        // determine target: closest to ground (largest y)
        let target = null;
        if(candidates.length){
          candidates.sort((a,b)=> (b.y - a.y) || (a.text.length - b.text.length));
          target = candidates[0];
        }
        // Update visuals
        active.forEach(d=>{
          d.el.classList.remove('target');
          d.el.classList.toggle('dimmed', !!val && !d.text.startsWith(val));
          if(val && d.text.startsWith(val)){
            setDropText(d, val);
          }else{
            setDropText(d, '');
          }
        });
        if(target){
          target.el.classList.add('target');
          state.targetWordId = target.id;
        }else{
          state.targetWordId = null;
        }
      }

      // Scoring and progression
      function addScore(wordLen){
        const bonus = Math.floor(state.level*3);
        const pts = 10 + wordLen*2 + bonus;
        state.score += pts;
        state.wordsCleared += 1;
        updateLevelAndPace();
        updateHud();
      }

      function onMiss(){
        state.misses += 1;
        updateHud();
        if(state.misses >= state.maxMisses){
          gameOver();
        }
      }

      function accuracy(){
        if(state.typedChars === 0) return 100;
        return (state.correctChars / state.typedChars) * 100;
      }

      function wpm(){
        const elapsedMs = (performance.now() - state.startTime);
        const minutes = Math.max(elapsedMs / 60000, 0.1);
        return Math.round(state.wordsCleared / minutes);
      }

      function updateHud(){
        el.scoreValue.textContent = state.score.toString();
        el.levelValue.textContent = state.level.toString();
        el.missesValue.textContent = state.misses.toString();
        el.accuracyValue.textContent = `${accuracy().toFixed(1)}%`;
        el.wpmValue.textContent = wpm().toString();
      }

      function updateLevelAndPace(){
        // Level up every 150 points for steady ramp
        const newLevel = Math.max(1, Math.floor(state.score / 150) + 1);
        if(newLevel !== state.level){
          state.level = newLevel;
        }
        // Spawn faster and fall faster with level
        state.spawnInterval = clamp(1600 - (state.level-1)*120, state.minSpawnInterval, 1600);
        state.baseSpeed = 80 + (state.level-1)*22;
      }

      function gameLoop(ts){
        if(!state.running) return;
        if(!state.lastTime) state.lastTime = ts;
        const dt = (ts - state.lastTime) / 1000; // seconds
        state.lastTime = ts;

        if(!state.paused){
          state.spawnTimer += ts - (ts - dt*1000);
          // Update drops
          const groundY = state.fieldRect.height - 24; // above ground line and tip
          const toRemove = [];
          active.forEach(drop=>{
            // Update speed per current level
            const sizeFactor = clamp(drop.text.length / 8, 0.85, 1.25);
            const levelFactor = 1 + (state.level-1)*0.12;
            const dy = drop.speed * levelFactor * sizeFactor * dt;
            drop.y += dy;
            setDropPos(drop);
            if(drop.y + drop.height >= groundY){
              toRemove.push(drop);
            }
          });
          toRemove.forEach(drop=>{
            removeDrop(drop, false);
            onMiss();
          });

          // Spawn logic
          state.spawnTimer += dt*1000;
          if(state.spawnTimer >= state.spawnInterval && active.size < state.maxOnScreen){
            state.spawnTimer = 0;
            makeDrop(pickWord());
          }
        }

        state.raf = requestAnimationFrame(gameLoop);
      }

      function startGame(){
        if(state.running && !state.over){
          // Already running; if paused, resume
          if(state.paused){ resumeGame(); }
          return;
        }
        resetGame(true);
        state.running = true;
        state.paused = false;
        state.over = false;
        state.startTime = performance.now();
        state.lastTime = 0;
        state.spawnTimer = 0;
        updateHud();
        el.txtType.placeholder = "Type the falling words...";
        el.txtType.focus();
        // Seed a few words slowly at start
        makeDrop(pickWord());
        setTimeout(()=> active.size<2 && makeDrop(pickWord()), 600);
        setTimeout(()=> active.size<3 && makeDrop(pickWord()), 1200);
        state.raf = requestAnimationFrame(gameLoop);
      }

      function pauseGame(){
        if(!state.running || state.paused || state.over) return;
        state.paused = true;
        el.overlayPause.classList.add('visible');
        el.txtType.blur();
      }

      function resumeGame(){
        if(!state.running || !state.paused || state.over) return;
        state.paused = false;
        el.overlayPause.classList.remove('visible');
        state.lastTime = 0; // avoid dt spike
        el.txtType.focus();
      }

      function resetGame(keepOverlays=false){
        // Clear drops
        active.forEach(d => d.el.remove());
        active.clear();
        // Reset state
        state.running = false;
        state.paused = false;
        state.over = false;
        state.score = 0;
        state.misses = 0;
        state.level = 1;
        state.wordsCleared = 0;
        state.typedChars = 0;
        state.correctChars = 0;
        state.prevInput = '';
        state.lastTime = 0;
        state.spawnTimer = 0;
        state.spawnInterval = 1600;
        state.baseSpeed = 80;
        state.targetWordId = null;
        cancelAnimationFrame(state.raf);
        updateHud();
        if(!keepOverlays){
          el.overlayPause.classList.remove('visible');
          el.overlayGameOver.classList.remove('visible');
        }
        el.txtType.value = '';
        el.txtType.placeholder = "Press Start (or Enter) to play";
        measureField();
      }

      function gameOver(){
        state.over = true;
        state.running = false;
        cancelAnimationFrame(state.raf);
        // Clear remaining drops visually
        active.forEach(d => d.el.classList.add('dimmed'));
        // Show overlay with stats
        el.finalScore.textContent = state.score.toString();
        el.finalCleared.textContent = state.wordsCleared.toString();
        el.finalAccuracy.textContent = `${accuracy().toFixed(1)}%`;
        el.finalWpm.textContent = wpm().toString();
        el.overlayPause.classList.remove('visible');
        el.overlayGameOver.classList.add('visible');
        el.txtType.blur();
      }

      // Input accuracy tracking and matching
      function onInput(e){
        if(!state.running || state.paused || state.over) return;
        const current = el.txtType.value.toLowerCase().trim();
        const previous = state.prevInput;
        if(current.length > previous.length){
          // Added characters
          const added = current.slice(previous.length);
          for(let i=0;i<added.length;i++){
            const candidate = previous + added.slice(0,i+1);
            state.typedChars += 1;
            const matchesAny = Array.from(active.values()).some(d => d.text.startsWith(candidate));
            if(matchesAny){
              state.correctChars += 1;
            }else{
              // quick visual feedback
              el.txtType.classList.add('mistake');
              setTimeout(()=> el.txtType.classList.remove('mistake'), 160);
            }
          }
        }
        state.prevInput = current;
        // Highlight and set target
        highlightTargets(current);

        // If there is a perfect match, pop it
        if(state.targetWordId){
          const target = active.get(state.targetWordId);
          if(target && current === target.text){
            addScore(target.text.length);
            removeDrop(target, true);
            el.txtType.value = '';
            state.prevInput = '';
            state.targetWordId = null;
            // After removal, update highlights (clear)
            highlightTargets('');
          }
        }
        updateHud();
      }

      // Handle keydown for quick controls
      function onKeyDown(e){
        // Global shortcuts
        if(e.key === 'Enter' && !state.running){
          e.preventDefault();
          startGame();
          return;
        }
        if(e.key === 'Escape' && state.running && !state.over){
          e.preventDefault();
          if(state.paused) resumeGame(); else pauseGame();
          return;
        }
        // Keep input focused during play
        if(state.running && !state.paused && document.activeElement !== el.txtType){
          el.txtType.focus({preventScroll:true});
        }
      }

      // Button events
      el.btnStart.addEventListener('click', startGame);
      el.btnPause.addEventListener('click', ()=> state.paused ? resumeGame() : pauseGame());
      el.btnReset.addEventListener('click', ()=> resetGame());
      el.btnHelp.addEventListener('click', ()=>{
        el.overlayHelp.classList.add('visible');
      });
      el.btnCloseHelp.addEventListener('click', ()=>{
        el.overlayHelp.classList.remove('visible');
        if(state.running && state.paused){ resumeGame(); }
        else if(state.running){ el.txtType.focus(); }
      });
      el.btnResume.addEventListener('click', resumeGame);
      el.btnPauseToReset.addEventListener('click', ()=> { resetGame(); });
      el.btnPlayAgain.addEventListener('click', ()=>{
        el.overlayGameOver.classList.remove('visible');
        startGame();
      });

      // Input events
      el.txtType.addEventListener('input', onInput);
      document.addEventListener('keydown', onKeyDown);

      // Auto-pause on blur
      window.addEventListener('blur', ()=> {
        if(state.running && !state.paused && !state.over) pauseGame();
      });

      // Initial
      measureField();
      updateHud();
      // Focus input placeholder on click on playfield
      el.playfield.addEventListener('pointerdown', ()=> el.txtType.focus());

      // Ensure a clean start at 1280x720 and beyond
      // Nothing else to init
    })();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weather Theatre — A Canvas Matinée</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* 
      Weather Theatre — Destylized, Operator-Friendly Revision
      Goals:
      - Clear, high-contrast interface: white background, black text
      - All controls >= 44px target size
      - Obvious keyboard focus outlines
      - Immediate feedback with visible status proxies
      - Keep existing IDs and functions for non-regression tests
      - Add missing advanced interactions (manual spotlight, partial curtain drag)
      - Ensure everything fits in 1280x720 without scrolling horizontally
    */

    :root{
      /* Basic palette */
      --bg:#ffffff;
      --text:#000000;
      --muted:#333333;
      --accent:#0055ff;
      --good:#008a00;
      --warn:#c67900;
      --danger:#c00000;

      /* Control sizes */
      --sidebar-w:320px;
      --ctl-min:44px;
      --gap:14px;

      /* Simple borders */
      --line:#000000;
      --line-weak:#888888;

      /* Spotlight indicator size */
      --spot-ind-size:14px;
    }

    *{ box-sizing: border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden; /* keep canvas stage stable in 720p */
    }

    /* Header — simple, left-aligned */
    header{
      display:flex;
      align-items:center;
      gap:12px;
      padding:8px 10px;
      border-bottom:1px solid var(--line-weak);
    }
    header h1{
      margin:0;
      font-size:18px;
      font-weight:700;
      line-height:1.2;
    }
    header p{
      margin:0;
      font-size:12px;
      color:var(--muted);
    }

    /* Two-column layout: controls left (fixed width), stage right (flex) */
    main{
      display:grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      grid-template-rows: calc(100vh - 41px); /* header approx height */
      width:100vw;
      height: calc(100vh - 41px);
    }

    /* Left Sidebar (Control Panel) */
    aside#controlPanel{
      border-right:1px solid var(--line-weak);
      padding:12px;
      overflow:auto;
    }
    .panel{
      padding:12px;
      border:1px solid var(--line-weak);
      margin-bottom:12px;
    }
    .panel h2{
      margin:0 0 8px 0;
      font-size:14px;
      text-transform:uppercase;
      letter-spacing:0.5px;
      color:var(--muted);
    }
    .legend{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
      margin-top:6px;
    }
    .row{
      display:flex;
      align-items:center;
      gap:12px;
      margin-bottom:12px;
      flex-wrap:wrap;
      padding:4px 0;
      border-top:1px dashed #ccc;
    }
    .row:first-of-type{ border-top:none; }
    .label{
      min-width:72px;
      font-weight:700;
      font-size:14px;
    }
    .value{
      min-width:48px;
      text-align:right;
      font-size:14px;
    }
    .value.max::after{
      content:" ✓";
      color:var(--good);
      font-weight:700;
    }
    .value.zero{
      color:var(--muted);
    }

    /* Controls — large target sizes */
    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      width:180px;
      min-height:var(--ctl-min);
      background:transparent;
    }
    input[type="range"]:focus-visible{
      outline:3px solid var(--accent);
      outline-offset:2px;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:6px;
      background:#000000;
    }
    input[type="range"]::-moz-range-track{
      height:6px;
      background:#000000;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:28px;
      height:28px;
      background:#ffffff;
      border:2px solid #000000;
      margin-top:-11px;
    }
    input[type="range"]::-moz-range-thumb{
      width:28px;
      height:28px;
      background:#ffffff;
      border:2px solid #000000;
    }

    /* Number inputs and +/- buttons */
    .numwrap{
      display:flex;
      gap:6px;
      align-items:center;
      flex: 1 1 auto;
    }
    input[type="number"]{
      width:72px;
      min-height:var(--ctl-min);
      border:1px solid var(--line);
      padding:4px 6px;
      font-size:14px;
    }
    .stepper{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .stepper button{
      min-width:var(--ctl-min);
      min-height:var(--ctl-min);
      border:1px solid var(--line);
      background:#ffffff;
      color:#000000;
      font-weight:700;
      cursor:pointer;
    }
    .stepper button:focus-visible,
    button:focus-visible{
      outline:3px solid var(--accent);
      outline-offset:2px;
    }
    .buttons{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      margin-top:8px;
    }
    button{
      min-height:var(--ctl-min);
      padding:4px 10px;
      border:1px solid var(--line);
      background:#ffffff;
      color:#000000;
      cursor:pointer;
      font-weight:700;
      font-size:14px;
    }
    button[aria-disabled="true"]{
      opacity:0.5;
      cursor:not-allowed;
    }

    /* Toggle (Matinée/Night) */
    .toggle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-top:8px;
    }
    .switch{
      display:flex;
      align-items:center;
      gap:6px;
    }
    .switch input{ width:24px; height:24px; }
    .toggle .label{ font-weight:700; }
    #modeLabel{
      border:1px solid var(--line);
      padding:4px 8px;
      min-height:var(--ctl-min);
      display:flex;
      align-items:center;
      justify-content:center;
      min-width:110px;
      font-size:14px;
      font-weight:700;
    }

    /* Status proxies */
    .statusPanel{
      border:1px solid var(--line-weak);
      padding:10px;
      font-size:12px;
    }
    .statusList{
      display:grid;
      grid-template-columns: 1fr;
      gap:6px;
    }
    .statusItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      border-top:1px dashed #ccc;
      padding-top:6px;
    }
    .statusItem:first-child{ border-top:none; }
    .statusLabel{ font-weight:700; }
    .statusValue{ min-width:100px; text-align:right; }

    /* Stage area (right column) */
    #stageSection{
      position:relative;
      background:#ffffff;
      overflow:hidden;
    }
    #stageContainer{
      position:relative;
      width:100%;
      height: calc(100% - 56px); /* reserve for bottom bar */
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      outline:none;
    }
    #stageContainer:focus-visible{
      outline:3px solid var(--accent);
      outline-offset:-3px;
    }
    #stageCanvas{
      display:block;
      width:100%;
      height:100%;
      background:transparent;
    }

    /* Subtitle — simple strip centered */
    #subtitle{
      position:absolute;
      left:10px;
      right:10px;
      bottom:10px;
      padding:8px 10px;
      border:1px solid var(--line);
      background:#ffffff;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-size:14px;
      color:#000000;
    }
    #subtitleText{
      display:inline-block;
      white-space:nowrap;
      overflow:hidden;
      vertical-align:bottom;
    }

    /* Curtain simplified: two solid panels that slide horizontally */
    #curtain{
      position:absolute;
      inset:0;
      display:flex;
      z-index:9;
      pointer-events:auto;
      background:transparent;
    }
    #curtain.hidden{
      pointer-events:none;
    }
    .curtain-half{
      flex:1;
      background:#dddddd;
      border-right:1px solid #000000;
      transform: translateX(0);
      will-change: transform;
    }
    .curtain-half.right{
      border-right:none;
      border-left:1px solid #000000;
    }
    .valance{
      position:absolute;
      left:0; right:0; top:0; height:48px;
      background:#cccccc;
      z-index:10;
      border-bottom:1px solid #000000;
    }
    .curtain-cta{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      z-index:11;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      background:#ffffff;
      border:1px solid #000000;
      padding:8px;
    }
    .rope{
      font-size:12px;
      color:#000000;
    }
    /* Keep class name for compatibility, but we will animate via JS for partial drag as well */
    .curtain-open .curtain-half.left{ transform: translateX(-102%); }
    .curtain-open .curtain-half.right{ transform: translateX(102%); }

    /* Spotlight indicator — visible "handle" for manual steering */
    #spotlightIndicator{
      position:absolute;
      width:var(--spot-ind-size);
      height:var(--spot-ind-size);
      background:#ffffff;
      border:2px solid #000000;
      transform:translate(-50%, -50%);
      z-index:8;
      display:none; /* visible when curtain open and feature enabled */
      pointer-events:none; /* indicator follows pointer; dragging is on stageContainer */
    }
    #spotlightIndicator[data-visible="true"]{ display:block; }

    /* Bottom bar (stage-side controls) */
    #stageControlsBar{
      position:absolute;
      left:0; right:0;
      bottom:0;
      height:56px;
      border-top:1px solid var(--line-weak);
      background:#ffffff;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:12px;
      z-index:4;
    }
    #stageControlsBar button{
      min-height:var(--ctl-min);
      padding:4px 10px;
      border:1px solid #000000;
      background:#ffffff;
      font-weight:700;
    }
    .highlight{
      border:2px solid var(--accent) !important;
    }

    /* Active slider visual state */
    .row.active{
      background:#f2f2f2;
      outline:2px solid var(--accent);
    }

    /* Stage change hint (brief outline class) */
    .changed-outline{
      outline:3px solid var(--accent);
    }

    /* Keyboard hint */
    .kbdHint{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }

    /* Responsive (simple) */
    @media (max-width: 1100px){
      main{
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        height:auto;
      }
      aside#controlPanel{
        border-right:none;
        border-bottom:1px solid var(--line-weak);
        max-height:320px;
      }
      #stageSection{
        height: calc(100vh - 41px - 320px);
        min-height:360px;
      }
    }

    /* 
      Extensive accessibility helpers
      Ensure every interactive element shows a strong focus ring and 
      is reachable via keyboard (Tab order follows DOM order).
    */
    a:focus-visible, select:focus-visible{
      outline:3px solid var(--accent);
      outline-offset:2px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Weather Theatre</h1>
    <p>Operator-friendly canvas stage. Clear controls. Keyboard-ready.</p>
  </header>

  <main>
    <aside id="controlPanel" aria-label="Controls">
      <div class="panel" id="moodPanel">
        <h2>Mood Mix</h2>

        <!-- Theme toggle placed above sliders for clear hierarchy -->
        <div class="toggle" id="modeToggleGroup">
          <div class="label">Theme</div>
          <div class="switch">
            <label for="modeToggle">Night</label>
            <input id="modeToggle" type="checkbox" aria-label="Matinée or Night mode" aria-pressed="false">
          </div>
          <div id="modeLabel">Matinée</div>
        </div>
        <div class="kbdHint">Tip: Space toggles Night. Sliders respond to Arrow keys. Press Enter to Apply.</div>

        <!-- Cosy -->
        <div class="row" id="cosyRow">
          <div class="label">Cosy</div>
          <input id="cosySlider" type="range" min="0" max="100" value="60" step="1" aria-label="Cosy mood slider">
          <div class="numwrap">
            <input id="cosyNumber" type="number" min="0" max="100" step="1" value="60" aria-label="Cosy numeric value">
            <div class="stepper">
              <button id="cosyMinus" aria-label="Decrease Cosy">−</button>
              <button id="cosyPlus" aria-label="Increase Cosy">+</button>
            </div>
          </div>
          <div class="value" id="cosyValue">60%</div>
        </div>

        <!-- Eerie -->
        <div class="row" id="eerieRow">
          <div class="label">Eerie</div>
          <input id="eerieSlider" type="range" min="0" max="100" value="20" step="1" aria-label="Eerie mood slider">
          <div class="numwrap">
            <input id="eerieNumber" type="number" min="0" max="100" step="1" value="20" aria-label="Eerie numeric value">
            <div class="stepper">
              <button id="eerieMinus" aria-label="Decrease Eerie">−</button>
              <button id="eeriePlus" aria-label="Increase Eerie">+</button>
            </div>
          </div>
          <div class="value" id="eerieValue">20%</div>
        </div>

        <!-- Heroic -->
        <div class="row" id="heroicRow">
          <div class="label">Heroic</div>
          <input id="heroicSlider" type="range" min="0" max="100" value="40" step="1" aria-label="Heroic mood slider">
          <div class="numwrap">
            <input id="heroicNumber" type="number" min="0" max="100" step="1" value="40" aria-label="Heroic numeric value">
            <div class="stepper">
              <button id="heroicMinus" aria-label="Decrease Heroic">−</button>
              <button id="heroicPlus" aria-label="Increase Heroic">+</button>
            </div>
          </div>
          <div class="value" id="heroicValue">40%</div>
        </div>

        <div class="buttons">
          <button id="applyButton" title="Apply current mood settings">Apply</button>
          <button id="resetButton" title="Reset sliders to defaults">Reset</button>
          <button id="dropCurtainButton" title="Close the curtain again">Drop Curtain</button>
        </div>
        <div class="legend" id="moodLegend">
          Move pointer over the stage for parallax. You can steer the spotlight by dragging on the stage; releasing returns to automatic sweep. All changes apply instantly; press Apply to confirm and log your current mix.
        </div>
      </div>

      <div class="panel">
        <h2>Spotlight</h2>
        <div class="row">
          <div class="label">Manual</div>
          <div class="numwrap">
            <input id="spotlightManualToggle" type="checkbox" aria-label="Hold manual spotlight">
            <label for="spotlightManualToggle">Hold manual control</label>
          </div>
          <div class="value" id="spotlightStatus">auto</div>
        </div>
        <div class="legend">
          Drag anywhere on the stage to move the spotlight. With "Hold manual control" enabled, it stays where you place it. Otherwise, it resumes its automatic sweep after a moment.
        </div>
      </div>

      <div class="panel statusPanel">
        <h2>Status</h2>
        <div class="statusList">
          <div class="statusItem">
            <div class="statusLabel">Apply</div>
            <div class="statusValue" id="applyStatus">idle</div>
          </div>
          <div class="statusItem">
            <div class="statusLabel">Theme</div>
            <div class="statusValue" id="themeStatus">ready</div>
          </div>
          <div class="statusItem">
            <div class="statusLabel">Curtain</div>
            <div class="statusValue" id="curtainStatus">closed</div>
          </div>
          <div class="statusItem">
            <div class="statusLabel">Preview</div>
            <div class="statusValue" id="previewStatus">initializing</div>
          </div>
          <div class="statusItem">
            <div class="statusLabel">Download</div>
            <div class="statusValue" id="downloadStatus">disabled</div>
          </div>
        </div>
        <div class="buttons" style="margin-top:10px;">
          <button id="downloadPNG" aria-disabled="true">Download PNG</button>
          <a id="downloadLink" href="#" download="weather-theatre.png" style="display:none;">Save</a>
        </div>
      </div>

      <div class="panel">
        <h2>Mock Forecast</h2>
        <div class="legend">
          • Mostly cloudy with soft sun breaks<br>
          • Light breeze around 7 km/h<br>
          • A brief drizzle may appear toward evening
        </div>
      </div>

      <div class="panel">
        <h2>About</h2>
        <div class="legend">
          Three moods remix the same forecast into different stagecraft.
          Cosy warms the palette and softens fog; eerie leans teal with thicker haze; heroic adds contrast and a bolder sweep.
          This revision focuses on straightforward control ergonomics and clear feedback:
          - All interactive elements are easy to see, easy to click, and easy to tab to.
          - Every success action updates a visible status field in this panel.
          - Sliders have adjacent numeric inputs and +/- step buttons for precision.
          - Spotlight is both automatic and steerable by drag/keyboard.
          - Curtain supports clicking, keyboard, and partial drag with snapping.
          Notes on keyboard:
          - Tab moves focus; Shift+Tab moves backward.
          - Space toggles checkboxes and Night/Matinée.
          - Left/Right change focused sliders by 1; Up/Down by 5.
          - Arrow keys in the stage move the spotlight in steps.
        </div>
      </div>

      <div class="panel">
        <h2>Help & Accessibility</h2>
        <div class="legend">
          Screen reader labels and ARIA:
          - Each slider announces its name and value.
          - Theme toggle has an aria-pressed state that reflects Night/Matinée.
          - Status values are plain text to keep announcements predictable.
          - Subtitle at the bottom of the stage is aria-live polite to avoid chatter.
          Operator tips:
          - To test edge cases, set any slider to 0% or 100% with the numeric input.
          - Press Reset to snap back to baseline; press Drop Curtain to close the stage and stop parallax/spotlight interactions.
          - Download PNG is enabled when a fresh capture is prepared after Raise Curtain and any scene update. 
          - Apply logs your current mix; Apply also sets a data-applied attribute on the body for automation.
        </div>
      </div>
    </aside>

    <section id="stageSection" aria-label="Canvas Stage">
      <div id="stageContainer" tabindex="0" aria-label="Stage container. Arrow keys move spotlight.">
        <canvas id="stageCanvas" role="img" aria-label="A stylized weather scene drawn on canvas" data-ready="false"></canvas>

        <div id="subtitle" aria-live="polite" aria-atomic="true">
          <span id="subtitleText"></span>
        </div>

        <div id="curtain" class="">
          <div class="valance" aria-hidden="true"></div>
          <div class="curtain-half left" aria-hidden="true"></div>
          <div class="curtain-half right" aria-hidden="true"></div>
          <div class="curtain-cta" role="dialog" aria-labelledby="curtainButton">
            <button id="curtainButton">Raise Curtain</button>
            <div class="rope">Tap to reveal today's scene</div>
          </div>
        </div>

        <div id="spotlightIndicator" aria-hidden="true" data-visible="false"></div>

        <div id="stageControlsBar" aria-label="Stage controls">
          <button id="raiseCurtainBelow">Raise Curtain</button>
          <button id="dropCurtainBelow">Drop Curtain</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    /*
      Utility functions — preserved API
    */
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const ease = t => t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

    function hexToRgb(hex){
      hex = hex.replace('#','');
      if(hex.length===3){ hex = hex.split('').map(c=>c+c).join(''); }
      const n = parseInt(hex,16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function rgbToHex({r,g,b}){
      const toHex = v => v.toString(16).padStart(2,'0');
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }
    function mixHex(a,b,t){
      const A=hexToRgb(a), B=hexToRgb(b);
      return rgbToHex({ r:Math.round(lerp(A.r,B.r,t)), g:Math.round(lerp(A.g,B.g,t)), b:Math.round(lerp(A.b,B.b,t)) });
    }
    function tint(hex, amount){ // amount -1..1
      const c=hexToRgb(hex);
      const t = amount>0? {r:255,g:255,b:255} : {r:0,g:0,b:0};
      const tA = Math.abs(amount);
      return rgbToHex({ r:Math.round(lerp(c.r,t.r,tA)), g:Math.round(lerp(c.g,t.g,tA)), b:Math.round(lerp(c.b,t.b,tA)) });
    }
    function multiply(hex1, hex2){
      const a=hexToRgb(hex1), b=hexToRgb(hex2);
      return rgbToHex({ r:Math.round(a.r*b.r/255), g:Math.round(a.g*b.g/255), b:Math.round(a.b*b.b/255) });
    }

    /*
      State — enhanced with manual spotlight + curtain progress
    */
    const state = {
      cosy: 0.6,
      eerie: 0.2,
      heroic: 0.4,
      mode: 'day', // 'day' (Matinée) or 'night'
      curtainOpen: false,
      curtainProgress: 0, // 0..1
      pointer: { x:0.5, y:0.5 },
      width: 1280, height: 720,

      // spotlight
      spot: {
        manual:false,
        x:0.5, y:0.6,
        resumeAt: 0
      }
    };

    /*
      Canvas setup — preserved API
    */
    const canvas = document.getElementById('stageCanvas');
    const ctx = canvas.getContext('2d');
    const stageContainer = document.getElementById('stageContainer');
    const subtitleText = document.getElementById('subtitleText');

    function resizeCanvas(){
      const ratio = window.devicePixelRatio || 1;
      state.width = canvas.clientWidth;
      state.height = canvas.clientHeight;
      canvas.width = Math.floor(state.width * ratio);
      canvas.height = Math.floor(state.height * ratio);
      ctx.setTransform(ratio,0,0,ratio,0,0);
      // Preview readiness proxy
      canvas.setAttribute('data-ready','true');
      document.getElementById('previewStatus').textContent = 'ready';
    }
    window.addEventListener('resize', resizeCanvas);

    /*
      UI elements
    */
    const cosySlider = document.getElementById('cosySlider');
    const eerieSlider = document.getElementById('eerieSlider');
    const heroicSlider = document.getElementById('heroicSlider');
    const cosyNumber = document.getElementById('cosyNumber');
    const eerieNumber = document.getElementById('eerieNumber');
    const heroicNumber = document.getElementById('heroicNumber');
    const cosyMinus = document.getElementById('cosyMinus');
    const cosyPlus = document.getElementById('cosyPlus');
    const eerieMinus = document.getElementById('eerieMinus');
    const eeriePlus = document.getElementById('eeriePlus');
    const heroicMinus = document.getElementById('heroicMinus');
    const heroicPlus = document.getElementById('heroicPlus');
    const cosyValue = document.getElementById('cosyValue');
    const eerieValue = document.getElementById('eerieValue');
    const heroicValue = document.getElementById('heroicValue');
    const modeToggle = document.getElementById('modeToggle');
    const modeLabel = document.getElementById('modeLabel');
    const resetButton = document.getElementById('resetButton');
    const dropCurtainButton = document.getElementById('dropCurtainButton');
    const curtain = document.getElementById('curtain');
    const curtainButton = document.getElementById('curtainButton');
    const applyButton = document.getElementById('applyButton');
    const applyStatus = document.getElementById('applyStatus');
    const themeStatus = document.getElementById('themeStatus');
    const curtainStatus = document.getElementById('curtainStatus');
    const previewStatus = document.getElementById('previewStatus');
    const downloadPNG = document.getElementById('downloadPNG');
    const downloadLink = document.getElementById('downloadLink');
    const downloadStatus = document.getElementById('downloadStatus');
    const spotlightManualToggle = document.getElementById('spotlightManualToggle');
    const spotlightStatus = document.getElementById('spotlightStatus');
    const spotlightIndicator = document.getElementById('spotlightIndicator');
    const raiseCurtainBelow = document.getElementById('raiseCurtainBelow');
    const dropCurtainBelow = document.getElementById('dropCurtainBelow');

    // Keep track of active slider row highlight
    const cosyRow = document.getElementById('cosyRow');
    const eerieRow = document.getElementById('eerieRow');
    const heroicRow = document.getElementById('heroicRow');
    const rows = [cosyRow, eerieRow, heroicRow];

    function setRowActive(row, active){
      rows.forEach(r=>{ if(r!==row) r.classList.remove('active'); });
      if(active){ row.classList.add('active'); }
      else{ row.classList.remove('active'); }
    }

    function reflectValueStates(){
      // Numeric readouts; add max/zero classes to show clear states
      function applyTo(valEl, v){
        valEl.textContent = Math.round(v*100) + '%';
        valEl.classList.toggle('max', v>=1);
        valEl.classList.toggle('zero', v<=0);
      }
      applyTo(cosyValue, state.cosy);
      applyTo(eerieValue, state.eerie);
      applyTo(heroicValue, state.heroic);
      // These texts are used by tests; ensure values like "60%","100%","0%" etc can appear
    }

    function markStageChanged(){
      // brief outline flash on stageContainer
      stageContainer.classList.add('changed-outline');
      setTimeout(()=>stageContainer.classList.remove('changed-outline'), 250);
    }

    /*
      Style slider tracks — preserved API signature; simplified in this theme
    */
    function paintSliderTracks(){
      // minimal: track is already black per CSS; no-op adheres to destylized spec
      // function retained to respect "keep_api"
    }
    paintSliderTracks();

    /*
      Update state from UI — preserved API
    */
    function updateFromUI(){
      state.cosy = clamp((+cosySlider.value)/100, 0, 1);
      state.eerie = clamp((+eerieSlider.value)/100, 0, 1);
      state.heroic = clamp((+heroicSlider.value)/100, 0, 1);

      cosyNumber.value = Math.round(state.cosy*100);
      eerieNumber.value = Math.round(state.eerie*100);
      heroicNumber.value = Math.round(state.heroic*100);

      reflectValueStates();

      // Update mode
      modeLabel.textContent = modeToggle.checked ? 'Night' : 'Matinée';
      modeToggle.setAttribute('aria-pressed', modeToggle.checked ? 'true' : 'false');
      state.mode = modeToggle.checked ? 'night' : 'day';
      themeStatus.textContent = 'ready';

      // Spotlight proxy
      spotlightStatus.textContent = state.spot.manual ? 'manual' : 'auto';

      // Update subtitle (typewriter queue)
      queueSubtitle(buildSubtitle());

      // Stage changed hint
      markStageChanged();

      // Snapshot download disabled until re-prepared
      downloadPNG.setAttribute('aria-disabled','true');
      downloadStatus.textContent = 'disabled';
    }

    cosySlider.addEventListener('input', ()=>{ setRowActive(cosyRow,true); updateFromUI(); });
    eerieSlider.addEventListener('input', ()=>{ setRowActive(eerieRow,true); updateFromUI(); });
    heroicSlider.addEventListener('input', ()=>{ setRowActive(heroicRow,true); updateFromUI(); });

    cosySlider.addEventListener('change', ()=> setRowActive(cosyRow,false));
    eerieSlider.addEventListener('change', ()=> setRowActive(eerieRow,false));
    heroicSlider.addEventListener('change', ()=> setRowActive(heroicRow,false));

    // Number inputs kept in sync
    function clampInt(v){ v = Math.round(+v||0); return Math.max(0, Math.min(100, v)); }
    cosyNumber.addEventListener('input', ()=>{ cosySlider.value = clampInt(cosyNumber.value); updateFromUI(); });
    eerieNumber.addEventListener('input', ()=>{ eerieSlider.value = clampInt(eerieNumber.value); updateFromUI(); });
    heroicNumber.addEventListener('input', ()=>{ heroicSlider.value = clampInt(heroicNumber.value); updateFromUI(); });

    // +/- steppers
    function step(id, delta){
      const map = {
        cosy: [cosySlider, cosyNumber, cosyRow],
        eerie:[eerieSlider, eerieNumber, eerieRow],
        heroic:[heroicSlider, heroicNumber, heroicRow]
      };
      const [rng, num, row] = map[id];
      const cur = clampInt(rng.value) + delta;
      rng.value = clampInt(cur);
      num.value = clampInt(cur);
      setRowActive(row, true);
      updateFromUI();
      setTimeout(()=>setRowActive(row,false), 200);
    }
    cosyMinus.addEventListener('click', ()=>step('cosy', -1));
    cosyPlus.addEventListener('click', ()=>step('cosy', +1));
    eerieMinus.addEventListener('click', ()=>step('eerie', -1));
    eeriePlus.addEventListener('click', ()=>step('eerie', +1));
    heroicMinus.addEventListener('click', ()=>step('heroic', -1));
    heroicPlus.addEventListener('click', ()=>step('heroic', +1));

    // Toggle Night/Matinée
    modeToggle.addEventListener('change', ()=>{
      themeStatus.textContent = 'ready';
      updateFromUI();
    });

    // Apply
    applyButton.addEventListener('click', ()=>{
      applyStatus.textContent = 'done';
      document.body.setAttribute('data-applied','true');
      // Also update subtitle for confirmation
      queueSubtitle(buildSubtitle());
    });

    // Reset
    resetButton.addEventListener('click', ()=>{
      cosySlider.value = 60;
      eerieSlider.value = 20;
      heroicSlider.value = 40;
      cosyNumber.value = 60;
      eerieNumber.value = 20;
      heroicNumber.value = 40;
      modeToggle.checked = false;
      updateFromUI();
      applyStatus.textContent = 'idle';
      queueSubtitle("Curtain falls... ready for the next cue.");
    });

    // Curtain controls (panel button)
    dropCurtainButton.addEventListener('click', ()=>{
      stageDropCurtain();
    });
    // Curtain controls (stage bottom bar duplicates)
    raiseCurtainBelow.addEventListener('click', ()=>stageRaiseCurtain());
    dropCurtainBelow.addEventListener('click', ()=>stageDropCurtain());

    curtainButton.addEventListener('click', ()=>{
      stageRaiseCurtain();
    });

    // Spotlight manual toggle
    spotlightManualToggle.addEventListener('change', ()=>{
      state.spot.manual = spotlightManualToggle.checked;
      spotlightStatus.textContent = state.spot.manual ? 'manual' : 'auto';
      if(!state.spot.manual){
        // allow resume after now
        state.spot.resumeAt = 0;
      }
    });

    /*
      Curtain — partial drag support + snap, plus preserved functions
    */
    function setCurtainProgress(p){
      state.curtainProgress = clamp(p, 0, 1);
      const left = curtain.querySelector('.curtain-half.left');
      const right = curtain.querySelector('.curtain-half.right');
      const perc = state.curtainProgress;
      left.style.transform = `translateX(${-102*perc}%)`;
      right.style.transform = `translateX(${102*perc}%)`;
      // hidden pointer pass-through only when fully open
      if(perc>=0.999){
        curtain.classList.add('hidden');
        state.curtainOpen = true;
        curtain.setAttribute('data-open','true');
        curtainStatus.textContent = 'open';
      } else {
        curtain.classList.remove('hidden');
        state.curtainOpen = false;
        curtain.setAttribute('data-open','false');
        curtainStatus.textContent = perc<=0.001 ? 'closed' : Math.round(perc*100) + '% open';
      }
    }

    function animateCurtain(to, ms=500){
      const from = state.curtainProgress;
      const t0 = performance.now();
      function step(now){
        const t = clamp((now - t0)/ms, 0, 1);
        const v = lerp(from, to, ease(t));
        setCurtainProgress(v);
        if(t<1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    function stageRaiseCurtain(){
      // preserved signature; enhanced
      curtain.classList.add('curtain-open'); // compatibility
      animateCurtain(1, 450);
      queueSubtitle(buildSubtitle());
      // Enable PNG download after scene change prepared
      prepareDownload();
    }

    function stageDropCurtain(){
      curtain.classList.remove('curtain-open'); // compatibility
      animateCurtain(0, 450);
      queueSubtitle("Curtain falls... ready for the next cue.");
    }

    // Drag logic for curtain
    let curtainDrag = null;
    curtain.addEventListener('pointerdown', (e)=>{
      const rect = curtain.getBoundingClientRect();
      curtainDrag = {
        startX: e.clientX,
        startProgress: state.curtainProgress,
        rect
      };
      curtain.setPointerCapture(e.pointerId);
    });
    curtain.addEventListener('pointermove', (e)=>{
      if(!curtainDrag) return;
      const dx = e.clientX - curtainDrag.startX;
      const total = curtainDrag.rect.width;
      const delta = dx / (total*0.9); // generous mapping
      const newP = clamp(curtainDrag.startProgress + delta, 0, 1);
      setCurtainProgress(newP);
    });
    curtain.addEventListener('pointerup', (e)=>{
      if(!curtainDrag) return;
      // Snap
      const target = state.curtainProgress > 0.5 ? 1 : 0;
      animateCurtain(target, 300);
      curtain.releasePointerCapture(e.pointerId);
      curtainDrag = null;
    });
    curtain.addEventListener('pointercancel', ()=>{ curtainDrag=null; });

    /*
      Parallax pointer (preserved event)
    */
    stageContainer.addEventListener('pointermove', (e)=>{
      const rect = stageContainer.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      state.pointer.x = clamp(x, 0, 1);
      state.pointer.y = clamp(y, 0, 1);

      // Manual spotlight steering if dragging while curtain open
      if(state.curtainProgress>=0.999){
        if(e.buttons & 1){ // primary button
          state.spot.manual = true;
          spotlightManualToggle.checked = true;
          spotlightStatus.textContent = 'manual';
          state.spot.x = state.pointer.x;
          state.spot.y = state.pointer.y;
          setSpotlightIndicator(state.spot.x, state.spot.y, true);
        } else if(!spotlightManualToggle.checked) {
          // Not holding manual; set grace period to auto resume soon
          state.spot.manual = false;
          state.spot.resumeAt = performance.now() + 2000;
          spotlightManualToggle.checked = false;
          spotlightStatus.textContent = 'auto';
          setSpotlightIndicator(state.spot.x, state.spot.y, false);
        } else {
          setSpotlightIndicator(state.spot.x, state.spot.y, true);
        }
      }
    });

    // Keyboard spotlight on stage
    stageContainer.addEventListener('keydown', (e)=>{
      let moved=false;
      const step = (e.shiftKey? 0.05 : 0.02);
      if(e.key==='ArrowLeft'){ state.spot.x = clamp(state.spot.x - step, 0, 1); moved=true; }
      if(e.key==='ArrowRight'){ state.spot.x = clamp(state.spot.x + step, 0, 1); moved=true; }
      if(e.key==='ArrowUp'){ state.spot.y = clamp(state.spot.y - step, 0, 1); moved=true; }
      if(e.key==='ArrowDown'){ state.spot.y = clamp(state.spot.y + step, 0, 1); moved=true; }
      if(moved){
        e.preventDefault();
        state.spot.manual = true;
        spotlightManualToggle.checked = true;
        spotlightStatus.textContent = 'manual';
        setSpotlightIndicator(state.spot.x, state.spot.y, true);
      }
    });

    function setSpotlightIndicator(nx, ny, visible){
      const w = state.width, h = state.height;
      const x = nx * w;
      const y = ny * h;
      spotlightIndicator.style.left = x + 'px';
      spotlightIndicator.style.top = y + 'px';
      spotlightIndicator.setAttribute('data-visible', visible ? 'true' : 'false');
    }

    /*
      Typewriter subtitle — preserved API name queueSubtitle
    */
    let twInterval = null;
    function queueSubtitle(text){
      if(twInterval) clearInterval(twInterval);
      subtitleText.textContent = '';
      let i = 0;
      const speedBase = 20;
      twInterval = setInterval(()=>{
        if(i < text.length){
          subtitleText.textContent += text[i];
          i++;
        } else {
          clearInterval(twInterval); twInterval = null;
        }
      }, speedBase);
    }

    function dominantMood(){
      const m = [
        {k:'cosy', v:state.cosy},
        {k:'eerie', v:state.eerie},
        {k:'heroic', v:state.heroic},
      ].sort((a,b)=>b.v-a.v)[0].k;
      return m;
    }

    function buildSubtitle(){
      const timeWord = state.mode==='day' ? 'Matinée' : 'Night';
      let vibe = '';
      const mood = dominantMood();
      if(mood==='cosy') vibe = 'warm lamplight and velvety fog';
      if(mood==='eerie') vibe = 'teal hush and drifting mist';
      if(mood==='heroic') vibe = 'bold contrast and golden edges';
      return `${timeWord} performance: Mostly cloudy with a light breeze; sun breaks possible; a brief drizzle by evening. Staged with ${vibe}.`;
    }

    /*
      Theme computation — preserved API name computeTheme
      (unchanged logic from original with small constants adjusted by state)
    */
    function computeTheme(){
      const { cosy, eerie, heroic, mode } = state;
      const daySkyTop = '#8ec5ff', daySkyBottom='#e9f7ff';
      const nightSkyTop='#0b1026', nightSkyBottom='#1a2340';

      const skyTop = (mode==='day') ? daySkyTop : nightSkyTop;
      const skyBottom = (mode==='day') ? daySkyBottom : nightSkyBottom;

      const cosyWarm = '#ffd8b1';
      const eerieTeal = '#81e6d9';
      const heroicBlue = '#3a66ff';

      const skyTopMood = mixHex(skyTop, cosyWarm, cosy*0.35);
      const skyTopMood2 = mixHex(skyTopMood, eerieTeal, eerie*0.25);
      const skyTopFinal = mixHex(skyTopMood2, heroicBlue, heroic*0.15);

      const skyBottomMood = mixHex(skyBottom, cosyWarm, cosy*0.45);
      const skyBottomMood2 = mixHex(skyBottomMood, eerieTeal, eerie*0.22);
      const skyBottomFinal = mixHex(skyBottomMood2, heroicBlue, heroic*0.10);

      const cloudBaseDay = '#ffffff';
      const cloudBaseNight = '#cfd8ff';
      let cloudColor = (mode==='day') ? cloudBaseDay : cloudBaseNight;
      cloudColor = mixHex(cloudColor, '#ffecd2', cosy*0.4);
      cloudColor = mixHex(cloudColor, '#b1fff1', eerie*0.35);
      cloudColor = tint(cloudColor, -heroic*0.15);

      const farMountainDay = '#6c8bb3';
      const farMountainNight = '#2a3a59';
      const farMount = (mode==='day')? farMountainDay: farMountainNight;
      const farMountFinal = tint(mixHex(farMount, '#ffd6a3', cosy*0.15), -heroic*0.12);

      const nearMountainDay = '#3f5f86';
      const nearMountainNight = '#1a2a46';
      const nearMount = (mode==='day')? nearMountainDay: nearMountainNight;
      const nearMountFinal = tint(mixHex(nearMount, '#1ed0b0', eerie*0.15), -heroic*0.05);

      const groundDay = '#2a3b4f';
      const groundNight = '#0f1829';
      const ground = (mode==='day')? groundDay : groundNight;
      const groundFinal = mixHex(ground, '#f7c14a', heroic*0.08);

      const accentGold = '#f7c14a';
      const accentTeal = '#52e0c4';
      const accent = mixHex(accentGold, accentTeal, eerie*0.5);
      const spotlightColor = mixHex(accent, '#ffffff', cosy*0.25);

      const fogDensity = clamp(0.08 + cosy*0.25 + eerie*0.22 + (mode==='night'?0.06:0), 0, 0.6);
      const hazeColor = mixHex('#cfe9ff', '#71f1d7', eerie*0.5);

      let rain = 0;
      const base = (mode==='night'? 0.15 : 0.05);
      rain = clamp(base + eerie*0.35 + heroic*0.08 - cosy*0.08, 0, 0.55);

      const wind = 0.2 + heroic*0.2 + eerie*0.05;

      const spotRadius = lerp(160, 300, heroic*0.7) * (Math.min(state.width, state.height)/720);
      const spotSpeed = 0.4 + heroic*0.6 - cosy*0.2 + eerie*0.05;
      const darkness = (mode==='night' ? 0.45 + eerie*0.1 - cosy*0.1 : 0.18 - cosy*0.05 + eerie*0.05);
      const vignette = 0.24 + heroic*0.08;

      const stars = (mode==='night') ? Math.round(100 + heroic*40 + eerie*60) : 0;

      return {
        skyTop: skyTopFinal,
        skyBottom: skyBottomFinal,
        cloudColor,
        farMount: farMountFinal,
        nearMount: nearMountFinal,
        ground: groundFinal,
        fogDensity,
        hazeColor,
        rainIntensity: rain,
        wind,
        accent,
        spotlightColor,
        spotRadius,
        spotSpeed,
        darkness: clamp(darkness, 0, 0.75),
        vignette: clamp(vignette, 0.1, 0.6),
        stars
      };
    }

    /*
      Scene objects — preserved APIs
    */
    const clouds = [];
    const raindrops = [];
    const stars = [];

    function initStars(count){
      stars.length = 0;
      for(let i=0;i<count;i++){
        stars.push({
          x: Math.random(),
          y: Math.random()*0.6,
          s: Math.random()*1.2+0.2,
          tw: Math.random()*Math.PI*2
        });
      }
    }

    function initClouds(){
      clouds.length = 0;
      const layers = [
        { n: 6, y: 0.22, scale: 0.7, parallax: 0.15, speed: 0.02 },
        { n: 5, y: 0.35, scale: 0.95, parallax: 0.25, speed: 0.035 },
        { n: 4, y: 0.48, scale: 1.25, parallax: 0.35, speed: 0.05 },
      ];
      layers.forEach((L, li)=>{
        for(let i=0;i<L.n;i++){
          clouds.push({
            x: Math.random(),
            y: L.y + (Math.random()-0.5)*0.06,
            s: L.scale * (0.75 + Math.random()*0.6),
            p: L.parallax,
            v: L.speed * (0.7 + Math.random()*0.6) * (Math.random()<0.5 ? 1 : 0.85),
            seed: Math.random()*1000 + li*100,
            layer: li
          });
        }
      });
    }

    function spawnRaindrop(theme){
      if(raindrops.length > 600) return;
      const width = state.width, height = state.height;
      raindrops.push({
        x: Math.random()*width,
        y: -20,
        vy: lerp(220, 380, theme.rainIntensity) * (0.8 + Math.random()*0.4),
        len: lerp(8, 16, theme.rainIntensity) * (0.8 + Math.random()*0.4),
        alpha: 0.25 + Math.random()*0.25
      });
    }

    /*
      Drawing helpers — preserved APIs
    */
    function drawSky(theme){
      const { width:w, height:h } = state;
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0, theme.skyTop);
      g.addColorStop(1, theme.skyBottom);
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawStars(theme, t){
      if(theme.stars<=0) return;
      const w=state.width, h=state.height;
      for(let i=0;i<stars.length;i++){
        const s = stars[i];
        const px = s.x*w;
        const py = s.y*h;
        const tw = (Math.sin(t*0.002 + s.tw) + 1)/2; // 0..1
        const a = 0.25 + tw*0.55;
        ctx.globalAlpha = a;
        ctx.fillStyle = '#cfe7ff';
        ctx.fillRect(px, py, s.s, s.s);
      }
      ctx.globalAlpha = 1;
    }

    function drawMountains(theme){
      const { width:w, height:h } = state;
      const px = (state.pointer.x - 0.5);
      const parallaxFar = px * 30;
      const parallaxNear = px * 60;

      // Far ridge
      ctx.fillStyle = theme.farMount;
      ctx.beginPath();
      ctx.moveTo(0, h*0.58 + 10);
      for(let x=0; x<=w; x+=20){
        const y = h*0.58 + Math.sin(x*0.003 + 0.5)*20 + Math.sin(x*0.007)*12;
        ctx.lineTo(x + parallaxFar, y);
      }
      ctx.lineTo(w+parallaxFar, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      // Near ridge
      ctx.fillStyle = theme.nearMount;
      ctx.beginPath();
      ctx.moveTo(0, h*0.7 + 20);
      for(let x=0; x<=w; x+=16){
        const y = h*0.7 + Math.sin(x*0.004+1.2)*28 + Math.sin(x*0.01+2)*14;
        ctx.lineTo(x + parallaxNear, y);
      }
      ctx.lineTo(w+parallaxNear, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();
    }

    function drawCloud(ctx, x, y, s, color, alpha){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      const r = 26*s;
      ctx.arc(x, y, r*0.9, 0, Math.PI*2);
      ctx.arc(x+ r*0.9, y+ r*0.1, r*0.8, 0, Math.PI*2);
      ctx.arc(x- r*0.8, y+ r*0.2, r*0.7, 0, Math.PI*2);
      ctx.arc(x+ r*0.2, y- r*0.5, r*0.7, 0, Math.PI*2);
      ctx.arc(x- r*0.2, y- r*0.4, r*0.6, 0, Math.PI*2);
      ctx.closePath();
      ctx.fill();

      const g = ctx.createLinearGradient(x, y, x, y+r*1.2);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.08)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(x, y+r*0.4, r*1.6, r*0.9, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function drawClouds(theme, dt){
      const w=state.width, h=state.height;
      const pointerX = (state.pointer.x-0.5);
      for(let c of clouds){
        c.x += (c.v + theme.wind*(0.5+c.layer*0.5)) * dt / w;
        if(c.x > 1.2) c.x = -0.2;
        const px = c.x*w + pointerX* (40 * c.p);
        const py = c.y*h + (state.pointer.y-0.5)* (10 * c.p);
        const alpha = 0.75 - c.layer*0.2;
        drawCloud(ctx, px, py, c.s, theme.cloudColor, alpha);
      }
    }

    function drawSunOrMoon(theme, t){
      const w=state.width, h=state.height;
      const px = state.pointer.x-0.5;
      const x = lerp(w*0.15, w*0.85, 0.5 + Math.sin(t*0.00015)*0.5) + px*20;
      const y = h*0.18 + Math.cos(t*0.0002)*8;
      if(state.mode==='day'){
        const g = ctx.createRadialGradient(x,y, 0, x,y, 110);
        g.addColorStop(0, 'rgba(255,230,160,0.9)');
        g.addColorStop(0.3, 'rgba(255,210,120,0.5)');
        g.addColorStop(1, 'rgba(255,210,120,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(x,y, 110, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = '#ffe59e';
        ctx.beginPath(); ctx.arc(x,y, 28, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle = '#fff6cc';
        ctx.beginPath(); ctx.arc(x,y, 20, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath(); ctx.arc(x+7,y-4, 18, 0, Math.PI*2); ctx.fill();
      }
    }

    function drawForeground(theme){
      const w=state.width, h=state.height;
      const px = state.pointer.x-0.5;
      const offset = px * 90;

      ctx.fillStyle = theme.ground;
      ctx.fillRect(0, h*0.86, w, h*0.14);

      ctx.save();
      ctx.translate(offset,0);
      ctx.fillStyle = tint(theme.ground, -0.22);
      for(let i=0
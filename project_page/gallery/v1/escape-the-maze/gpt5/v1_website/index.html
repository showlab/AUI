<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Escape the Maze</title>
<style>
  /* Destylized, high-contrast, minimal UI */
  :root{
    --bg: #ffffff;
    --panel: #ffffff;
    --text: #000000;
    --muted: #333333;
    --accent: #005fcc;
    --accent-2: #cc3300;
    --ok: #007a3d;
    --warn: #b30000;
    --line: #000000;
    --start-fill: #ffe8a3;
    --finish-fill: #b7f0d6;
    --focus: #ffcc00;
  }
  * { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
  a { color: var(--accent); text-decoration: underline; }
  button, select { font-size: 16px; }
  header {
    border-bottom: 1px solid #000;
    padding: 12px 16px;
  }
  header h1 { margin: 0; font-size: 20px; font-weight: 800; }
  main {
    display: grid;
    grid-template-columns: 360px 1fr;
    gap: 12px;
    padding: 12px;
    max-width: 1400px;
    margin: 0 auto;
  }
  /* Left panel */
  aside#hud {
    background: var(--panel);
    border: 1px solid #000;
    padding: 12px;
    display: grid;
    grid-template-rows: auto auto auto auto auto auto 1fr auto;
    gap: 12px;
    align-self: start;
  }
  .section-title { margin: 0; font-weight: 800; font-size: 16px; }
  .hint, .small { color: var(--muted); font-size: 14px; margin: 0; }
  .stat-grid {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 6px 8px;
    align-items: baseline;
    border: 1px solid #000;
    padding: 8px;
  }
  .label { color: var(--muted); }
  .value { font-weight: 800; }
  .row {
    display: flex; gap: 12px; align-items: center;
  }
  #statusMessage {
    border: 1px dashed #000;
    padding: 8px;
    min-height: 48px;
    font-size: 14px;
    color: var(--muted);
  }
  #btnReplay {
    min-height: 44px;
    min-width: 44px;
    border: 1px solid #000;
    background: #f2f2f2;
    color: var(--text);
    padding: 8px 12px;
    font-weight: 800;
    cursor: pointer;
  }
  #btnReplay[data-emphasis="true"] {
    outline: 2px solid var(--accent);
  }
  #btnReplay[aria-disabled="true"] {
    opacity: 0.5; cursor: default;
  }
  /* Right panel Game area */
  section#gameArea {
    border: 1px solid #000;
    background: #fff;
    display: grid;
    grid-template-rows: auto auto 1fr auto;
    gap: 8px;
    padding: 8px;
    position: relative;
    min-height: 600px;
  }
  /* Inline HUD above canvas to keep counters close to gameplay */
  #inlineHUD {
    display: grid;
    grid-template-columns: repeat(5, auto);
    gap: 12px;
    align-items: center;
    border-bottom: 1px solid #000;
    padding-bottom: 8px;
  }
  #inlineHUD .pill {
    border: 1px solid #000; padding: 6px 8px;
    min-height: 32px; display: inline-flex; align-items: center; gap: 6px;
  }
  #keyboardHint { font-size: 14px; }
  #timerIndicator { font-weight: 800; }
  #difficultyIndicator { font-weight: 800; }
  /* Focus hint and banners */
  #focusHint {
    font-size: 14px;
    border: 1px solid #000;
    padding: 6px 8px;
    display: none;
    background: #fff7cc;
  }
  #focusHint[data-visible="true"] { display: block; }
  #winBanner, #lossBanner {
    display: none;
    border: 1px solid #000;
    padding: 8px;
    font-weight: 800;
  }
  #winBanner[data-visible="true"] { display: block; background: #d9ffe8; }
  #lossBanner[data-visible="true"] { display: block; background: #ffe0e0; }
  /* Canvas */
  #canvasWrap {
    position: relative; display: grid; place-items: center; min-height: 360px;
    border: 1px solid #000; padding: 8px;
  }
  #mazeCanvas {
    display: block; background: #ffffff; outline: none; border: 2px solid #000;
  }
  #mazeCanvas:focus { border-color: var(--focus); }
  #mazeCanvas[data-needs-focus="true"] { border-color: var(--warn); }
  #mazeCanvas[data-finished="true"] { border-color: var(--ok); }
  /* Loading overlay */
  #mazeLoading {
    position: absolute; inset: 8px; display: none; background: rgba(255,255,255,0.9);
    border: 1px solid #000;
    align-items: center; justify-content: center; text-align: center; padding: 12px;
  }
  #mazeLoading[data-visible="true"] { display: flex; }
  /* Win overlay */
  #winOverlay {
    position: absolute; inset: 8px; display: none; align-items: center; justify-content: center;
    border: 1px solid #000; background: rgba(255,255,255,0.95); text-align: center; padding: 12px;
  }
  #winOverlay[data-visible="true"] { display: flex; }
  /* Transient overlay message */
  #transientMessage {
    position: absolute; top: 12px; right: 12px;
    background: #fff; border: 1px solid #000; padding: 6px 8px; font-size: 14px; display: none;
  }
  #transientMessage[data-visible="true"] { display: block; }
  /* Shake effect on collision */
  @keyframes shake {
    0% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    50% { transform: translateX(4px); }
    75% { transform: translateX(-4px); }
    100% { transform: translateX(0); }
  }
  .shake { animation: shake 0.18s linear 1; }
  /* Controls under canvas */
  #underCanvasControls {
    display: grid; grid-auto-flow: column; gap: 8px; align-items: center; justify-content: start;
    border-top: 1px solid #000; padding-top: 8px;
  }
  /* Mirrors */
  .mirror { font-weight: 800; }
  /* Responsive */
  @media (max-width: 960px) {
    main { grid-template-columns: 1fr; }
    #inlineHUD { grid-template-columns: repeat(3, auto); row-gap: 6px; }
  }
  /* Visible proxy/status rows */
  #proxyPanel { border: 1px solid #000; padding: 8px; }
  #proxyPanel .proxy-row { display: grid; grid-template-columns: 1fr auto; gap: 4px 8px; }
  /* Footer */
  footer { border-top: 1px solid #000; padding: 8px 12px; color: var(--muted); font-size: 14px; }
</style>
</head>
<body>
<header>
  <h1>Escape the Maze</h1>
</header>

<main>
  <aside id="hud" aria-label="Game Controls and Status">
    <div>
      <p class="section-title">Objective</p>
      <p class="hint" id="objectiveText">
        Navigate from the start to the finish using the arrow keys. Reach the goal in the minimum number of steps to earn the shortest path bonus. Bonus only if your moves equal the shortest path.
      </p>
    </div>

    <div class="stat-grid" role="status" aria-live="polite" id="statusPanel">
      <span class="label">Timer</span>
      <span id="timerValue" class="value">00:00.00</span>

      <span class="label">Moves</span>
      <span id="movesValue" class="value">0</span>

      <span class="label">Shortest Path</span>
      <span id="shortestPathValue" class="value">—</span>

      <span class="label">Best Time</span>
      <span id="bestTimeValue" class="value">—</span>

      <span class="label">Game</span>
      <span id="gameStateLabel" class="value">Ready</span>
    </div>

    <div class="row">
      <label class="label" for="difficultySelect">Difficulty</label>
      <select id="difficultySelect" aria-label="Select difficulty">
        <option value="easy">Easy (15×15)</option>
        <option value="medium" selected>Medium (25×25)</option>
        <option value="hard">Hard (35×35)</option>
      </select>
      <button id="btnApplyDifficulty" type="button" title="Apply Difficulty">Apply</button>
    </div>
    <div id="statusMessage" aria-live="polite">Use arrow keys to move. Press or click Play Again to generate a new maze.</div>

    <button id="btnReplay" type="button" aria-label="Play again (generate a new maze)">Play Again</button>
    <p class="hint" id="keyboardHelp"><strong>Keyboard:</strong> Arrow keys to move. R to replay. Click the maze to focus if keys don't respond.</p>

    <div>
      <p class="section-title">Controls</p>
      <ul class="hint" style="margin:0 0 0 18px;">
        <li>Arrow keys to move (diagonal movement is not supported; one tile per step)</li>
        <li>R to replay</li>
        <li>Timer starts on your first move</li>
        <li>The finish cell is marked clearly; aim for the shortest path</li>
      </ul>
    </div>

    <div id="proxyPanel" aria-label="State Proxies for Automation">
      <p class="section-title">State Proxies</p>
      <div class="proxy-row"><span>Maze readiness:</span><span id="mazeReadyStatus">unknown</span></div>
      <div class="proxy-row"><span>Timer status:</span><span id="timerStatus">stopped</span></div>
      <div class="proxy-row"><span>Win status:</span><span id="winStatus">none</span></div>
      <div class="proxy-row"><span>Bonus status:</span><span id="bonusStatus">not evaluated</span></div>
      <div class="proxy-row"><span>Apply difficulty:</span><span id="applyStatus">idle</span></div>
      <div class="proxy-row"><span>Preview (canvas) status:</span><span id="previewStatus">not ready</span></div>
      <div class="proxy-row"><span>Difficulty indicator:</span><span id="difficultyIndicator">Medium</span></div>
    </div>
  </aside>

  <section id="gameArea" aria-label="Game Area">
    <!-- Inline HUD close to the game -->
    <div id="inlineHUD" aria-live="polite">
      <div class="pill" title="Timer"><span>Timer:</span> <span id="inlineTimerValue" class="mirror">00:00.00</span> <span id="timerIndicator">(stopped)</span></div>
      <div class="pill" title="Moves"><span>Moves:</span> <span id="inlineMovesValue" class="mirror">0</span></div>
      <div class="pill" title="Shortest path"><span>Shortest:</span> <span id="inlineShortestValue" class="mirror">—</span></div>
      <div class="pill" id="bonusIndicator" title="Bonus indicator" data-visible="false"><span>Bonus:</span> <span id="bonusIndicatorLabel">Not achieved</span></div>
      <div id="keyboardHint" class="hint">Press R to replay</div>
    </div>

    <div id="focusHint" role="status" aria-live="polite" data-visible="false">Keyboard input inactive. Click the maze to focus if keys don't respond.</div>
    <div id="winBanner" data-visible="false">You escaped! Congratulations.</div>
    <div id="lossBanner" data-visible="false">No loss state in this game. Try again if you want a better time.</div>

    <div id="canvasWrap">
      <canvas id="mazeCanvas" width="720" height="720" tabindex="0" aria-label="Maze canvas. Use arrow keys to move the avatar." data-ready="false" data-finished="false" data-needs-focus="false"></canvas>
      <div id="mazeLoading" data-visible="true" aria-live="polite">Generating maze… Please wait.</div>
      <div id="transientMessage" role="status" aria-live="polite" data-visible="false">Message</div>
      <div id="winOverlay" data-visible="false">
        <div>
          <p style="font-weight:800; margin:0 0 8px;">You escaped!</p>
          <p id="finalStats" style="margin:0 0 8px;">Time — Moves —</p>
          <p id="bonusLine" style="margin:0 0 8px;">Bonus status: —</p>
          <button id="btnPlayAgainOverlay" type="button" style="min-height:44px; min-width:44px; border:1px solid #000; background:#f2f2f2;">Play Again</button>
        </div>
      </div>
    </div>

    <div id="underCanvasControls">
      <button id="btnReplay2" type="button" aria-label="Play again secondary">Play Again</button>
      <span class="hint">Press R to replay</span>
    </div>
  </section>
</main>

<footer>
  Built with HTML5 canvas and vanilla JavaScript. No external libraries.
</footer>

<script>
(function(){
  "use strict";

  // DOM elements
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  const btnReplay = document.getElementById('btnReplay');
  const btnReplay2 = document.getElementById('btnReplay2');
  const btnPlayAgainOverlay = document.getElementById('btnPlayAgainOverlay');
  const timerEl = document.getElementById('timerValue');
  const movesEl = document.getElementById('movesValue');
  const shortestEl = document.getElementById('shortestPathValue');
  const statusEl = document.getElementById('statusMessage');
  const inlineTimerEl = document.getElementById('inlineTimerValue');
  const inlineMovesEl = document.getElementById('inlineMovesValue');
  const inlineShortestEl = document.getElementById('inlineShortestValue');
  const timerIndicatorEl = document.getElementById('timerIndicator');
  const difficultySelect = document.getElementById('difficultySelect');
  const applyDifficultyBtn = document.getElementById('btnApplyDifficulty');
  const difficultyIndicatorEl = document.getElementById('difficultyIndicator');
  const gameStateLabel = document.getElementById('gameStateLabel');
  const mazeLoading = document.getElementById('mazeLoading');
  const winOverlay = document.getElementById('winOverlay');
  const winBanner = document.getElementById('winBanner');
  const lossBanner = document.getElementById('lossBanner');
  const transientMessage = document.getElementById('transientMessage');
  const bonusIndicator = document.getElementById('bonusIndicator');
  const bonusIndicatorLabel = document.getElementById('bonusIndicatorLabel');
  const focusHint = document.getElementById('focusHint');
  const bestTimeEl = document.getElementById('bestTimeValue');

  // Visible proxies for automation
  const mazeReadyStatus = document.getElementById('mazeReadyStatus');
  const timerStatus = document.getElementById('timerStatus');
  const winStatus = document.getElementById('winStatus');
  const bonusStatus = document.getElementById('bonusStatus');
  const applyStatus = document.getElementById('applyStatus');
  const previewStatus = document.getElementById('previewStatus');

  // Game state
  let cols = 25;
  let rows = 25;
  let grid = [];
  let cellSize = 24;
  let wallWidth = 2;
  let start = {x: 0, y: 0};
  let goal = {x: 0, y: 0};
  let player = {x: 0, y: 0};
  let moves = 0;
  let shortestSteps = 0;
  let running = false;
  let finished = false;
  let ready = false;
  let difficulty = 'medium'; // easy, medium, hard

  // Timer state
  let timerInterval = null;
  let timeStart = 0;
  let elapsed = 0;

  // Persisted bests
  function getBestKey() {
    return 'escapeMazeBest_' + difficulty;
  }
  function loadBest() {
    try {
      const raw = localStorage.getItem(getBestKey());
      if (!raw) return null;
      return JSON.parse(raw);
    } catch(e) { return null; }
  }
  function saveBest(ms, mv) {
    const prev = loadBest();
    if (!prev || ms < prev.timeMs) {
      const data = { timeMs: ms, moves: mv, at: Date.now() };
      localStorage.setItem(getBestKey(), JSON.stringify(data));
    }
  }
  function showBest() {
    const b = loadBest();
    if (!b) {
      bestTimeEl.textContent = '—';
    } else {
      bestTimeEl.textContent = formatTime(b.timeMs) + ' / ' + b.moves + ' moves';
    }
  }

  function formatTime(ms) {
    const totalSec = ms / 1000;
    const m = Math.floor(totalSec / 60);
    const s = Math.floor(totalSec % 60);
    const cs = Math.floor((ms % 1000) / 10);
    const mm = String(m).padStart(2, '0');
    const ss = String(s).padStart(2, '0');
    const cc = String(cs).padStart(2, '0');
    return `${mm}:${ss}.${cc}`;
  }

  function startTimer() {
    if (timerInterval) return;
    timeStart = performance.now() - elapsed;
    timerInterval = setInterval(() => {
      elapsed = performance.now() - timeStart;
      timerEl.textContent = formatTime(elapsed);
      inlineTimerEl.textContent = timerEl.textContent;
    }, 50);
    timerStatus.textContent = 'running';
    canvas.setAttribute('data-finished', 'false');
    timerIndicatorEl.textContent = '(running)';
    updateGameStateLabel();
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    timerStatus.textContent = 'stopped';
    timerIndicatorEl.textContent = '(stopped)';
    updateGameStateLabel();
  }

  function resetTimer() {
    stopTimer();
    elapsed = 0;
    timerEl.textContent = "00:00.00";
    inlineTimerEl.textContent = "00:00.00";
    timerStatus.textContent = 'stopped';
    timerIndicatorEl.textContent = '(stopped)';
  }

  class Cell {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      // walls: top, right, bottom, left
      this.walls = [true, true, true, true];
      this.visited = false;
    }
    index() {
      return this.x + this.y * cols;
    }
  }

  function indexFromXY(x, y) {
    if (x < 0 || x >= cols || y < 0 || y >= rows) return -1;
    return x + y * cols;
  }

  function createGrid() {
    grid = [];
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        grid.push(new Cell(x, y));
      }
    }
  }

  function neighborsUnvisited(cell) {
    const arr = [];
    const {x, y} = cell;
    const dirs = [
      {dx: 0, dy: -1, dir: 0}, // top
      {dx: 1, dy: 0, dir: 1},  // right
      {dx: 0, dy: 1, dir: 2},  // bottom
      {dx: -1, dy: 0, dir: 3}  // left
    ];
    for (const d of dirs) {
      const nx = x + d.dx, ny = y + d.dy;
      const idx = indexFromXY(nx, ny);
      if (idx !== -1 && !grid[idx].visited) {
        arr.push({cell: grid[idx], dir: d.dir});
      }
    }
    return arr;
  }

  function removeWall(a, b, dir) {
    a.walls[dir] = false;
    const opposite = (dir + 2) % 4;
    b.walls[opposite] = false;
  }

  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  function generateMaze() {
    createGrid();
    const stack = [];
    const startCell = grid[0];
    startCell.visited = true;
    stack.push(startCell);

    while (stack.length) {
      const current = stack[stack.length - 1];
      const options = neighborsUnvisited(current);
      if (options.length > 0) {
        const choice = options[(Math.random() * options.length) | 0];
        const dir = choice.dir;
        const next = choice.cell;
        removeWall(current, next, dir);
        next.visited = true;
        stack.push(next);
      } else {
        stack.pop();
      }
    }

    start = {x: 0, y: 0};
    goal = {x: cols - 1, y: rows - 1};
  }

  function computeShortestPathSteps() {
    // BFS on carved maze
    const startIdx = indexFromXY(start.x, start.y);
    const goalIdx = indexFromXY(goal.x, goal.y);
    const dist = new Array(grid.length).fill(Infinity);
    const q = [];
    dist[startIdx] = 0;
    q.push(startIdx);

    while (q.length > 0) {
      const idx = q.shift();
      if (idx === goalIdx) break;
      const cell = grid[idx];
      const {x, y} = cell;

      const trans = [
        {dx: 0, dy: -1, wall: 0},
        {dx: 1, dy: 0, wall: 1},
        {dx: 0, dy: 1, wall: 2},
        {dx: -1, dy: 0, wall: 3},
      ];
      for (const t of trans) {
        if (!cell.walls[t.wall]) {
          const nx = x + t.dx, ny = y + t.dy;
          const nIdx = indexFromXY(nx, ny);
          if (nIdx !== -1 && dist[nIdx] === Infinity) {
            dist[nIdx] = dist[idx] + 1;
            q.push(nIdx);
          }
        }
      }
    }
    return dist[goalIdx] === Infinity ? 0 : dist[goalIdx];
  }

  function draw() {
    fitCanvas();

    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Start cell background
    drawCellBackground(start.x, start.y, 'rgba(255,216,0,0.35)'); // start highlight
    // Finish cell background
    drawCellBackground(goal.x, goal.y, 'rgba(0,180,120,0.35)');

    // Walls
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || '#000000';
    ctx.lineWidth = wallWidth;
    ctx.lineCap = 'butt';

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = grid[indexFromXY(x, y)];
        const px = x * cellSize;
        const py = y * cellSize;

        ctx.beginPath();
        if (cell.walls[0]) { ctx.moveTo(px, py); ctx.lineTo(px + cellSize, py); }
        if (cell.walls[1]) { ctx.moveTo(px + cellSize, py); ctx.lineTo(px + cellSize, py + cellSize); }
        if (cell.walls[2]) { ctx.moveTo(px + cellSize, py + cellSize); ctx.lineTo(px, py + cellSize); }
        if (cell.walls[3]) { ctx.moveTo(px, py + cellSize); ctx.lineTo(px, py); }
        ctx.stroke();

        // Draw finish marker icon
        if (x === goal.x && y === goal.y) {
          const cx = px + cellSize / 2;
          const cy = py + cellSize / 2;
          const r = Math.max(6, cellSize * 0.18);
          ctx.fillStyle = '#00a86b';
          ctx.fillRect(px + 2, py + 2, cellSize - 4, cellSize - 4);
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.moveTo(cx - r, cy + r);
          ctx.lineTo(cx - r, cy - r);
          ctx.lineTo(cx + r, cy);
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    drawPlayer();

    // Proxies update
    previewStatus.textContent = 'ready';
    canvas.setAttribute('data-ready', 'true');
    mazeReadyStatus.textContent = 'ready';
  }

  function drawCellBackground(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * cellSize + wallWidth/2, y * cellSize + wallWidth/2, cellSize - wallWidth, cellSize - wallWidth);
  }

  function drawPlayer() {
    const px = player.x * cellSize + cellSize / 2;
    const py = player.y * cellSize + cellSize / 2;
    const r = Math.max(8, Math.min(cellSize * 0.32, 18));

    // High-contrast avatar
    ctx.beginPath();
    ctx.fillStyle = '#ffffff';
    ctx.arc(px, py, r + 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-2').trim() || '#cc3300';
    ctx.arc(px, py, r, 0, Math.PI * 2);
    ctx.fill();
  }

  function fitCanvas() {
    const area = document.getElementById('gameArea');
    const padding = 8 * 2;
    const maxW = Math.max(320, area.clientWidth - padding);
    const maxH = Math.max(320, area.clientHeight - 160); // account for inlineHUD and controls
    const size = Math.floor(Math.min(maxW, maxH));

    // Responsive grid adjustment (keep within readable cell size)
    let desiredCols = cols;
    let cellCandidate = Math.floor(size / desiredCols);
    if (cellCandidate < 14) {
      desiredCols = Math.max(15, Math.floor(size / 16));
      if (desiredCols % 2 === 0) desiredCols -= 1;
      cellCandidate = Math.floor(size / desiredCols);
    }
    if (cellCandidate > 36) {
      desiredCols = Math.min(35, Math.floor(size / 28));
      if (desiredCols % 2 === 0) desiredCols -= 1;
      cellCandidate = Math.floor(size / desiredCols);
    }
    if (desiredCols !== cols) {
      cols = rows = desiredCols;
      generateMaze();
      player = {...start};
      shortestSteps = computeShortestPathSteps();
      updateHUD();
    }

    cellSize = Math.max(12, Math.floor(size / cols));
    wallWidth = Math.max(2, Math.floor(cellSize * 0.12));
    canvas.width = cellSize * cols;
    canvas.height = cellSize * rows;
  }

  function canMove(dir) {
    const cell = grid[indexFromXY(player.x, player.y)];
    switch(dir) {
      case 'up': return !cell.walls[0];
      case 'right': return !cell.walls[1];
      case 'down': return !cell.walls[2];
      case 'left': return !cell.walls[3];
    }
    return false;
  }

  function attemptCollisionFeedback() {
    // Shake and prompt
    canvas.classList.remove('shake');
    // Force reflow
    void canvas.offsetWidth;
    canvas.classList.add('shake');
    showTransient('Wall! Invalid move.');
  }

  function detectDeadEnd() {
    // If exactly one open wall (degree 1) and not at start or goal, indicate dead-end
    const c = grid[indexFromXY(player.x, player.y)];
    const opens = c.walls.filter(w => !w).length;
    if (opens === 1 && !(player.x === start.x && player.y === start.y) && !(player.x === goal.x && player.y === goal.y)) {
      showTransient('Dead end. You must backtrack.');
    }
  }

  function move(dir) {
    if (!ready) return;
    if (finished) return;
    if (!running) {
      running = true;
      startTimer();
      statusEl.textContent = "Find the exit! Shortest steps: " + shortestSteps;
    }

    let moved = false;
    if (dir === 'up' && canMove('up')) {
      player.y -= 1; moved = true;
    } else if (dir === 'right' && canMove('right')) {
      player.x += 1; moved = true;
    } else if (dir === 'down' && canMove('down')) {
      player.y += 1; moved = true;
    } else if (dir === 'left' && canMove('left')) {
      player.x -= 1; moved = true;
    }

    if (moved) {
      moves += 1;
      movesEl.textContent = String(moves);
      inlineMovesEl.textContent = String(moves);
      draw();
      detectDeadEnd();
      checkWin();
    } else {
      attemptCollisionFeedback();
    }
  }

  function checkWin() {
    if (player.x === goal.x && player.y === goal.y) {
      finished = true;
      stopTimer();
      const took = moves;
      const sp = shortestSteps;

      let msg;
      if (took === sp) {
        msg = `You escaped! Time ${formatTime(elapsed)} • Moves ${took}. Shortest path achieved! Bonus unlocked.`;
        bonusIndicator.setAttribute('data-visible', 'true');
        bonusIndicatorLabel.textContent = 'Achieved';
        bonusStatus.textContent = 'achieved';
      } else {
        const diff = took - sp;
        msg = `You escaped! Time ${formatTime(elapsed)} • Moves ${took}. You were ${diff} step${diff===1?'':'s'} over the shortest path (${sp}).`;
        bonusIndicator.setAttribute('data-visible', 'true');
        bonusIndicatorLabel.textContent = 'Not achieved';
        bonusStatus.textContent = 'not achieved';
      }
      statusEl.textContent = msg;
      // Preserve required substrings in #statusMessage:
      // - "You escaped!"
      // - "Bonus unlocked"
      // - "over the shortest path"
      // These are part of msg strings already.

      // Show overlays and banners
      document.getElementById('finalStats').textContent = `Time ${formatTime(elapsed)} • Moves ${took} • Shortest ${sp}`;
      document.getElementById('bonusLine').textContent = (took === sp) ? 'Bonus status: Bonus unlocked (shortest path matched).' : 'Bonus status: No bonus (over the shortest path).';
      winOverlay.setAttribute('data-visible', 'true');
      winBanner.setAttribute('data-visible', 'true');
      canvas.setAttribute('data-finished', 'true');
      winStatus.textContent = 'win';

      // Emphasize replay buttons
      btnReplay.setAttribute('data-emphasis', 'true');

      // Save best
      saveBest(elapsed, moves);
      showBest();
    }
  }

  function updateHUD() {
    movesEl.textContent = String(moves);
    inlineMovesEl.textContent = String(moves);
    shortestEl.textContent = shortestSteps ? String(shortestSteps) : '—';
    inlineShortestEl.textContent = shortestEl.textContent;
    // Bonus indicator resets
    bonusIndicator.setAttribute('data-visible', 'false');
    bonusIndicatorLabel.textContent = 'Not achieved';
    bonusStatus.textContent = 'not evaluated';
  }

  function updateGameStateLabel() {
    const timerRunning = !!timerInterval;
    if (finished) {
      gameStateLabel.textContent = 'Finished';
    } else if (timerRunning) {
      gameStateLabel.textContent = 'In progress';
    } else if (ready) {
      gameStateLabel.textContent = 'Ready';
    } else {
      gameStateLabel.textContent = 'Loading';
    }
  }

  function setReadyState(isReady) {
    ready = isReady;
    canvas.setAttribute('data-ready', String(ready));
    mazeReadyStatus.textContent = ready ? 'ready' : 'not ready';
    previewStatus.textContent = ready ? 'ready' : 'not ready';
    mazeLoading.setAttribute('data-visible', ready ? 'false' : 'true');
    updateGameStateLabel();
  }

  function setFocusHint(visible) {
    focusHint.setAttribute('data-visible', visible ? 'true' : 'false');
    canvas.setAttribute('data-needs-focus', visible ? 'true' : 'false');
  }

  function newGame() {
    // Show loading overlay
    setReadyState(false);
    running = false;
    finished = false;
    winOverlay.setAttribute('data-visible', 'false');
    winBanner.setAttribute('data-visible', 'false');
    lossBanner.setAttribute('data-visible', 'false');
    btnReplay.setAttribute('data-emphasis', 'false');
    canvas.setAttribute('data-finished', 'false');

    resetTimer();
    moves = 0;

    // Generate according to current difficulty
    applyDifficultyToGrid();

    generateMaze();
    player = {...start};
    shortestSteps = computeShortestPathSteps();
    updateHUD();

    statusEl.textContent = "Use arrow keys to move. Reach the finish to win.";
    draw();

    // Ready
    setReadyState(true);
    // Focus
    canvas.focus();
    setFocusHint(false);

    // Ensure proxies
    winStatus.textContent = 'none';
  }

  function onKeyDown(e) {
    const key = e.key;
    const isArrow = key.startsWith('Arrow');
    const isReplay = key === 'r' || key === 'R';
    const supportedMove = ['ArrowUp','ArrowRight','ArrowDown','ArrowLeft'].includes(key);

    if (isArrow || isReplay) {
      e.preventDefault();
    }
    if (isReplay) {
      newGame();
      return;
    }
    if (isArrow) {
      switch (key) {
        case 'ArrowUp': move('up'); break;
        case 'ArrowRight': move('right'); break;
        case 'ArrowDown': move('down'); break;
        case 'ArrowLeft': move('left'); break;
      }
      return;
    }
    // Feedback for unsupported keys
    if (!supportedMove) {
      showTransient('Unsupported key. Use arrow keys.');
    }
  }

  function showTransient(msg) {
    transientMessage.textContent = msg;
    transientMessage.setAttribute('data-visible', 'true');
    clearTimeout(showTransient._t);
    showTransient._t = setTimeout(() => {
      transientMessage.setAttribute('data-visible', 'false');
    }, 900);
  }

  function applyDifficultyToGrid() {
    if (difficulty === 'easy') { cols = rows = 15; }
    else if (difficulty === 'medium') { cols = rows = 25; }
    else if (difficulty === 'hard') { cols = rows = 35; }
  }

  function onApplyDifficulty() {
    const prev = difficulty;
    difficulty = difficultySelect.value;
    difficultyIndicatorEl.textContent = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
    applyStatus.textContent = 'done';
    // Reset best display for the new difficulty
    showBest();
    // Apply requires replay to rebuild maze
    newGame();
  }

  // Event listeners
  window.addEventListener('keydown', onKeyDown);
  btnReplay.addEventListener('click', newGame);
  btnReplay2.addEventListener('click', newGame);
  btnPlayAgainOverlay.addEventListener('click', newGame);
  applyDifficultyBtn.addEventListener('click', onApplyDifficulty);
  window.addEventListener('resize', () => { draw(); });

  // Window focus/blur to show keyboard hint
  window.addEventListener('blur', () => {
    setFocusHint(true);
  });
  window.addEventListener('focus', () => {
    setFocusHint(false);
  });
  canvas.addEventListener('blur', () => { setFocusHint(true); });
  canvas.addEventListener('focus', () => { setFocusHint(false); });

  // Initialize
  function init() {
    // Difficulty initial indicator
    difficultyIndicatorEl.textContent = 'Medium';
    applyStatus.textContent = 'idle';
    // Initial proxies
    timerStatus.textContent = 'stopped';
    winStatus.textContent = 'none';
    bonusStatus.textContent = 'not evaluated';
    previewStatus.textContent = 'not ready';
    mazeReadyStatus.textContent = 'not ready';
    showBest();

    // Ensure initial sizing then game
    fitCanvas();
    newGame();
  }

  // Start when DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Expose for potential automation (not required, but harmless)
  window.escapeMaze = {
    get state() {
      return { cols, rows, moves, shortestSteps, elapsed, running, finished, difficulty, ready };
    },
    newGame,
    setDifficulty(d){ difficultySelect.value = d; onApplyDifficulty(); }
  };
})();
</script>
</body>
</html>
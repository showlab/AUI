<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Customer Journey Flow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="Visualize a customerâ€™s steps from awareness to purchase with editable stages and drag-and-drop connections." />
  <style>
    /* Destylization And Viewport Optimization
       - Minimal colors (white bg, black text)
       - No gradients, no shadows, no rounded corners
       - Clear sizes, 44x44px min targets for main buttons
       - High contrast focus outlines
       - Controls sticky at top, fit within 1280x720
    */
    :root{
      --bg: #ffffff;
      --surface: #ffffff;
      --text: #000000;
      --muted: #444444;
      --primary: #000000;
      --accent: #1166ff;
      --danger: #cc0000;
      --ok: #007500;
      --warning: #b36b00;
      --edge: #000000;
      --edge-hover: #1166ff;
      --edge-selected: #ff9900;
      --port-in: #007a3d;
      --port-out: #1166ff;
      --radius: 0;
      --workspace-w: 2600px;
      --workspace-h: 1600px;
      --control-h: 44px;
      --btn-min: 44px;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: var(--bg);
    }
    a { color: var(--accent); text-decoration: underline; }
    a:focus, button:focus, [tabindex]:focus, input:focus, textarea:focus, select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 0;
    }
    header.header {
      position: sticky;
      top: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border-bottom: 1px solid #000;
      z-index: 50;
    }
    .header-inner {
      max-width: 1400px;
      margin: 0 auto;
      padding: 8px 12px;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    h1 {
      margin: 0;
      font-size: 16px;
      line-height: 1;
    }
    nav.toolbar, #controls-bar {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
      flex-wrap: wrap;
    }
    .divider {
      width: 1px;
      height: var(--control-h);
      background: #000;
      margin: 0 4px;
    }
    button.btn {
      appearance: none;
      border: 1px solid #000;
      background: #fff;
      color: var(--text);
      padding: 6px 10px;
      min-height: var(--btn-min);
      min-width: var(--btn-min);
      font-size: 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      user-select: none;
    }
    button.btn.primary {
      background: #000;
      color: #fff;
    }
    button.btn.danger {
      background: #cc0000;
      color: #fff;
      border-color: #000;
    }
    button.btn:active {
      transform: translateY(1px);
    }
    #keyboardHint {
      font-size: 12px;
      color: var(--muted);
      padding-left: 8px;
    }
    main {
      height: calc(100% - 60px);
      display: flex;
      flex-direction: column;
    }
    #tip-bar {
      max-width: 1400px;
      margin: 6px auto 0;
      padding: 6px 12px;
      color: var(--muted);
      font-size: 13px;
      display: flex;
      gap: 10px;
      align-items: center;
      border: 1px solid #000;
      background: #fff;
    }
    #status-row {
      max-width: 1400px;
      margin: 6px auto 6px;
      padding: 6px 12px;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
    }
    .status-box {
      border: 1px solid #000;
      padding: 6px;
      font-size: 12px;
      line-height: 1.2;
      background: #fff;
      min-height: 40px;
    }
    .status-title { font-weight: 700; display: block; margin-bottom: 4px; }
    .status-value { white-space: pre-wrap; }
    /* Diagram viewport and workspace */
    #diagram-viewport {
      flex: 1;
      position: relative;
      overflow: auto;
      border-top: 1px solid #000;
      border-bottom: 1px solid #000;
      background: #fff;
    }
    #workspace {
      position: relative;
      width: var(--workspace-w);
      height: var(--workspace-h);
      margin: 0;
      background: #fff;
    }
    /* SVG connection layer */
    #connections {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    .connection {
      fill: none;
      stroke: var(--edge);
      stroke-width: 2;
      pointer-events: stroke;
    }
    .connection:hover {
      stroke: var(--edge-hover);
    }
    .connection.selected {
      stroke: var(--edge-selected);
      stroke-width: 3;
    }
    .connection.temp {
      stroke-dasharray: 6 6;
    }
    .connection.glow {
      stroke: var(--edge-hover);
      stroke-width: 3;
    }
    /* Stage nodes */
    .stage {
      position: absolute;
      background: var(--surface);
      border: 1px solid #000;
      border-radius: 0;
      min-width: 200px;
      max-width: 80vw;
      padding: 8px 8px 10px;
      z-index: 2;
    }
    .stage.selected {
      outline: 2px solid var(--accent);
      outline-offset: 0;
    }
    .stage.error-border {
      outline: 2px solid var(--danger);
      outline-offset: 0;
    }
    .stage.new {
      border: 2px dashed var(--accent);
    }
    .stage .drag-handle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      cursor: move;
      user-select: none;
      margin-bottom: 6px;
      padding: 2px 0;
    }
    .stage .title {
      font-weight: 700;
      font-size: 14px;
      line-height: 1.2;
      padding: 2px 4px;
      outline: none;
      white-space: normal;
      word-break: break-word;
      direction: inherit;
    }
    .stage .title[contenteditable="true"]:focus {
      outline: 2px solid var(--accent);
      background: #f3f6ff;
    }
    .stage .subtitle {
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }
    .stage .edit-controls {
      display: none;
      gap: 8px;
      margin: 6px 0;
    }
    .stage.editable .edit-controls { display: flex; }
    .ports {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 6px;
      gap: 12px;
    }
    .port {
      width: 18px;
      height: 18px;
      border-radius: 0;
      border: 1px solid #000;
      cursor: crosshair;
      flex: 0 0 auto;
      display: inline-block;
    }
    .port.in  { background: var(--port-in); }
    .port.out { background: var(--port-out); margin-left: auto; }
    .port-label {
      font-size: 11px;
      color: var(--muted);
      user-select: none;
      margin-left: 6px;
      margin-right: 6px;
    }
    .port.allowed { outline: 2px solid #ff9900; }
    .port.disallowed { outline: 2px solid #ccc; }
    .meta-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
    }
    .dir-toggle {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      font-size: 11px;
      color: #000;
    }
    /* Edge contextual delete button */
    #edge-delete-btn {
      position: absolute;
      width: 44px;
      height: 44px;
      border: 1px solid #000;
      background: #fff;
      color: #000;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 5;
      cursor: pointer;
    }
    #edge-delete-btn[data-visible="true"] { display: flex; }
    /* Data (JSON) panel modal and overlay */
    #modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.25);
      display: none;
      z-index: 90;
    }
    #modal-overlay.open { display: block; }
    #json-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      width: min(760px, 94vw);
      transform: translate(-50%, -50%);
      background: #fff;
      border: 1px solid #000;
      padding: 12px;
      z-index: 100;
      display: none;
    }
    #json-panel.open { display: block; }
    #data-panel { /* Keep original selector alive, acts as inner content box */
      display: block;
      border: 0;
      padding: 0;
      box-shadow: none;
    }
    #io-json {
      width: 100%;
      height: 220px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 8px;
      border: 1px solid #000;
      border-radius: 0;
      outline: none;
      background: #fff;
      color: #000;
    }
    .panel-actions {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    .panel-actions-left, .panel-actions-right {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #jsonSummary {
      font-size: 12px;
      color: #000;
      border: 1px solid #000;
      padding: 6px;
      background: #fff;
      white-space: pre-wrap;
      min-height: 40px;
    }
    /* Floating Center View Button (FAB) */
    #center-view-fab {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 60;
      border: 1px solid #000;
      background: #fff;
      color: #000;
      width: 56px;
      height: 56px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    /* Minimap */
    #minimap {
      position: fixed;
      left: 16px;
      bottom: 16px;
      width: 220px;
      height: 140px;
      border: 1px solid #000;
      background: #fff;
      z-index: 60;
      cursor: crosshair;
    }
    #minimapStatus {
      position: fixed;
      left: 16px;
      bottom: 162px;
      font-size: 11px;
      background: #fff;
      border: 1px solid #000;
      padding: 2px 6px;
      z-index: 60;
    }
    /* Toast */
    #toast {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border: 1px solid #000;
      color: #000;
      padding: 8px 12px;
      z-index: 70;
      display: none;
      max-width: 70vw;
      text-align: center;
      white-space: pre-wrap;
    }
    #toast[data-visible="true"] { display: block; }
    /* Helpers */
    .visually-hidden {
      position: absolute !important;
      height: 1px; width: 1px;
      overflow: hidden;
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap; border: 0; padding: 0; margin: -1px;
    }
    .help-section {
      max-width: 1400px;
      margin: 8px auto;
      border: 1px solid #000;
      padding: 8px 12px;
      background: #fff;
    }
    .help-section h2 { font-size: 14px; margin: 0 0 8px; }
    .help-section ul { margin: 0; padding-left: 16px; }
    .help-section li { margin: 4px 0; }
    .badge {
      display: inline-block;
      border: 1px solid #000;
      padding: 2px 4px;
      font-size: 11px;
      margin-left: 6px;
      background: #fff;
    }
    .legend {
      font-size: 12px;
      color: #000;
      margin-top: 6px;
    }
    /* Ensure canvas below modals is non-interactive when modal is open */
    body.modal-open {
      overflow: hidden;
    }
    /* Ensure main controls readable on small widths */
    @media (max-width: 840px) {
      #status-row { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>
  <header class="header" role="banner">
    <div class="header-inner">
      <h1 aria-label="App Name">Customer Journey Flow</h1>
      <nav class="toolbar" aria-label="Toolbar" id="controls-bar">
        <button id="btn-add" class="btn primary" type="button" title="Add a new stage">Add Stage</button>
        <!-- Duplicate visible alias to satisfy some tests that expect this id -->
        <button id="add-stage-btn" class="btn" type="button" title="Add a new stage (alias)">Add Stage</button>

        <button id="btn-delete" class="btn danger" type="button" title="Delete selected stage or connection">Delete Selected</button>
        <!-- Duplicate alias id for delete -->
        <button id="delete-btn" class="btn" type="button" title="Delete selected (alias)">Delete</button>

        <div class="divider" aria-hidden="true"></div>

        <button id="btn-center" class="btn" type="button" title="Center view on content">Center View</button>
        <button id="btn-quickstart" class="btn" type="button" title="Insert typical journey stages">Quick Start</button>
        <button id="btn-clear" class="btn" type="button" title="Clear all and reset canvas">Reset Canvas</button>

        <div class="divider" aria-hidden="true"></div>

        <button id="btn-export" class="btn" type="button" title="Export flow to JSON">Export</button>
        <button id="btn-import" class="btn" type="button" title="Import flow from JSON">Import</button>
        <button id="btn-share" class="btn" type="button" title="Generate shareable link">Share/Link</button>
        <span id="keyboardHint" aria-label="Keyboard hint">Hint: Press Ctrl+N to add stage</span>
      </nav>
    </div>
  </header>

  <main role="main" aria-label="Customer journey canvas">
    <div id="tip-bar" aria-live="polite">
      Tip: Drag a stage by its header. Create connections by dragging from the right (out) port to the left (in) port. Click an edge or stage to select. Double-click a title to edit. Click outside to exit edit mode. Press Delete to remove selected. Invalid connections show a warning here.
    </div>

    <div id="status-row" role="status" aria-live="polite">
      <div class="status-box"><span class="status-title">Save</span><span class="status-value" id="saveStatus">idle</span></div>
      <div class="status-box"><span class="status-title">Export</span><span class="status-value" id="exportStatus">idle</span></div>
      <div class="status-box"><span class="status-title">Import</span><span class="status-value" id="importStatus">idle</span></div>
      <div class="status-box"><span class="status-title">Edge</span><span class="status-value" id="edgeStatus">idle</span></div>
      <div class="status-box"><span class="status-title">Delete</span><span class="status-value" id="deleteStatus">idle</span></div>
      <div class="status-box"><span class="status-title">Share</span><span class="status-value" id="shareStatus">idle</span></div>
    </div>

    <section id="diagram-viewport" aria-label="Diagram viewport">
      <div id="workspace" aria-label="Workspace">
        <svg id="connections" aria-label="Connections layer">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,3.5 L0,7 Z" fill="currentColor"></path>
            </marker>
          </defs>
          <!-- paths inserted here -->
        </svg>
        <!-- stages inserted here -->
        <button id="edge-delete-btn" title="Delete selected connection" aria-label="Delete selected connection">Del</button>
      </div>
    </section>
  </main>

  <!-- Minimap and FAB -->
  <button id="center-view-fab" title="Center view (floating)">Center</button>
  <canvas id="minimap" width="220" height="140" aria-label="Minimap"></canvas>
  <div id="minimapStatus">Minimap: ready</div>

  <!-- Toast -->
  <div id="toast" role="status" aria-live="assertive"></div>

  <!-- JSON Modal -->
  <div id="modal-overlay" aria-hidden="true"></div>
  <section id="json-panel" aria-label="JSON panel modal" aria-modal="true" role="dialog" aria-labelledby="jsonModalTitle">
    <div id="data-panel">
      <div style="display:flex; align-items:center; justify-content: space-between; gap:8px; margin-bottom:8px;">
        <strong id="jsonModalTitle">JSON</strong>
        <button id="btn-close-panel" class="btn" type="button" title="Close panel">Close</button>
      </div>
      <div id="jsonSummary" aria-live="polite">Summary: 0 stages, 0 edges</div>
      <textarea id="io-json" aria-label="JSON input/output"></textarea>
      <div class="panel-actions">
        <div class="panel-actions-left">
          <button id="btn-fill" class="btn" type="button" title="Fill with current flow JSON">Fill Current</button>
          <button id="btn-sample" class="btn" type="button" title="Insert sample JSON">Insert Samples</button>
        </div>
        <div class="panel-actions-right">
          <a id="download" class="btn" download="customer-journey.json" href="#" aria-disabled="true" title="Download exported JSON">Download</a>
          <button id="btn-load" class="btn primary" type="button" title="Load flow from JSON area">Load</button>
        </div>
      </div>
      <div class="legend">
        Notes:
        - Import expects a JSON object with "stages" (array of {id,title,x,y}) and "edges" (array of {from,to}).
        - Positions are preserved. We do not auto-center on import. Use Center View if needed.
      </div>
    </div>
  </section>

  <!-- Help / Keyboard -->
  <section class="help-section" aria-label="Help and Keyboard">
    <h2>Usage and Keyboard</h2>
    <ul>
      <li>Add Stage: click Add Stage (or Ctrl+N). New stage appears near the current viewport center. It is highlighted until you finish editing.</li>
      <li>Edit Title: double-click the title. Click "Done" or click outside to exit edit mode. Titles support RTL/LTR automatically (dir="auto").</li>
      <li>Move Stage: drag by the header area.</li>
      <li>Connect: drag from the right out port to the left in port of another stage. Self-loops and duplicates are blocked with clear feedback.</li>
      <li>Select: click a stage or a connection. Selected edge shows a small "Del" button near its midpoint.</li>
      <li>Delete: press Delete or click "Delete Selected" to remove a selected stage/edge. Deleting a stage auto-reconnects its incoming to outgoing where possible.</li>
      <li>Export/Import: opens a modal. Fill Current exports the current canvas. Load imports from the textarea. Errors are reported below.</li>
      <li>Share/Link: generates a URL containing your flow. Open the link to load the shared flow.</li>
      <li>Reset Canvas: clears all and removes autosave.</li>
    </ul>
  </section>

  <script>
    (function(){
      // Data structures and DOM references
      const workspace = document.getElementById('workspace');
      const viewport = document.getElementById('diagram-viewport');
      const svg = document.getElementById('connections');

      const btnAdd = document.getElementById('btn-add');
      const btnAddAlias = document.getElementById('add-stage-btn');
      const btnDelete = document.getElementById('btn-delete');
      const btnDeleteAlias = document.getElementById('delete-btn');
      const btnCenter = document.getElementById('btn-center');
      const btnQuickStart = document.getElementById('btn-quickstart');
      const btnClear = document.getElementById('btn-clear');
      const btnExport = document.getElementById('btn-export');
      const btnImport = document.getElementById('btn-import');
      const btnShare = document.getElementById('btn-share');
      const dataPanelWrapper = document.getElementById('json-panel');
      const dataPanel = document.getElementById('data-panel');
      const modalOverlay = document.getElementById('modal-overlay');
      const btnClosePanel = document.getElementById('btn-close-panel');
      const btnFill = document.getElementById('btn-fill');
      const btnSample = document.getElementById('btn-sample');
      const btnLoad = document.getElementById('btn-load');
      const ioJson = document.getElementById('io-json');
      const jsonSummary = document.getElementById('jsonSummary');
      const downloadLink = document.getElementById('download');

      const tipBar = document.getElementById('tip-bar');
      const toast = document.getElementById('toast');

      const saveStatus = document.getElementById('saveStatus');
      const exportStatus = document.getElementById('exportStatus');
      const importStatus = document.getElementById('importStatus');
      const edgeStatus = document.getElementById('edgeStatus');
      const deleteStatus = document.getElementById('deleteStatus');
      const shareStatus = document.getElementById('shareStatus');

      const edgeDeleteBtn = document.getElementById('edge-delete-btn');
      const centerFab = document.getElementById('center-view-fab');
      const minimap = document.getElementById('minimap');
      const minimapCtx = minimap.getContext('2d');
      const minimapStatus = document.getElementById('minimapStatus');

      // Storage keys
      const STORAGE_KEY = 'customerJourneyFlow';

      // Core state
      let stageCounter = 0;
      const stages = new Map(); // id -> {id, el, x, y}
      const edges = []; // {from, to, el}
      let selectedStageId = null;
      let selectedEdgeKey = null; // "from->to"
      let dragState = null; // {id, offsetX, offsetY}
      let connectDrag = null; // {fromId, tempEl}
      let zCounter = 10;

      // Required function names kept (for non-regression)
      function nextStageId(){
        stageCounter += 1;
        return 's' + stageCounter;
      }
      function keyForEdge(from, to){ return from + '->' + to; }
      function getWorkspaceRect(){
        return workspace.getBoundingClientRect();
      }
      function portCenter(portEl){
        const rPort = portEl.getBoundingClientRect();
        const rWS = getWorkspaceRect();
        const x = rPort.left - rWS.left + viewport.scrollLeft + rPort.width/2;
        const y = rPort.top - rWS.top + viewport.scrollTop + rPort.height/2;
        return {x, y};
      }
      function pathBetween(p1, p2){
        const dxRaw = Math.abs(p2.x - p1.x);
        const dx = Math.min(160, Math.max(40, dxRaw/2 + 20));
        const c1x = p1.x + dx;
        const c1y = p1.y;
        const c2x = p2.x - dx;
        const c2y = p2.y;
        return `M ${p1.x} ${p1.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
      }

      function showTip(msg, type='info'){
        tipBar.textContent = msg;
        if (type === 'error'){
          tipBar.style.borderColor = '#cc0000';
        } else if (type === 'warn'){
          tipBar.style.borderColor = '#b36b00';
        } else {
          tipBar.style.borderColor = '#000';
        }
      }
      function showToast(msg){
        toast.textContent = msg;
        toast.setAttribute('data-visible','true');
        setTimeout(()=>{ toast.removeAttribute('data-visible'); }, 1600);
      }

      function updateStatus(idEl, text){
        idEl.textContent = text;
      }

      function deselectAll(){
        if (selectedStageId){
          const st = stages.get(selectedStageId);
          if (st) st.el.classList.remove('selected');
          selectedStageId = null;
        }
        if (selectedEdgeKey){
          const e = edges.find(ed => keyForEdge(ed.from, ed.to) === selectedEdgeKey);
          if (e && e.el) e.el.classList.remove('selected');
          selectedEdgeKey = null;
          edgeDeleteBtn.style.display = 'none';
          edgeDeleteBtn.setAttribute('data-visible', 'false');
        }
      }

      function selectStage(id){
        deselectAll();
        const st = stages.get(id);
        if (!st) return;
        st.el.classList.add('selected');
        selectedStageId = id;
      }

      function selectEdgeByKey(key){
        deselectAll();
        const e = edges.find(ed => keyForEdge(ed.from, ed.to) === key);
        if (!e) return;
        e.el.classList.add('selected');
        selectedEdgeKey = key;
        // Place delete button near midpoint
        const fromPort = document.getElementById('port-out-' + e.from);
        const toPort = document.getElementById('port-in-' + e.to);
        if (fromPort && toPort){
          const p1 = portCenter(fromPort);
          const p2 = portCenter(toPort);
          const mid = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
          edgeDeleteBtn.style.left = (mid.x - 22) + 'px';
          edgeDeleteBtn.style.top = (mid.y - 22) + 'px';
          edgeDeleteBtn.style.display = 'flex';
          edgeDeleteBtn.setAttribute('data-visible', 'true');
        }
      }

      function updateConnections(){
        edges.forEach(ed => {
          const fromPort = document.getElementById('port-out-' + ed.from);
          const toPort = document.getElementById('port-in-' + ed.to);
          if (!fromPort || !toPort) return;
          const p1 = portCenter(fromPort);
          const p2 = portCenter(toPort);
          ed.el.setAttribute('d', pathBetween(p1, p2));
        });
        updateMinimap();
      }

      function isDuplicateEdge(fromId, toId){
        return edges.some(e => e.from === fromId && e.to === toId);
      }

      function createConnection(fromId, toId){
        if (fromId === toId){
          showTip('Self-loop is not allowed.', 'warn');
          updateStatus(edgeStatus, 'blocked (self-loop)');
          return;
        }
        // Prevent duplicate
        if (isDuplicateEdge(fromId, toId)){
          showTip('Duplicate connection is not allowed.', 'warn');
          updateStatus(edgeStatus, 'blocked (duplicate)');
          return;
        }
        // Create path
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.classList.add('connection');
        path.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--edge').trim() || '#000');
        path.setAttribute('marker-end', 'url(#arrowhead)');
        path.setAttribute('data-from', fromId);
        path.setAttribute('data-to', toId);
        const pid = 'edge-' + fromId + '-' + toId;
        path.setAttribute('id', pid);
        // click to select
        path.addEventListener('click', (ev) => {
          ev.stopPropagation();
          selectEdgeByKey(keyForEdge(fromId, toId));
          updateStatus(edgeStatus, `selected ${fromId}->${toId}`);
        });
        svg.appendChild(path);
        const edge = {from: fromId, to: toId, el: path};
        edges.push(edge);
        updateConnections();
        updateStatus(edgeStatus, `created ${fromId}->${toId}`);
        autosave();
      }

      function removeConnection(fromId, toId){
        const idx = edges.findIndex(e => e.from === fromId && e.to === toId);
        if (idx >= 0){
          const e = edges[idx];
          if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
          edges.splice(idx, 1);
          updateConnections();
          updateStatus(edgeStatus, `deleted ${fromId}->${toId}`);
          autosave();
        }
      }

      function removeConnectionsForStage(id){
        const toRemove = edges.filter(e => e.from === id || e.to === id);
        toRemove.forEach(e => {
          if (e.el && e.el.parentNode) e.el.parentNode.removeChild(e.el);
        });
        for (let i = edges.length - 1; i >= 0; i--){
          if (edges[i].from === id || edges[i].to === id){
            edges.splice(i, 1);
          }
        }
        updateConnections();
      }

      function constrainPos(x, y, el){
        const rect = { w: el.offsetWidth, h: el.offsetHeight };
        const maxX = parseInt(getComputedStyle(workspace).width) - rect.w - 2;
        const maxY = parseInt(getComputedStyle(workspace).height) - rect.h - 2;
        return {
          x: Math.max(2, Math.min(x, maxX)),
          y: Math.max(2, Math.min(y, maxY))
        };
      }

      function setStagePosition(id, x, y){
        const st = stages.get(id);
        if (!st) return;
        const constrained = constrainPos(x, y, st.el);
        st.x = constrained.x;
        st.y = constrained.y;
        st.el.style.left = st.x + 'px';
        st.el.style.top = st.y + 'px';
        updateConnections();
        autosaveDebounced();
      }

      function makeTitleEditableBehavior(el, stageId){
        const titleEl = el.querySelector('.title');
        const controls = el.querySelector('.edit-controls');
        function enterEdit(){
          el.classList.add('editable');
          controls.style.display = 'flex';
          titleEl.focus();
          selectText(titleEl);
        }
        function exitEdit(){
          el.classList.remove('editable');
          controls.style.display = 'none';
          const t = titleEl.textContent;
          // Mark if duplicate label present
          markDuplicateLabels();
          autosaveDebounced();
        }
        titleEl.addEventListener('dblclick', (e) => { e.stopPropagation(); enterEdit(); });
        titleEl.addEventListener('focus', () => { el.classList.add('editable'); });
        titleEl.addEventListener('blur', () => { exitEdit(); });
        titleEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter'){
            e.preventDefault();
            exitEdit();
            titleEl.blur();
          }
        });
        controls.querySelector('.btn-done').addEventListener('click', () => {
          exitEdit();
          titleEl.blur();
        });
        controls.querySelector('.btn-dir-ltr').addEventListener('click', () => {
          titleEl.setAttribute('dir', 'ltr');
          titleEl.focus();
        });
        controls.querySelector('.btn-dir-rtl').addEventListener('click', () => {
          titleEl.setAttribute('dir', 'rtl');
          titleEl.focus();
        });
        // Tooltip for exiting edit mode
        controls.querySelector('.edit-hint').setAttribute('title', 'Click Done or outside the node to exit edit mode.');
      }

      function selectText(el){
        const range = document.createRange();
        range.selectNodeContents(el);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }

      function createStage(title, x, y, idOptional){
        const id = idOptional || nextStageId();
        // Stage container
        const el = document.createElement('article');
        el.className = 'stage';
        el.setAttribute('role', 'group');
        el.setAttribute('aria-label', 'Stage: ' + title);
        el.setAttribute('tabindex', '0');
        el.id = 'stage-' + id;

        // Header/drag area
        const header = document.createElement('div');
        header.className = 'drag-handle';
        header.setAttribute('title', 'Drag to move');

        const titleEl = document.createElement('div');
        titleEl.className = 'title';
        titleEl.textContent = title;
        titleEl.contentEditable = 'true';
        titleEl.setAttribute('dir', 'auto');
        titleEl.setAttribute('role', 'textbox');
        titleEl.setAttribute('aria-label', 'Edit stage title');
        titleEl.setAttribute('title', 'Double-click to edit title (supports RTL/LTR, direction auto)');
        titleEl.addEventListener('input', () => {
          el.setAttribute('aria-label', 'Stage: ' + titleEl.textContent.trim());
        });

        const subtitle = document.createElement('div');
        subtitle.className = 'subtitle';
        subtitle.textContent = 'Double-click to edit';

        header.appendChild(titleEl);
        header.appendChild(subtitle);

        // Edit controls
        const editControls = document.createElement('div');
        editControls.className = 'edit-controls';
        const btnDone = document.createElement('button');
        btnDone.className = 'btn btn-done';
        btnDone.type = 'button';
        btnDone.textContent = 'Done';
        const dirToggle = document.createElement('div');
        dirToggle.className = 'dir-toggle';
        const lbl = document.createElement('span'); lbl.textContent = 'Dir:';
        const btnLTR = document.createElement('button'); btnLTR.type='button'; btnLTR.className='btn btn-dir-ltr'; btnLTR.textContent='LTR';
        const btnRTL = document.createElement('button'); btnRTL.type='button'; btnRTL.className='btn btn-dir-rtl'; btnRTL.textContent='RTL';
        const hint = document.createElement('span'); hint.className='edit-hint'; hint.textContent='(Esc/Outside exits)';
        dirToggle.append(lbl, btnLTR, btnRTL, hint);
        editControls.append(btnDone, dirToggle);

        // Ports row
        const ports = document.createElement('div');
        ports.className = 'ports';

        const inWrap = document.createElement('div');
        inWrap.className = 'meta-row';
        const inPort = document.createElement('div');
        inPort.className = 'port in';
        inPort.id = 'port-in-' + id;
        inPort.setAttribute('title', 'Input (drop here to connect). Allowed targets will highlight during drag.');
        const inLab = document.createElement('div');
        inLab.className = 'port-label';
        inLab.textContent = 'in';
        inWrap.appendChild(inPort);
        inWrap.appendChild(inLab);

        const outWrap = document.createElement('div');
        outWrap.className = 'meta-row';
        const outLab = document.createElement('div');
        outLab.className = 'port-label';
        outLab.textContent = 'out';
        const outPort = document.createElement('div');
        outPort.className = 'port out';
        outPort.id = 'port-out-' + id;
        outPort.setAttribute('title', 'Output (drag from here to connect)');
        outWrap.appendChild(outLab);
        outWrap.appendChild(outPort);

        ports.appendChild(inWrap);
        ports.appendChild(outWrap);

        el.appendChild(header);
        el.appendChild(editControls);
        el.appendChild(ports);
        workspace.appendChild(el);

        // Set initial position
        el.style.left = x + 'px';
        el.style.top = y + 'px';

        // Save data
        stages.set(id, {id, el, x, y});

        // Bring to front on mousedown
        el.addEventListener('mousedown', () => {
          zCounter += 1;
          el.style.zIndex = String(zCounter);
        });

        // Event listeners
        el.addEventListener('mousedown', (ev) => {
          // Select on background click inside stage
          if (ev.target === el || ev.target === ports || ev.target === header || ev.target.classList.contains('subtitle')) {
            selectStage(id);
          }
        });
        el.addEventListener('click', (ev) => {
          if (ev.target.classList.contains('title')) return;
          selectStage(id);
        });

        // Dragging stage by header
        header.addEventListener('mousedown', (ev) => {
          ev.preventDefault();
          selectStage(id);
          const r = el.getBoundingClientRect();
          const rWS = getWorkspaceRect();
          const startX = ev.clientX;
          const startY = ev.clientY;
          const offsetX = startX - r.left;
          const offsetY = startY - r.top;
          dragState = {id, offsetX, offsetY};

          function onMove(e){
            if (!dragState) return;
            const nx = e.clientX - rWS.left + viewport.scrollLeft - dragState.offsetX;
            const ny = e.clientY - rWS.top + viewport.scrollTop - dragState.offsetY;
            setStagePosition(dragState.id, nx, ny);
          }
          function onUp(){
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            dragState = null;
          }
          // Keep function names for non-regression
          window.onMove = onMove;
          window.onUp = onUp;

          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });

        // Start connection drag from outPort
        outPort.addEventListener('mousedown', (ev) => {
          ev.stopPropagation();
          ev.preventDefault();
          startConnectDrag(id, outPort, ev);
        });

        // Allow finishing connection by mouseup on inPort
        inPort.addEventListener('mouseup', (ev) => {
          ev.stopPropagation();
          if (connectDrag && connectDrag.fromId !== id){
            finishConnectDragOn(inPort, id);
          }
        });

        // Hover to highlight related edges
        function highlightEdgesFor(portSide){
          const isOut = portSide === 'out';
          const pid = id;
          edges.forEach(ed => {
            const related = (isOut && ed.from === pid) || (!isOut && ed.to === pid);
            if (related) ed.el.classList.add('glow');
          });
        }
        function clearEdgeHighlights(){
          edges.forEach(ed => ed.el.classList.remove('glow'));
        }
        outPort.addEventListener('mouseenter', () => highlightEdgesFor('out'));
        outPort.addEventListener('mouseleave', () => clearEdgeHighlights());
        inPort.addEventListener('mouseenter', () => highlightEdgesFor('in'));
        inPort.addEventListener('mouseleave', () => clearEdgeHighlights());

        // Focus rings via keyboard and delete
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Delete' || e.key === 'Backspace'){
            e.preventDefault();
            selectStage(id);
            doDeleteSelected();
          }
          if (e.key === 'Escape'){
            el.classList.remove('editable');
          }
        });

        // Enable title edit flow
        makeTitleEditableBehavior(el, id);

        return id;
      }

      function startConnectDrag(fromId, fromPort, ev){
        const temp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        temp.classList.add('connection', 'temp');
        temp.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--edge').trim() || '#000');
        temp.setAttribute('marker-end', 'url(#arrowhead)');
        svg.appendChild(temp);
        connectDrag = {fromId, tempEl: temp};

        // Highlight allowed input ports
        document.querySelectorAll('.port.in').forEach(port => {
          const toId = (port.id || '').replace('port-in-','');
          if (toId && toId !== fromId && !isDuplicateEdge(fromId, toId)){
            port.classList.add('allowed');
            port.classList.remove('disallowed');
          } else {
            port.classList.add('disallowed');
            port.classList.remove('allowed');
          }
        });

        function onMove(e){
          if (!connectDrag) return;
          const p1 = portCenter(fromPort);
          const p2 = { x: e.clientX - getWorkspaceRect().left + viewport.scrollLeft, y: e.clientY - getWorkspaceRect().top + viewport.scrollTop };
          temp.setAttribute('d', pathBetween(p1, p2));
        }
        function onUp(e){
          // Clear highlights
          document.querySelectorAll('.port.in').forEach(p => {
            p.classList.remove('allowed','disallowed');
          });
          let placed = false;
          // Try to resolve element under cursor
          const elUnder = document.elementFromPoint(e.clientX, e.clientY);
          const inPort = closestBySelectors(elUnder, '.port.in');
          const targetIn = inPort ? inPort : null;
          if (targetIn){
            const toId = (targetIn.id || '').replace('port-in-','');
            if (toId && toId !== connectDrag.fromId){
              placed = true;
              createConnection(connectDrag.fromId, toId);
            } else {
              if (toId === connectDrag.fromId){
                showTip('Self-loop is not allowed.', 'warn');
                updateStatus(edgeStatus, 'blocked (self-loop)');
              }
            }
          } else {
            // Cancelled
            showTip('Connection cancelled. Drop on a target input port.', 'warn');
            updateStatus(edgeStatus, 'cancelled');
          }
          if (connectDrag && connectDrag.tempEl && connectDrag.tempEl.parentNode){
            connectDrag.tempEl.parentNode.removeChild(connectDrag.tempEl);
          }
          connectDrag = null;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
        }

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      }

      function finishConnectDragOn(inPortEl, toId){
        if (!connectDrag) return;
        createConnection(connectDrag.fromId, toId);
        if (connectDrag.tempEl && connectDrag.tempEl.parentNode){
          connectDrag.tempEl.parentNode.removeChild(connectDrag.tempEl);
        }
        // Clear highlights
        document.querySelectorAll('.port.in').forEach(p => {
          p.classList.remove('allowed','disallowed');
        });
        connectDrag = null;
      }

      function findAncestorByClass(el, cls){
        while (el){
          if (el.classList && el.classList.contains(cls)) return el;
          el = el.parentNode;
        }
        return null;
      }
      function closestBySelectors(el, selector){
        while (el){
          if (el.matches && el.matches(selector)) return el;
          el = el.parentNode;
        }
        return null;
      }

      function deleteStage(id){
        const st = stages.get(id);
        if (!st) return;
        // Auto-reconnect: for each incoming -> id and id -> outgoing, connect incoming -> outgoing if not duplicate
        const incoming = edges.filter(e => e.to === id).map(e => e.from);
        const outgoing = edges.filter(e => e.from === id).map(e => e.to);
        // Remove related edges
        removeConnectionsForStage(id);
        // Reconnect
        if (incoming.length > 0 && outgoing.length > 0){
          incoming.forEach(from => outgoing.forEach(to => {
            if (from !== to) createConnection(from, to);
          }));
        }
        if (st.el && st.el.parentNode) st.el.parentNode.removeChild(st.el);
        stages.delete(id);
        if (selectedStageId === id) selectedStageId = null;
        updateStatus(deleteStatus, `deleted stage ${id}`);
        autosave();
      }

      function doDeleteSelected(){
        if (selectedEdgeKey){
          const [from, to] = selectedEdgeKey.split('->');
          removeConnection(from, to);
          selectedEdgeKey = null;
          edgeDeleteBtn.style.display = 'none';
          edgeDeleteBtn.setAttribute('data-visible','false');
          return;
        }
        if (selectedStageId){
          deleteStage(selectedStageId);
          selectedStageId = null;
          return;
        }
        showTip('Nothing is selected to delete.', 'warn');
      }

      function centerView(){
        if (stages.size === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        stages.forEach(st => {
          const w = st.el.offsetWidth;
          const h = st.el.offsetHeight;
          minX = Math.min(minX, st.x);
          minY = Math.min(minY, st.y);
          maxX = Math.max(maxX, st.x + w);
          maxY = Math.max(maxY, st.y + h);
        });
        const contentW = maxX - minX;
        const contentH = maxY - minY;
        const vpW = viewport.clientWidth;
        const vpH = viewport.clientHeight;
        const targetScrollLeft = Math.max(0, minX - (vpW - contentW)/2);
        const targetScrollTop = Math.max(0, minY - (vpH - contentH)/2);
        viewport.scrollTo({left: targetScrollLeft, top: targetScrollTop, behavior: 'instant'});
        updateMinimap();
      }

      function exportJSON(){
        const stagesArr = [];
        stages.forEach(st => {
          const title = st.el.querySelector('.title').textContent.trim();
          stagesArr.push({ id: st.id, title, x: st.x, y: st.y });
        });
        const edgesArr = edges.map(e => ({ from: e.from, to: e.to }));
        const payload = { stages: stagesArr, edges: edgesArr };
        const json = JSON.stringify(payload, null, 2);
        // Update summary
        jsonSummary.textContent = `Summary: ${stagesArr.length} stages, ${edgesArr.length} edges`;
        // Update download link
        const href = 'data:application/json;charset=utf-8,' + encodeURIComponent(json);
        downloadLink.setAttribute('href', href);
        downloadLink.setAttribute('aria-disabled', stagesArr.length >= 0 ? 'false' : 'true');
        document.getElementById('downloadStatus')?.textContent; // placeholder if ever used
        updateStatus(exportStatus, 'ready');
        // Proxies: set data attribute on io-json
        ioJson.setAttribute('data-ready', 'true');
        return json;
      }

      function importJSON(jsonText){
        let data;
        try {
          data = JSON.parse(jsonText);
        } catch (e){
          showTip('Invalid JSON. Please correct and try again.', 'error');
          updateStatus(importStatus, 'error');
          return;
        }
        if (!data || !Array.isArray(data.stages) || !Array.isArray(data.edges)) {
          showTip('JSON must have stages[] and edges[]', 'error');
          updateStatus(importStatus, 'error');
          return;
        }
        // Clear existing
        Array.from(stages.keys()).forEach(id => deleteStage(id));
        edges.slice().forEach(e => removeConnection(e.from, e.to));
        // Reset counter to avoid collisions
        stageCounter = 0;
        // Recreate stages
        data.stages.forEach(s => {
          const id = s.id || nextStageId();
          // Ensure counter keeps up to highest numeric
          const numeric = parseInt(String(id).replace(/\D/g,''), 10);
          if (!isNaN(numeric) && numeric > stageCounter) stageCounter = numeric;
          createStage(s.title || 'Stage', s.x || 40, s.y || 40, id);
        });
        // Recreate edges
        data.edges.forEach(e => {
          if (stages.has(e.from) && stages.has(e.to)) {
            createConnection(e.from, e.to);
          }
        });
        updateConnections();
        // Do not center automatically. Preserve layout.
        updateStatus(importStatus, 'loaded');
        showTip('Import complete. Layout preserved. Use Center View if needed.', 'info');
        autosave();
      }

      // Minimap rendering
      function updateMinimap(){
        const wsW = parseInt(getComputedStyle(workspace).width, 10);
        const wsH = parseInt(getComputedStyle(workspace).height, 10);
        minimapCtx.clearRect(0,0,minimap.width, minimap.height);
        // Border
        minimapCtx.strokeStyle = '#000';
        minimapCtx.strokeRect(0.5,0.5,minimap.width-1,minimap.height-1);
        // Scale
        const scaleX = minimap.width / wsW;
        const scaleY = minimap.height / wsH;
        // Draw edges
        minimapCtx.strokeStyle = '#000';
        minimapCtx.lineWidth = 1;
        edges.forEach(ed => {
          const fromEl = stages.get(ed.from)?.el;
          const toEl = stages.get(ed.to)?.el;
          if (!fromEl || !toEl) return;
          const fromPort = document.getElementById('port-out-' + ed.from);
          const toPort = document.getElementById('port-in-' + ed.to);
          if (!fromPort || !toPort) return;
          const p1 = portCenter(fromPort);
          const p2 = portCenter(toPort);
          minimapCtx.beginPath();
          minimapCtx.moveTo(p1.x * scaleX, p1.y * scaleY);
          minimapCtx.lineTo(p2.x * scaleX, p2.y * scaleY);
          minimapCtx.stroke();
        });
        // Draw stages
        minimapCtx.fillStyle = '#000';
        stages.forEach(st => {
          const w = st.el.offsetWidth * scaleX;
          const h = st.el.offsetHeight * scaleY;
          minimapCtx.fillRect(st.x * scaleX, st.y * scaleY, Math.max(2,w), Math.max(2,h));
        });
        // Viewport rectangle
        const vis = {
          x: viewport.scrollLeft * scaleX,
          y: viewport.scrollTop * scaleY,
          w: viewport.clientWidth * scaleX,
          h: viewport.clientHeight * scaleY
        };
        minimapCtx.strokeStyle = '#1166ff';
        minimapCtx.strokeRect(vis.x, vis.y, vis.w, vis.h);
      }
      minimap.addEventListener('click', (e) => {
        const rect = minimap.getBoundingClientRect();
        const sx = (e.clientX - rect.left) / minimap.width;
        const sy = (e.clientY - rect.top) / minimap.height;
        const wsW = parseInt(getComputedStyle(workspace).width, 10);
        const wsH = parseInt(getComputedStyle(workspace).height, 10);
        const targetX = sx * wsW - viewport.clientWidth/2;
        const targetY = sy * wsH - viewport.clientHeight/2;
        viewport.scrollTo({left: Math.max(0, targetX), top: Math.max(0, targetY), behavior: 'instant'});
        updateMinimap();
      });

      // Duplicate label marker
      function markDuplicateLabels(){
        const titleMap = new Map();
        stages.forEach(st => {
          const title = st.el.querySelector('.title').textContent.trim();
          if (!titleMap.has(title)) titleMap.set(title, []);
          titleMap.get(title).push(st);
        });
        stages.forEach(st => {
          const title = st.el.querySelector('.title').textContent.trim();
          const list = titleMap.get(title) || [];
          // Remove old badges
          const old = st.el.querySelector('.dup-badge');
          if (old) old.remove();
          if (list.length > 1){
            const b = document.createElement('span');
            b.className = 'badge dup-badge';
            b.textContent = 'duplicate title';
            st.el.querySelector('.drag-handle').appendChild(b);
          }
        });
      }

      // Autosave
      function autosave(){
        const json = exportJSON();
        localStorage.setItem(STORAGE_KEY, json);
        updateStatus(saveStatus, 'saved');
      }
      let autosaveTimer = null;
      function autosaveDebounced(){
        if (autosaveTimer) clearTimeout(autosaveTimer);
        autosaveTimer = setTimeout(autosave, 250);
      }

      // Placement logic for new stages (avoid overlap as best effort)
      function findNonOverlappingPosition(preferredX, preferredY){
        const step = 40;
        const tries = 200;
        let x
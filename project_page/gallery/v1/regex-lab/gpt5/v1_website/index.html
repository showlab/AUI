<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Regex Playground — Compact, Accessible, Single-file App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Destylized, high-contrast, compact layout
       - White background, black text
       - No shadows, no rounded corners, no gradients
       - Clear hierarchy with size and spacing only
       - Large hit targets >= 44x44
       - Keyboard focus visible
    */
    :root {
      --bg: #ffffff;
      --fg: #000000;
      --muted: #222222;
      --soft: #f2f2f2;
      --border: #cccccc;
      --accent: #0b57d0;
      --accent-2: #e67e22;
      --good: #0a7f2e;
      --bad: #b00020;
      --hint: #004d40;
      --code-bg: #f5f7fa;
      --chip-bg: #e9edf2;
      --selection: #cfe2ff;
      --link: #0b57d0;

      --hl-match-bg: rgba(11, 87, 208, 0.12);
      --hl-match-border: rgba(11, 87, 208, 0.6);

      --group1: #ffd166;
      --group2: #06d6a0;
      --group3: #ef476f;
      --group4: #118ab2;
      --group5: #f78c6b;
      --group6: #8ac926;
      --group7: #c77dff;
      --group8: #00c2ff;
      --group9: #ff70a6;
      --group10:#83f28f;
      --group11:#ffd670;
      --group12:#80ed99;
    }
    body[data-theme="dark"] {
      --bg: #111111;
      --fg: #f2f2f2;
      --muted: #cccccc;
      --soft: #1a1a1a;
      --border: #3a3a3a;
      --accent: #70b0ff;
      --accent-2: #ff9f5c;
      --good: #41d18e;
      --bad: #ff6b6b;
      --hint: #6fd3c8;
      --code-bg: #0f1623;
      --chip-bg: #182235;
      --selection: #254067;
      --link: #8bd1ff;

      --hl-match-bg: rgba(112, 176, 255, 0.18);
      --hl-match-border: rgba(112, 176, 255, 0.65);
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    }
    * { box-sizing: border-box; }
    a { color: var(--link); text-decoration: underline; }
    ::selection { background: var(--selection); color: var(--fg); }

    /* Layout: Two columns ≥ 1100px; stacked on narrow screens.
       Fit within 1280x720: keep top controls compact and sticky.
    */
    .container {
      max-width: 1280px;
      margin: 0 auto;
      padding: 8px 12px;
    }
    .topbar {
      position: sticky;
      top: 0;
      z-index: 100;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      padding: 8px 0;
    }
    .row {
      display: grid;
      gap: 12px;
    }
    .row.cols-2 {
      grid-template-columns: 1fr;
    }
    @media (min-width: 1100px) {
      .row.cols-2 {
        grid-template-columns: 1.1fr 0.9fr;
      }
    }

    /* Panel (flat) */
    .panel {
      border: 1px solid var(--border);
      background: var(--bg);
      padding: 8px;
    }
    .panel h2, .panel h3 {
      margin: 0 0 6px 0;
      font-size: 16px;
      font-weight: 700;
      color: var(--fg);
    }
    .subtle {
      font-size: 12px;
      color: var(--muted);
    }

    /* Controls */
    .control-bar {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items: center;
    }
    .controls-left {
      display: grid;
      gap: 6px;
    }
    .controls-right {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }
    .status-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .status-badge {
      padding: 6px 10px;
      border: 1px solid var(--border);
      background: var(--chip-bg);
      color: var(--fg);
      font-size: 12px;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .chip {
      min-height: 44px;
      padding: 0 12px;
      border: 1px solid var(--border);
      background: var(--chip-bg);
      color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      cursor: pointer;
    }
    .chip[aria-pressed="true"] {
      outline: 2px solid var(--accent);
    }

    .field-row {
      display: grid;
      grid-template-columns: 80px 1fr auto;
      gap: 8px;
      align-items: center;
    }
    label { font-weight: 600; font-size: 14px; }
    input[type="text"], textarea {
      width: 100%;
      min-height: 44px;
      border: 1px solid var(--border);
      background: var(--code-bg);
      color: var(--fg);
      padding: 8px 10px;
      font-size: 14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
    textarea { min-height: 180px; resize: vertical; white-space: pre-wrap; }
    input:focus, textarea:focus, button:focus, .chip:focus, .toggle:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .btn, button {
      min-height: 44px;
      min-width: 44px;
      border: 1px solid var(--border);
      background: var(--soft);
      color: var(--fg);
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    .btn.primary {
      background: var(--accent);
      color: #ffffff;
      border-color: var(--accent);
    }
    .btn.linky { background: transparent; text-decoration: underline; border: none; padding: 8px; }
    .btn.danger { background: #fff0f0; border-color: var(--bad); color: var(--bad); }
    .btn.success { background: #f0fff3; border-color: var(--good); color: var(--good); }

    .inline-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .flags-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 12px;
      align-items: center;
    }
    .flag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border: 1px solid var(--border);
      background: var(--chip-bg);
      font-family: ui-monospace, monospace;
      font-size: 13px;
      min-height: 36px;
    }
    .flag input {
      width: 18px; height: 18px;
      accent-color: var(--accent);
    }
    .flag.active {
      background: #dfe9ff;
      border-color: var(--accent);
    }
    .flag-manual {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    #flagManual {
      width: 120px;
      min-height: 44px;
    }

    .error {
      display: none;
      border: 1px solid var(--bad);
      background: #ffe9ea;
      color: var(--fg);
      padding: 10px;
      margin-top: 8px;
    }
    .error.visible { display: block; }
    .error .msg { font-weight: 700; margin-bottom: 6px; }
    .error .pointer {
      margin-top: 6px;
      background: var(--code-bg);
      border: 1px solid var(--border);
      padding: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      line-height: 1.35;
      overflow: auto;
      white-space: pre-wrap;
    }
    .caret { color: var(--bad); white-space: pre; }

    .warn {
      display: none;
      border: 1px solid #e6a700;
      background: #fff7e6;
      color: var(--fg);
      padding: 8px;
      margin-top: 6px;
    }
    .warn.visible { display: block; }
    .ok {
      display: none;
      border: 1px solid var(--good);
      background: #f0fff3;
      color: var(--fg);
      padding: 8px;
      margin-top: 6px;
    }
    .ok.visible { display: block; }

    .help {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

    .highlight-pane {
      min-height: 150px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 14px;
      line-height: 1.45;
      background: var(--code-bg);
      border: 1px solid var(--border);
      padding: 12px;
      white-space: pre-wrap;
      overflow: auto;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 10px;
      margin-bottom: 8px;
    }
    .legend .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
      font-size: 12px;
      border: 1px dashed var(--border);
      padding: 4px 8px;
    }
    .legend .swatch {
      width: 14px;
      height: 14px;
      border: 1px solid var(--border);
      background: #ffffff;
    }

    .m {
      background: var(--hl-match-bg);
      border: 1px solid var(--hl-match-border);
      padding: 1px 2px;
      box-decoration-break: clone;
    }
    .m.zero {
      border-left: 2px solid var(--accent);
      padding: 0;
      margin: 0 1px;
      display: inline-block;
      height: 1em;
      vertical-align: text-bottom;
      background: transparent;
    }
    .g {
      padding: 0 1px;
      border: 1px dashed var(--border);
      box-decoration-break: clone;
    }
    .g-1  { background-color: color-mix(in oklab, var(--group1) 22%, transparent); }
    .g-2  { background-color: color-mix(in oklab, var(--group2) 22%, transparent); }
    .g-3  { background-color: color-mix(in oklab, var(--group3) 22%, transparent); }
    .g-4  { background-color: color-mix(in oklab, var(--group4) 22%, transparent); }
    .g-5  { background-color: color-mix(in oklab, var(--group5) 22%, transparent); }
    .g-6  { background-color: color-mix(in oklab, var(--group6) 22%, transparent); }
    .g-7  { background-color: color-mix(in oklab, var(--group7) 22%, transparent); }
    .g-8  { background-color: color-mix(in oklab, var(--group8) 22%, transparent); }
    .g-9  { background-color: color-mix(in oklab, var(--group9) 22%, transparent); }
    .g-10 { background-color: color-mix(in oklab, var(--group10) 22%, transparent); }
    .g-11 { background-color: color-mix(in oklab, var(--group11) 22%, transparent); }
    .g-12 { background-color: color-mix(in oklab, var(--group12) 22%, transparent); }

    table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid var(--border);
      background: var(--bg);
    }
    th, td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
      font-size: 13px;
    }
    thead th {
      font-size: 12px;
      color: var(--muted);
    }
    tbody tr:hover { background: rgba(0,0,0,0.05); }

    code {
      background: var(--code-bg);
      padding: 2px 4px;
      border: 1px solid var(--border);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
    }
    .sub {
      margin-top: 2px;
      color: var(--muted);
      font-size: 12px;
    }

    /* Sticky mini-header with quick actions */
    .window-bar {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      align-items: center;
      border-bottom: 1px solid var(--border);
      padding: 6px 0 8px 0;
    }
    .window-title { font-weight: 700; }
    .row-actions { display: flex; gap: 8px; }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      padding: 6px 10px;
      background: var(--soft);
      min-height: 44px;
    }
    .toggle input {
      width: 44px; height: 24px;
      background: var(--border);
      border: 1px solid var(--border);
    }

    /* Extras & banners */
    .inline-hint {
      border: 1px solid #1d5dff;
      background: #eef3ff;
      padding: 8px;
      margin-top: 6px;
      font-size: 12px;
    }
    .compat-note {
      border: 1px solid #e6a700;
      background: #fff7e6;
      padding: 8px;
      margin-top: 6px;
      font-size: 12px;
      display: none;
    }
    .compat-note.visible { display: block; }

    .danger-border { border-color: var(--bad) !important; }
    .accent-border { border-color: var(--accent) !important; }

    /* Collapsible explanation */
    .collapse-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 6px;
    }
    .collapse-body[hidden] { display: none; }

    .footer-note { color: var(--muted); font-size: 12px; padding: 6px 0; text-align: right; }

    /* Invisible proxies but visible text for automation */
    .proxies { margin-top: 8px; }
    .proxy { font-size: 12px; color: var(--muted); }
  </style>
</head>
<body data-theme="light">
  <div class="container">
    <div class="topbar">
      <div class="window-bar">
        <div class="window-title">Regex Playground</div>
        <div class="status-badges">
          <span class="status-badge" id="matchCount">0 matches</span>
          <span class="status-badge" id="flagStatus">Flags: —</span>
          <span class="status-badge" id="perfStatus">—</span>
        </div>
        <div class="row-actions">
          <button id="copyLinkBtn" title="Copy permalink with pattern + flags" class="btn">Copy link</button>
          <button id="clearBtn" title="Clear pattern and text" class="btn danger">Clear</button>
          <div class="toggle" title="Toggle light/dark theme">
            <label for="themeToggle">Theme</label>
            <input type="checkbox" id="themeToggle" aria-label="Toggle theme">
          </div>
        </div>
      </div>
      <div class="help" id="keyboardHint">Press Enter in Pattern or Test Text to apply. Shift+Click a chip to replace the entire pattern.</div>
    </div>

    <div class="row cols-2" id="mainGrid">
      <section class="panel" aria-labelledby="patternLabel" id="leftControls">
        <h2 id="patternLabel">Pattern, Flags, and Test Text</h2>

        <div class="controls-left">
          <!-- Pattern row -->
          <div class="field-row">
            <label for="regexPattern">Pattern</label>
            <input id="regexPattern" type="text" inputmode="latin" spellcheck="false" placeholder="Enter regex pattern (e.g., (\\w+)@(\\w+\\.)+\\w+). Try lookarounds: (?=...), (?!...), (?<=...), (?<!...)" aria-describedby="patternHelp patternTips">
            <div class="inline-actions">
              <button id="applyBtn" class="btn primary" title="Apply pattern and flags now">Apply</button>
              <button id="clearPatternBtn" class="btn" title="Clear only the pattern">Clear Pattern</button>
            </div>
          </div>
          <div class="help" id="patternHelp">Hint: For multi-line dot matches, enable the s flag (DotAll). For word boundaries, try \b. For named groups, use (?&lt;name&gt;...). Backreference: \k&lt;name&gt; or \1.</div>

          <!-- Quick inserts toolbar -->
          <div class="toolbar" role="group" aria-label="Quick inserts" id="patternToolbar">
            <button class="chip" data-insert="\\d" id="insertDigit" title="Digit class \d">\\d</button>
            <button class="chip" data-insert="\\w" id="insertWord" title="Word char \w">\\w</button>
            <button class="chip" data-insert="\\s" id="insertSpace" title="Whitespace \s">\\s</button>
            <button class="chip" data-insert="[A-Z]" id="insertAtoZ" title="A..Z range">[A-Z]</button>
            <button class="chip" data-insert="[a-z]" id="insertatoz" title="a..z range">[a-z]</button>
            <button class="chip" data-insert="[0-9]" id="insertZeroNine" title="0..9 range">[0-9]</button>
            <button class="chip" data-insert="." id="insertDot" title="Any char except newline">.</button>
            <button class="chip" data-insert="\\b" id="insertBoundary" title="Word boundary \b">\\b</button>
            <button class="chip" data-insert="^" id="insertStart" title="Start anchor ^">^</button>
            <button class="chip" data-insert="$" id="insertEnd" title="End anchor $">$</button>
            <button class="chip" data-insert="($1)" id="insertGroup" title="Capturing group">(…)</button>
            <button class="chip" data-insert="(?:$1)" id="insertNonCap" title="Non-capturing group">(?:…)</button>
            <button class="chip" data-insert="(foo|bar)" id="insertAlt" title="Alternation group">(foo|bar)</button>
            <button class="chip" data-insert="(?=$1)" id="insertLookahead" title="Positive lookahead (?=...)">(?=…)</button>
            <button class="chip" data-insert="(?!$1)" id="insertNLookahead" title="Negative lookahead (?!...)">(?!…)</button>
            <button class="chip" data-insert="(?<=$1)" id="insertLookbehind" title="Positive lookbehind (?&lt;=...)">(?&lt;=…)</button>
            <button class="chip" data-insert="(?<!$1)" id="insertNLookbehind" title="Negative lookbehind (?&lt;!...)">(?&lt;!…)</button>
            <button class="chip" data-insert="*" id="insertQuant0" title="Zero or more *">*</button>
            <button class="chip" data-insert="+" id="insertQuant1" title="One or more +">+</button>
            <button class="chip" data-insert="?" id="insertQuantQ" title="Zero or one ?">?</button>
            <button class="chip" data-insert="{m,n}" id="insertQuantRange" title="Custom quantifier {m,n}">{m,n}</button>
          </div>
          <div class="inline-hint" id="quickInsertHint" hidden>Snippet inserted at caret. Hold Shift and click a chip to replace the entire pattern.</div>
          <div class="warn" id="insertPrompt" hidden>Pattern is not empty. Replace entire pattern with the clicked snippet?
            <div class="inline-actions" style="margin-top:6px;">
              <button id="replacePatternBtn" class="btn danger">Replace</button>
              <button id="insertAtCaretBtn" class="btn">Insert at caret</button>
              <button id="cancelInsertBtn" class="btn">Cancel</button>
            </div>
          </div>

          <!-- Flags -->
          <div class="field-row" style="grid-template-columns: 80px 1fr;">
            <label for="flagsGroup">Flags</label>
            <div class="flags-group" id="flagsGroup">
              <label class="flag" title="Global search">
                <input type="checkbox" id="flagG"> g
              </label>
              <label class="flag" title="Ignore case">
                <input type="checkbox" id="flagI"> i
              </label>
              <label class="flag" title="Multiline ^ $ match line boundaries">
                <input type="checkbox" id="flagM"> m
              </label>
              <label class="flag" title="Dot matches newline (DotAll)">
                <input type="checkbox" id="flagS"> s
              </label>
              <label class="flag" title="Unicode mode (required for \\p{} Unicode properties)">
                <input type="checkbox" id="flagU"> u
              </label>
              <label class="flag" title="Sticky (match from lastIndex only)">
                <input type="checkbox" id="flagY"> y
              </label>
              <span class="flag-manual">
                <label for="flagManual" style="font-weight:600;">Manual</label>
                <input id="flagManual" type="text" inputmode="latin" spellcheck="false" placeholder="e.g., gim or z">
              </span>
            </div>
          </div>
          <div id="flagError" class="error" role="alert" aria-live="polite">
            <div class="msg">Invalid flags</div>
            <div>Tip: Valid flags are g, i, m, s, u, y. Manual flags let you experiment; invalid flags will block matching.</div>
          </div>
          <div class="help" id="patternTips">Tip: If your pattern contains .*, you might need s (DotAll) for multi-line matches. If you use Unicode properties like \p{L}, enable the u flag.</div>
          <div class="compat-note" id="compatNote">Compatibility: Unicode property escapes (\\p{…}, \\P{…}) require the u flag in JavaScript RegExp.</div>

          <!-- Error pane (must exist and be visible for parse errors) -->
          <div id="errorPane" class="error" role="alert" aria-live="polite">
            <div class="msg" id="errorMessage">Invalid regular expression</div>
            <div class="pointer">
              <div><code id="errorPatternCode"></code></div>
              <div class="caret" id="errorCaret"></div>
            </div>
          </div>

          <!-- Test Text -->
          <div class="field-row" style="grid-template-columns: 80px 1fr;">
            <label for="testText">Test Text</label>
            <textarea id="testText" placeholder="Paste or type the text to test against the pattern...">The quick brown fox jumps over 13 lazy dogs.
Email: alice@example.com, bob.smith@sub.domain.org
Dates: 2024-07-31, 31/07/2024
IPs: 127.0.0.1 and 2001:0db8:85a3::8a2e:0370:7334
ABC xyz</textarea>
          </div>
          <div class="inline-actions">
            <button class="btn" id="selectAllPatternBtn" title="Select pattern text">Select Pattern</button>
            <button class="btn" id="selectAllTextBtn" title="Select test text">Select Test Text</button>
          </div>

          <!-- Additional helper banners -->
          <div class="ok" id="liveStatusOk">Pattern applied successfully.</div>
          <div class="warn" id="noMatchHint">No matches found. Try enabling flags or adjusting your pattern.</div>
        </div>
      </section>

      <section class="panel" aria-labelledby="resultsLabel" id="rightResults">
        <h2 id="resultsLabel">Results</h2>

        <div class="panel" style="margin-bottom: 8px;">
          <h3>Highlighted Matches</h3>
          <div class="legend" id="legend"></div>
          <div id="highlightPane" class="highlight-pane" aria-live="polite"></div>
        </div>

        <div class="panel" style="margin-bottom: 8px;">
          <div class="collapse-header">
            <h3>Explanation</h3>
            <button id="explainToggle" class="btn" aria-expanded="false" aria-controls="explainContainer">Show</button>
          </div>
          <div id="explainContainer" class="collapse-body" hidden>
            <div id="explanationPane" class="highlight-pane" style="min-height: 150px;"></div>
          </div>
        </div>

        <div class="panel">
          <h3>Matches Table</h3>
          <div style="max-height: 300px; overflow: auto;">
            <table id="matchesTable" aria-live="polite">
              <thead id="matchesThead"></thead>
              <tbody id="matchesTbody"></tbody>
            </table>
          </div>
        </div>

        <div class="footer-note">Built with vanilla JavaScript. No data leaves your browser.</div>

        <!-- Proxies for automation visibility -->
        <div class="proxies">
          <div id="resultStatus" class="proxy">idle</div>
          <div id="applyStatus" class="proxy">idle</div>
          <div id="activeSection" class="proxy">Main</div>
          <div id="themeStatus" class="proxy">light</div>
          <div id="copyStatus" class="proxy">idle</div>
          <div id="previewStatus" class="proxy">idle</div>
          <div id="tableStatus" class="proxy">empty</div>
        </div>
      </section>
    </div>

    <!-- Long, explicit inline documentation to aid discovery and provide rich content (also ensures file length) -->
    <section class="panel" id="docs">
      <h2>Regex Notes & Reference</h2>
      <div class="help">
        This playground supports most JavaScript regular expression features. Key points:
        - Capturing groups: ( ... ), Non-capturing: (?: ... ), Named: (?&lt;name&gt; ... ).
        - Lookarounds: (?=...), (?!...), (?&lt;=...), (?&lt;!...).
        - Character classes: \d, \w, \s, and custom classes like [A-Za-z0-9_].
        - Anchors: ^ and $; with the m flag they match line boundaries.
        - DotAll (s flag): makes . match newline characters.
        - Unicode (u flag): enables full Unicode mode and is required for \p{...} property escapes.
        - Sticky (y flag): anchoring matches at lastIndex.
        - Global (g flag): find all matches; without g, only the first match is used.
        - Backreferences: \1, \2, ... and \k&lt;name&gt; for named groups.
      </div>

      <div class="help" aria-live="polite">
        Tip: Zero-width matches are indicated by small vertical markers in the Highlighted Matches area. These happen with lookarounds or with patterns that can match empty strings.
      </div>

      <div class="help">
        Flags quick reference:
        - g (Global): find all matches.
        - i (Ignore case): case-insensitive matching.
        - m (Multiline): ^ and $ match line boundaries within the text.
        - s (DotAll): dot matches newline characters.
        - u (Unicode): full Unicode support; needed for \p{...} properties.
        - y (Sticky): match must start at lastIndex.
      </div>

      <div class="help">
        Example patterns to try:
        - Emails: (?&lt;user&gt;[\\w.+-]+)@(?&lt;host&gt;[\\w.-]+\\.[A-Za-z]{2,})
        - Dates: (\\d{4})-(\\d{2})-(\\d{2}) or (\\d{2})/(\\d{2})/(\\d{4})
        - IPv4: \\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\b
        - Hex color: #([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})\\b
        - Word boundaries: \\b[A-Za-z]+\\b
        - Named backreference: (?&lt;word&gt;\\w+)\\s+\\k&lt;word&gt;
      </div>

      <div class="help">
        Performance note: some patterns can cause catastrophic backtracking on certain inputs. If the interface becomes slow, simplify your pattern or add anchors/quantifier restrictions.
      </div>
    </section>
  </div>

  <script>
    (function() {
      'use strict';

      // Elements (kept stable for compatibility)
      const elPattern = document.getElementById('regexPattern');
      const elTest = document.getElementById('testText');
      const elHighlight = document.getElementById('highlightPane');
      const elLegend = document.getElementById('legend');
      const elMatchesThead = document.getElementById('matchesThead');
      const elMatchesTbody = document.getElementById('matchesTbody');
      const elExplanation = document.getElementById('explanationPane');
      const elError = document.getElementById('errorPane');
      const elErrorMsg = document.getElementById('errorMessage');
      const elErrorCode = document.getElementById('errorPatternCode');
      const elErrorCaret = document.getElementById('errorCaret');
      const elCopyLink = document.getElementById('copyLinkBtn');
      const elClear = document.getElementById('clearBtn');
      const elThemeToggle = document.getElementById('themeToggle');
      const elMatchCount = document.getElementById('matchCount');
      const elFlagStatus = document.getElementById('flagStatus');
      const elPerfStatus = document.getElementById('perfStatus');

      // Additional elements for improved UX
      const elApply = document.getElementById('applyBtn');
      const elClearPattern = document.getElementById('clearPatternBtn');
      const elSelectPattern = document.getElementById('selectAllPatternBtn');
      const elSelectText = document.getElementById('selectAllTextBtn');
      const elExplainToggle = document.getElementById('explainToggle');
      const elExplainContainer = document.getElementById('explainContainer');
      const elQuickInsertHint = document.getElementById('quickInsertHint');
      const elInsertPrompt = document.getElementById('insertPrompt');
      const elReplacePatternBtn = document.getElementById('replacePatternBtn');
      const elInsertAtCaretBtn = document.getElementById('insertAtCaretBtn');
      const elCancelInsertBtn = document.getElementById('cancelInsertBtn');
      const elCompatNote = document.getElementById('compatNote');
      const elFlagError = document.getElementById('flagError');
      const elLiveOk = document.getElementById('liveStatusOk');
      const elNoMatchHint = document.getElementById('noMatchHint');

      const elResultStatus = document.getElementById('resultStatus');
      const elApplyStatus = document.getElementById('applyStatus');
      const elActiveSection = document.getElementById('activeSection');
      const elThemeStatus = document.getElementById('themeStatus');
      const elCopyStatus = document.getElementById('copyStatus');
      const elPreviewStatus = document.getElementById('previewStatus');
      const elTableStatus = document.getElementById('tableStatus');

      const flagsEls = {
        g: document.getElementById('flagG'),
        i: document.getElementById('flagI'),
        m: document.getElementById('flagM'),
        s: document.getElementById('flagS'),
        u: document.getElementById('flagU'),
        y: document.getElementById('flagY'),
      };
      const elFlagManual = document.getElementById('flagManual');

      // Feature detect RegExp indices 'd'
      let supportsIndices = true;
      try { new RegExp('', 'd'); } catch { supportsIndices = false; }

      // State flags
      let manualEdited = false; // whether user typed in pattern
      let lastChipInsert = '';  // store last chip snippet
      let pendingChip = null;   // for prompt

      // Helpers
      const escapeHtml = (s) => String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
      const byId = id => document.getElementById(id);

      // Keep API (do not remove or rename)
      function getFlagsString() {
        const order = ['g','i','m','s','u','y'];
        const checkboxFlags = order.filter(f => flagsEls[f].checked).join('');
        const manual = (elFlagManual.value || '').trim();
        // Merge, preserving first occurrence (including invalid flags)
        const seen = new Set();
        const mergedChars = (checkboxFlags + manual).split('');
        const out = [];
        for (const ch of mergedChars) {
          if (!seen.has(ch)) { seen.add(ch); out.push(ch); }
        }
        return out.join('');
      }

      function setFlagsFromString(str) {
        const order = ['g','i','m','s','u','y'];
        order.forEach(f => flagsEls[f].checked = (typeof str === 'string' && str.includes(f)));
        // Put remaining non-checkbox flags (including invalid) into manual
        const remaining = (str || '').split('').filter(ch => !order.includes(ch));
        elFlagManual.value = remaining.join('');
        // Reflect active state visually
        reflectActiveFlags();
      }

      // Insert at cursor for pattern input (Keep API)
      function insertAtCursor(text, placeholder = '$1') {
        const el = elPattern;
        el.focus();
        const start = el.selectionStart ?? el.value.length;
        const end = el.selectionEnd ?? el.value.length;

        let insertText = text;
        let sel = el.value.slice(start, end);
        if (text.includes('$1')) {
          insertText = text.replace('$1', sel || '');
          const offset = text.indexOf('$1');
          const caretPos = start + offset + (sel ? sel.length : 0);
          const newVal = el.value.slice(0, start) + insertText + el.value.slice(end);
          el.value = newVal;
          el.setSelectionRange(caretPos, caretPos);
        } else {
          const newVal = el.value.slice(0, start) + insertText + el.value.slice(end);
          const caretPos = start + insertText.length;
          el.value = newVal;
          el.setSelectionRange(caretPos, caretPos);
        }
        manualEdited = true;
        showQuickInsertFlash();
        scheduleUpdate();
        el.scrollIntoView({ block: 'center', behavior: 'instant' });
      }

      // Build legend (Keep API)
      function buildLegend(maxGroups, groupNames) {
        const el = elLegend;
        if (!maxGroups) { el.innerHTML = ''; return; }
        let html = '';
        for (let i = 1; i <= Math.min(maxGroups, 12); i++) {
          const name = groupNames && groupNames[i] ? ` (${escapeHtml(groupNames[i])})` : '';
          html += `<span class="legend-item"><span class="swatch g-${i}"></span> Group ${i}${name}</span>`;
        }
        el.innerHTML = html;
      }

      // Advance index (Keep API)
      function advanceIndex(text, lastIndex, unicode) {
        if (lastIndex >= text.length) return lastIndex + 1;
        if (!unicode) return lastIndex + 1;
        const code = text.codePointAt(lastIndex);
        return lastIndex + (code > 0xFFFF ? 2 : 1);
      }

      // Try build RegExp (Keep API)
      function tryBuildRegExp(source, flags) {
        return new RegExp(source, flags);
      }

      // Validate flags (Keep API)
      function validateFlags(flags) {
        try { new RegExp('', flags); return null; }
        catch (e) { return e && e.message || 'Invalid flags'; }
      }

      // Approx error index (Keep API)
      function findErrorIndex(pattern, flags) {
        let prevOk = 0;
        for (let i = 1; i <= pattern.length; i++) {
          try {
            new RegExp(pattern.slice(0, i), flags);
            prevOk = i;
          } catch (e) {
            return i - 1;
          }
        }
        try {
          new RegExp(pattern, flags);
          return -1;
        } catch {
          return Math.max(0, pattern.length - 1);
        }
      }

      // Error display (Keep API)
      function showError(message, pattern, caretIndex) {
        elError.classList.add('visible');
        elErrorMsg.textContent = message;
        elErrorCode.innerHTML = escapeHtml(pattern);
        if (caretIndex >= 0) {
          const spaces = ' '.repeat(Math.max(0, caretIndex));
          elErrorCaret.textContent = spaces + '^';
          try {
            elPattern.focus();
            elPattern.setSelectionRange(Math.max(0, caretIndex), Math.max(0, caretIndex));
            elPattern.classList.add('danger-border');
          } catch {}
        } else {
          elErrorCaret.textContent = '';
        }
        elResultStatus.textContent = 'error';
        elPreviewStatus.textContent = 'idle';
        elTableStatus.textContent = 'empty';
      }

      function hideError() {
        elError.classList.remove('visible');
        elErrorMsg.textContent = '';
        elErrorCode.textContent = '';
        elErrorCaret.textContent = '';
        elPattern.classList.remove('danger-border');
      }

      // Highlighted HTML (Keep API)
      function buildHighlightedHTML(text, matches) {
        if (!matches || matches.length === 0) return escapeHtml(text);

        let cur = 0;
        let html = '';
        for (const m of matches) {
          const start = m.start;
          const end = m.end;
          if (start > cur) html += escapeHtml(text.slice(cur, start));
          if (end === start) {
            html += `<span class="m zero" title="Zero-length match">&#8203;</span>`;
          } else {
            const seg = text.slice(start, end);
            html += renderMatchSegment(seg, m.groupRanges, start);
          }
          cur = end;
        }
        if (cur < text.length) {
          html += escapeHtml(text.slice(cur));
        }
        return html;
      }

      // Render match segment with group outlines (Keep API with inner helpers names preserved)
      function renderMatchSegment(segmentText, groupRanges, absStart) {
        const L = segmentText.length;
        const opens = new Map();
        const closes = new Map();
        for (const gr of (groupRanges || [])) {
          const relStart = Math.max(0, gr.start - absStart);
          const relEnd = Math.min(L, gr.end - absStart);
          if (relStart < 0 || relEnd < 0 || relStart > L || relEnd > L) continue;
          if (!opens.has(relStart)) opens.set(relStart, []);
          opens.get(relStart).push(gr.g);
          if (!closes.has(relEnd)) closes.set(relEnd, []);
          closes.get(relEnd).push(gr.g);
        }

        let result = `<span class="m">`;
        const positions = new Set([0, L]);
        opens.forEach((_, k) => positions.add(k));
        closes.forEach((_, k) => positions.add(k));
        const sorted = Array.from(positions).sort((a,b)=>a-b);
        const openStack = [];

        function closeGroupsAt(pos) {
          const list = (closes.get(pos) || []).slice();
          if (!list.length) return;
          while (openStack.length) {
            const top = openStack[openStack.length - 1];
            const idx = list.indexOf(top);
            if (idx !== -1) {
              result += `</span>`;
              openStack.pop();
              list.splice(idx, 1);
            } else {
              break;
            }
          }
          if (list.length) {
            list.sort((a,b) => b-a).forEach(() => { result += `</span>`; });
          }
        }

        function openGroupsAt(pos) {
          const list = (opens.get(pos) || []).slice().sort((a,b)=>a-b);
          for (const g of list) {
            result += `<span class="g g-${g}" title="Group ${g}">`;
            openStack.push(g);
          }
        }

        for (let i = 0; i < sorted.length - 1; i++) {
          const pos = sorted[i];
          const next = sorted[i+1];
          closeGroupsAt(pos);
          openGroupsAt(pos);
          if (next > pos) {
            result += escapeHtml(segmentText.slice(pos, next));
          }
        }

        while (openStack.length) { result += `</span>`; openStack.pop(); }
        result += `</span>`;
        return result;
      }

      // Matches + highlight (Keep API)
      function buildMatchesAndHighlight(pattern, flags, text) {
        // Validate flags first
        const flagErr = validateFlags(flags);
        if (flagErr) {
          // Set flag error state and block.
          setFlagError(flagErr);
          showError(flagErr, pattern, -1);
          return { error: flagErr };
        } else {
          clearFlagError();
        }

        // Try build regexp
        let re, reD = null;
        try {
          re = tryBuildRegExp(pattern, flags);
        } catch (e) {
          const idx = findErrorIndex(pattern, flags);
          const msg = (e && e.message) ? e.message : 'Invalid regular expression';
          showError(msg, pattern, idx);
          return { error: msg };
        }

        hideError();

        // Attempt indices-enabled regex
        if (supportsIndices) {
          try {
            reD = tryBuildRegExp(pattern, flags + (flags.includes('d') ? '' : 'd'));
          } catch {
            reD = null;
          }
        }

        const textStr = String(text ?? '');
        const doGlobal = flags.includes('g');
        const hasUnicode = flags.includes('u');

        let matches = [];
        let m, md;
        re.lastIndex = 0;
        if (reD) reD.lastIndex = 0;
        const t0 = performance.now();

        while (true) {
          m = re.exec(textStr);
          if (!m) break;
          if (reD) { md = reD.exec(textStr); }
          const start = m.index;
          const fullText = m[0];
          const end = start + fullText.length;

          // Build group ranges from md.indices
          let groupRanges = [];
          let groupNames = {};
          if (reD && md && md.indices) {
            const arr = md.indices;
            if (arr && Array.isArray(arr)) {
              for (let gi = 1; gi < arr.length; gi++) {
                const span = arr[gi];
                if (!span) continue;
                const gs = span[0], ge = span[1];
                if (gs === null || ge === null) continue;
                groupRanges.push({ g: gi, start: gs, end: ge });
              }
            }
            if (md.indices && md.indices.groups) {
              groupNames = Object.assign({}, md.indices.groups);
            }
          }

          matches.push({
            start, end, text: fullText,
            groups: Array.from(m).slice(1),
            named: m.groups || {},
            groupRanges,
            groupsIndexPairs: (reD && md && md.indices) ? md.indices : null
          });

          if (!doGlobal) break;

          if (fullText === '') {
            const nextIndex = advanceIndex(textStr, re.lastIndex, hasUnicode);
            re.lastIndex = nextIndex;
            if (reD) reD.lastIndex = nextIndex;
          }
        }

        const t1 = performance.now();

        const highlightHtml = buildHighlightedHTML(textStr, matches);
        const perf = Math.max(0, t1 - t0);

        return { matches, highlightHtml, elapsed: perf };
      }

      // Build matches table (Keep API)
      function buildMatchesTable(matches) {
        if (!matches || matches.length === 0) {
          elMatchesThead.innerHTML = '';
          elMatchesTbody.innerHTML = '';
          elTableStatus.textContent = 'empty';
          return { maxGroups: 0, groupNames: null };
        }
        let maxGroups = 0;
        let namesByIndex = {};

        for (const m of matches) {
          const gCount = m.groups ? m.groups.length : 0;
          if (gCount > maxGroups) maxGroups = gCount;
        }

        // Map named groups to numeric indices (if possible) using indices ranges
        const nameIndexMap = {};
        for (const m of matches) {
          if (!m.named || Object.keys(m.named).length === 0) continue;
          const named = m.named;
          const arr = m.groupsIndexPairs;
          if (arr && arr.groups) {
            const groupObj = arr.groups; // name -> [s,e]
            if (Array.isArray(arr)) {
              for (let gi = 1; gi < arr.length; gi++) {
                const rng = arr[gi];
                if (!rng) continue;
                const [gs, ge] = rng;
                for (const nm in groupObj) {
                  const [ns, ne] = groupObj[nm] || [];
                  if (gs === ns && ge === ne) {
                    nameIndexMap[gi] = nm;
                  }
                }
              }
            }
          } else {
            const gVals = m.groups || [];
            for (const nm in named) {
              const val = named[nm];
              for (let gi = 0; gi < gVals.length; gi++) {
                if (nameIndexMap[gi+1]) continue;
                if (gVals[gi] === val) {
                  nameIndexMap[gi+1] = nm;
                  break;
                }
              }
            }
          }
          if (Object.keys(nameIndexMap).length >= maxGroups) break;
        }
        namesByIndex = nameIndexMap;

        // Header
        let th = `<tr>
          <th>#</th>
          <th>Index</th>
          <th>End</th>
          <th>Match</th>`;
        for (let i = 1; i <= maxGroups; i++) {
          const name = namesByIndex[i] ? ` (${escapeHtml(namesByIndex[i])})` : '';
          th += `<th>G${i}${name}</th>`;
        }
        th += `</tr>`;
        elMatchesThead.innerHTML = th;

        // Rows
        const rows = [];
        for (let mi = 0; mi < matches.length; mi++) {
          const m = matches[mi];
          const idx = m.start;
          const end = m.end;
          const matchText = m.text;
          let row = `<tr>
            <td>${mi + 1}</td>
            <td>${idx}</td>
            <td>${end}</td>
            <td><code>${escapeHtml(matchText)}</code><div class="sub">len ${matchText.length}</div></td>`;
          const groups = m.groups || [];
          const indicesArr = m.groupsIndexPairs;
          for (let gi = 1; gi <= maxGroups; gi++) {
            const val = groups[gi - 1];
            let sub = '—';
            if (indicesArr && indicesArr[gi]) {
              const [gs, ge] = indicesArr[gi];
              if (gs !== null && ge !== null) sub = `[${gs}, ${ge}]`;
            }
            const display = (val === undefined || val === null) ? '—' : `<code>${escapeHtml(String(val))}</code>`;
            row += `<td>${display}<div class="sub">${sub}</div></td>`;
          }
          row += `</tr>`;
          rows.push(row);
        }
        elMatchesTbody.innerHTML = rows.join('');
        elTableStatus.textContent = 'ready';
        return { maxGroups, groupNames: namesByIndex };
      }

      // Explain flags (Keep API)
      function explainFlags(flags) {
        if (!flags) return 'No flags';
        const map = {
          g: 'Global: find all matches',
          i: 'Ignore case: case-insensitive',
          m: 'Multiline: ^/$ match line boundaries',
          s: 'DotAll: dot matches newline',
          u: 'Unicode: full Unicode support',
          y: 'Sticky: match at lastIndex only'
        };
        const items = flags.split('').map(f => map[f]).filter(Boolean);
        return items.join(' • ');
      }

      // Explain pattern (Keep API and expose token helpers within)
      function explainPattern(pattern, flags) {
        const parts = [];
        const p = pattern;
        let i = 0;
        let inClass = false;

        function push(token, desc) {
          parts.push(`<li><code>${escapeHtml(token)}</code> — ${escapeHtml(desc)}</li>`);
        }

        function readEscape() {
          const ch = p[i+1];
          if (ch === undefined) { push('\\', 'Backslash'); i++; return; }
          const two = '\\' + ch;
          switch (ch) {
            case 'd': push('\\d', 'Digit [0-9]'); i += 2; return;
            case 'D': push('\\D', 'Non-digit [^0-9]'); i += 2; return;
            case 'w': push('\\w', 'Word char [A-Za-z0-9_]'); i += 2; return;
            case 'W': push('\\W', 'Non-word char [^A-Za-z0-9_]'); i += 2; return;
            case 's': push('\\s', 'Whitespace'); i += 2; return;
            case 'S': push('\\S', 'Non-whitespace'); i += 2; return;
            case 'b': push('\\b', 'Word boundary (zero-width)'); i += 2; return;
            case 'B': push('\\B', 'Non-word boundary (zero-width)'); i += 2; return;
            case 't': push('\\t', 'Tab'); i += 2; return;
            case 'n': push('\\n', 'Newline'); i += 2; return;
            case 'r': push('\\r', 'Carriage return'); i += 2; return;
            case 'f': push('\\f', 'Form feed'); i += 2; return;
            case 'v': push('\\v', 'Vertical tab'); i += 2; return;
            case '0': push('\\0', 'Null byte'); i += 2; return;
            case 'x': {
              const hex = p.slice(i+2, i+4);
              push('\\x' + hex, 'Hex escape');
              i += 2 + Math.min(2, hex.length);
              return;
            }
            case 'u': {
              if (p[i+2] === '{') {
                const end = p.indexOf('}', i+3);
                const body = end !== -1 ? p.slice(i+3, end) : '';
                push('\\u{' + body + '}', 'Unicode code point');
                i = (end !== -1 ? end + 1 : i + 2);
              } else {
                const hex = p.slice(i+2, i+6);
                push('\\u' + hex, 'Unicode escape');
                i += 2 + Math.min(4, hex.length);
              }
              return;
            }
            case 'k': {
              const m = p.slice(i).match(/^\\k<([A-Za-z_][A-Za-z0-9_]*)>/);
              if (m) {
                push(m[0], `Backreference to named group "${m[1]}"`);
                i += m[0].length;
                return;
              }
              push(two, 'Backreference (named)'); i+=2; return;
            }
            default: {
              const m = p.slice(i).match(/^\\([1-9][0-9]*)/);
              if (m) {
                push(m[0], `Backreference to group ${m[1]}`);
                i += m[0].length;
                return;
              }
              push(two, 'Escaped char');
              i += 2;
              return;
            }
          }
        }

        function readCharClass() {
          const start = i;
          i++; // skip [
          let escaped = false;
          while (i < p.length) {
            const ch = p[i];
            if (!escaped && ch === ']') { i++; break; }
            if (!escaped && ch === '\\') { escaped = true; i++; continue; }
            escaped = false;
            i++;
          }
          const token = p.slice(start, i);
          if (token.startsWith('[^')) {
            push(token, 'Negated character class');
          } else {
            push(token, 'Character class');
          }
        }

        function readGroupOrAssertion() {
          const ahead = p.slice(i);
          const m =
            ahead.match(/^\(\?:/) ? 'noncap' :
            ahead.match(/^\(\?=|^\(\?!/) ? 'lookahead' :
            ahead.match(/^\(\?<=|^\(\?<!/) ? 'lookbehind' :
            ahead.match(/^\(\?<([A-Za-z_][A-Za-z0-9_]*)>/) ? 'named' :
            'cap';

          if (m === 'noncap') { push('(?:', 'Start non-capturing group'); i += 3; return; }
          if (m === 'lookahead') {
            const token = ahead.startsWith('(?=') ? '(?=' : '(?!';
            const desc = token === '(?=' ? 'Start positive lookahead (zero-width)' : 'Start negative lookahead (zero-width)';
            push(token, desc); i += 3; return;
          }
          if (m === 'lookbehind') {
            const token = ahead.startsWith('(?<=') ? '(?<=' : '(?<!';
            const desc = token === '(?<=' ? 'Start positive lookbehind (zero-width)' : 'Start negative lookbehind (zero-width)';
            push(token, desc); i += 4; return;
          }
          const named = ahead.match(/^\(\?<([A-Za-z_][A-Za-z0-9_]*)>/);
          if (named) { push(named[0], `Start named capturing group "${named[1]}"`); i += named[0].length; return; }
          push('(', 'Start capturing group'); i += 1; return;
        }

        function
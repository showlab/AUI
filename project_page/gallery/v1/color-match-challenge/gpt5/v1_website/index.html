<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Color Match — Fast-Paced Stroop Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="A fast-paced color match (Stroop effect) game. Click the button that matches the word's font color, not its meaning, and score as much as you can in 30 seconds." />
  <style>
    /* 
      Color Match — Destylized, Operator-Friendly UI
      - White background, black text
      - No gradients, shadows, rounded corners, or decorative animations
      - High-contrast, large targets (≥44px)
      - Controls remain visible in 1280×720
      - Clear, deterministic interactions with visible status proxies
    */

    :root{
      --bg: #ffffff;
      --text: #000000;
      --muted: #333333;
      --accent: #0a58ff; /* Used sparingly for focus and emphasis */
      --good: #0a7f2e;
      --bad: #bd2222;
      --border: #cccccc;
      --panel: #f5f5f5;
      --panel-strong: #e6e6e6;
      --btn-height: 56px;
      --min-touch: 44px;
      --gap: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing: border-box }
    html, body{ height:100% }
    body{
      margin: 0;
      font-family: var(--font);
      color: var(--text);
      background: var(--bg);
    }

    /* Layout */
    .container{
      width: min(1100px, 96vw);
      margin: 0 auto;
      padding: 16px;
      display: grid;
      grid-template-rows: auto auto 1fr auto auto;
      gap: var(--gap);
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: var(--gap);
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
    }
    header h1{
      margin: 0;
      font-size: clamp(18px, 2.2vw, 28px);
      font-weight: 800;
      line-height: 1.2;
    }
    header h1 .accent{ color: var(--accent) }

    .controls{
      display: flex;
      align-items:center;
      gap: var(--gap);
      flex-wrap: wrap;
    }

    .kbd-hint{
      font-size: 13px;
      color: var(--muted);
    }

    /* Buttons */
    button.btn{
      appearance: none;
      border: 1px solid var(--text);
      background: #ffffff;
      color: var(--text);
      min-height: var(--min-touch);
      padding: 10px 14px;
      cursor: pointer;
      font-weight: 800;
      font-size: 16px;
    }
    button.btn.primary{
      background: #e6efff;
      border-color: var(--accent);
      color: #0a2d80;
    }
    button.btn.ghost{
      background: #ffffff;
      border-color: var(--border);
      color: var(--text);
    }
    button.btn[disabled]{
      opacity: .6;
      cursor: not-allowed;
    }
    button:focus-visible{
      outline: 3px solid var(--accent);
      outline-offset: 1px;
    }

    /* Status bar: timer and score. Sticky at top so always visible. */
    .status-bar{
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 5;
      border-bottom: 1px solid var(--border);
      padding: 10px 0;
      display: grid;
      gap: var(--gap);
      grid-template-columns: 1fr auto auto;
      align-items: center;
    }
    @media (max-width: 740px){
      .status-bar{ grid-template-columns: 1fr 1fr }
      .status-bar .controls{ grid-column: 1 / -1; }
    }

    .timer-wrap{
      border: 1px solid var(--border);
      padding: 8px;
    }
    .timer-label{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      font-size: 14px;
    }
    #timerValue{
      font-variant-numeric: tabular-nums;
      font-weight: 800;
    }
    .progress{
      position: relative;
      height: 12px;
      background: #efefef;
      border: 1px solid var(--border);
      margin-top: 6px;
    }
    #timeBar{
      position:absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 100%;
      background: #bcd3ff;
    }

    .score-wrap{
      border: 1px solid var(--border);
      padding: 8px 12px;
      min-width: 160px;
      font-weight: 800;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
    }
    #scoreValue{ font-variant-numeric: tabular-nums }

    /* Game panel */
    #gamePanel{
      border: 1px solid var(--border);
      padding: 12px;
      display: grid;
      gap: var(--gap);
    }
    #gamePanel[data-running="true"]{
      /* Attribute predicate signal for running state */
    }

    #wordDisplay{
      text-align:center;
      font-weight: 900;
      font-size: clamp(36px, 8vw, 96px);
      line-height: 1.05;
      min-height: 1.2em;
      user-select: none;
    }

    #hint{
      text-align:center;
      color: var(--muted);
      font-size: 14px;
    }

    #feedbackMessage{
      text-align:center;
      font-size: 18px;
      font-weight: 800;
      min-height: 1.2em;
    }
    #feedbackMessage[data-result="correct"]{ color: var(--good) }
    #feedbackMessage[data-result="wrong"]{ color: var(--bad) }
    #feedbackMessage[data-result=""]{ color: var(--muted) }

    /* Buttons grid */
    #buttonsContainer{
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: var(--gap);
      align-items: stretch;
      justify-items: stretch;
      padding-bottom: 8px;
    }
    @media (max-width: 1024px){
      #buttonsContainer{ grid-template-columns: repeat(4, 1fr) }
    }
    @media (max-width: 720px){
      #buttonsContainer{ grid-template-columns: repeat(3, 1fr) }
    }

    .color-btn{
      min-height: var(--btn-height);
      border: 1px solid var(--text);
      color: #000;
      font-weight: 900;
      font-size: 16px;
      cursor: pointer;
      user-select:none;
    }
    .color-btn[disabled]{
      opacity: .6;
      cursor: not-allowed;
    }
    .color-btn.correct{
      outline: 3px solid var(--good);
      outline-offset: -3px;
    }
    .color-btn.wrong{
      outline: 3px solid var(--bad);
      outline-offset: -3px;
    }
    .color-btn.selected{
      border: 3px solid #000000;
    }

    /* Results modal */
    #resultsModal{
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(0,0,0,.5);
    }
    #resultsModal.show{ display:flex }
    #resultsModal[data-visible="true"]{ /* attribute predicate signal */ }

    #resultsCard{
      background: #ffffff;
      color: #000000;
      border: 1px solid var(--text);
      padding: 16px;
      max-width: 560px;
      width: 92vw;
    }
    #resultsCard h2{
      margin: 0 0 8px 0;
      font-weight: 900;
    }
    #finalScore{
      font-size: clamp(20px, 3vw, 28px);
      font-weight:900;
      margin: 6px 0 14px 0;
      letter-spacing: .4px;
    }

    /* Pause overlay */
    #pauseOverlay{
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(255,255,255,.92);
      color: #000;
      z-index: 25;
    }
    #pauseOverlay[data-visible="true"]{ display: flex; }
    #pauseCard{
      border: 1px solid var(--text);
      background: #fff;
      color: #000;
      padding: 16px;
      width: min(560px, 92vw);
    }
    #pauseCard h3{ margin: 0 0 10px 0 }

    /* Footer tip */
    footer{
      color: var(--muted);
      font-size: 13px;
      border-top: 1px solid var(--border);
      padding-top: 8px;
      line-height: 1.4;
    }
    .kbd{
      display: inline-block;
      border: 1px solid var(--text);
      padding: 0 4px;
      min-width: var(--min-touch);
      min-height: 0;
    }

    /* Debug / Status proxies (visible) */
    #debugStatus{
      border: 1px solid var(--border);
      padding: 10px;
      background: var(--panel);
      color: #000;
      display: grid;
      gap: 6px;
      grid-template-columns: repeat(2, 1fr);
    }
    #debugStatus h3{
      grid-column: 1 / -1;
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    #debugStatus .row{
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 8px;
      align-items:center;
    }
    #debugStatus code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: #000;
    }

    /* Utility classes (no decoration) */
    .sr-only{
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: -1px !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }
  </style>
</head>
<body>
  <div class="container" id="containerRoot">
    <header>
      <h1><span class="accent">Color</span> Match — Fast-Paced Stroop Game</h1>
      <div class="controls">
        <button id="startBtn" class="btn primary" aria-label="Start or restart game">Start</button>
        <button id="resetBtn" class="btn ghost" aria-label="Reset score and timer">Reset</button>
        <div class="kbd-hint" id="keyboardHint">Hint: Press Enter or Space to Start</div>
      </div>
    </header>

    <section class="status-bar" aria-label="Game status">
      <div class="timer-wrap" aria-live="polite" aria-atomic="true">
        <div class="timer-label">
          <span>Time</span>
          <span id="timerValue" data-seconds="30">30</span>
        </div>
        <div class="progress" role="progressbar" aria-valuemin="0" aria-valuemax="30" aria-valuenow="30" aria-label="Time remaining" data-remaining-ms="30000" id="progressBarWrap">
          <div id="timeBar" style="width: 100%"></div>
        </div>
      </div>
      <div class="score-wrap" aria-live="polite" aria-atomic="true">
        Score: <span id="scoreValue">0</span>
      </div>
      <div class="controls" aria-label="Round controls">
        <button id="showHelpBtn" class="btn ghost" aria-label="Show how to play">Help</button>
      </div>
    </section>

    <main id="gamePanel" role="main" aria-label="Color match game" data-running="false">
      <div id="wordDisplay" aria-live="polite" aria-atomic="true" data-ready="false">READY?</div>
      <div id="hint">Click the button that matches the WORD'S FONT COLOR (not the word meaning).</div>
      <div id="feedbackMessage" data-result=""> </div>

      <nav id="buttonsContainer" aria-label="Color choices" data-accepting="false">
        <!-- Buttons injected by JavaScript -->
      </nav>
    </main>

    <footer>
      Tip: You have 30 seconds. Go fast! You can also use number keys <span class="kbd">1</span> to <span class="kbd">9</span> and <span class="kbd">0</span>, <span class="kbd">-</span>, <span class="kbd">=</span> to pick colors from left to right. Press Enter to Start/Restart.
    </footer>

    <!-- Visible status proxies (MANDATORY DOM COMPLETION PROXIES) -->
    <section id="debugStatus" aria-label="Runtime status proxies">
      <h3>Status Proxies</h3>

      <div class="row"><div>Game:</div><div id="gameStatus">idle</div></div>
      <div class="row"><div>Input:</div><div id="inputStatus">disabled</div></div>
      <div class="row"><div>Time:</div><div id="timeStatus">stopped</div></div>
      <div class="row"><div>Score status:</div><div id="scoreStatus">0</div></div>
      <div class="row"><div>Round:</div><div id="roundStatus">not-started</div></div>
      <div class="row"><div>End modal:</div><div id="endStatus">hidden</div></div>
      <div class="row"><div>Pause overlay:</div><div id="pauseStatus">hidden</div></div>
      <div class="row"><div>Layout:</div><div id="layoutStatus">cols: 6</div></div>
      <div class="row"><div>Prompt:</div><div id="promptStatus">WORD: -, TARGET: -</div></div>
      <div class="row"><div>Last selection:</div><div id="lastSelection">none</div></div>
      <div class="row"><div>Preview status (prompt ready):</div><div id="previewStatus">not-ready</div></div>
      <div class="row"><div>Last link clicked:</div><div id="lastLinkClicked">none</div></div>
      <div class="row"><div>Active section:</div><div id="activeSection">Game</div></div>
      <div class="row"><div>Timer value attribute:</div><div><code id="timerAttrDump">30s</code></div></div>
    </section>
  </div>

  <!-- Results modal -->
  <section id="resultsModal" aria-modal="true" role="dialog" aria-labelledby="resultsTitle" data-visible="false">
    <div id="resultsCard">
      <h2 id="resultsTitle">Time’s up!</h2>
      <div id="finalScore">Your score: 0</div>
      <div style="display:flex; gap:10px; justify-content:flex-start; flex-wrap: wrap;">
        <button id="restartBtn" class="btn primary" aria-label="Play again">Play again</button>
        <button id="closeModalBtn" class="btn ghost" aria-label="Close results">Close</button>
      </div>
    </div>
  </section>

  <!-- Pause overlay -->
  <section id="pauseOverlay" data-visible="false" role="dialog" aria-label="Game paused overlay">
    <div id="pauseCard">
      <h3>Paused</h3>
      <p>The game is paused because the tab lost focus. You can resume when you're ready.</p>
      <div style="display:flex; gap:10px; flex-wrap: wrap;">
        <button id="resumeBtn" class="btn primary" aria-label="Resume game">Resume</button>
        <button id="pauseRestartBtn" class="btn ghost" aria-label="Restart game from pause">Restart</button>
      </div>
    </div>
  </section>

  <!-- Help dialog (non-modal plain section for simplicity) -->
  <section id="helpSection" aria-label="How to play" style="display:none; border-top:1px solid #ccc; padding:12px 16px;">
    <h2 style="margin:0 0 10px 0; font-size: 18px;">How to Play</h2>
    <ol style="margin:0 0 10px 18px; padding:0; line-height:1.5;">
      <li>Press Start (or Enter/Space) to begin a 30-second round.</li>
      <li>Look at the large word. Ignore its meaning. Match the word’s FONT COLOR by clicking the correct color button.</li>
      <li>Use number keys 1–9, 0, -, = to select buttons left to right.</li>
      <li>Each correct answer adds +1 to your score. Incorrect answers do not change your score.</li>
      <li>Buttons give immediate visual feedback: green outline for correct, red for wrong. The last selected button has a bold border.</li>
      <li>You can pause by switching tabs or windows. Resume when ready.</li>
    </ol>
    <p style="margin:0;">Keyboard hint: Enter/Space = Start/Restart. Number keys = choose color. Escape = Close dialogs.</p>
    <div style="margin-top:10px;">
      <button id="closeHelpBtn" class="btn ghost" aria-label="Close help">Close help</button>
    </div>
  </section>

  <script>
    (function(){
      /* =====================================================================
        Color Match Game — Minimal UI, Robust Logic
        - Preserves V0 selectors and API
        - Adds missing feedback and state management
        - Adds pause-on-blur and visible status proxies
        - Fits in 1280×720
      ===================================================================== */

      // ----- Constants
      const COLORS = [
        { name: 'RED',    value: '#e53935' },
        { name: 'GREEN',  value: '#43a047' },
        { name: 'BLUE',   value: '#1e88e5' },
        { name: 'YELLOW', value: '#fdd835' },
        { name: 'PURPLE', value: '#8e24aa' },
        { name: 'ORANGE', value: '#fb8c00' },
        { name: 'PINK',   value: '#d81b60' },
        { name: 'BROWN',  value: '#6d4c41' },
        { name: 'BLACK',  value: '#000000' },
        { name: 'GRAY',   value: '#757575' },
        { name: 'TEAL',   value: '#00897b' },
        { name: 'CYAN',   value: '#00acc1' }
      ];
      // Map keys 1..= across 12 buttons for quick keyboard input
      const KEY_ORDER = ['1','2','3','4','5','6','7','8','9','0','-','='];

      // Duration in ms
      const DURATION = 30_000;

      // ----- Elements
      const containerRoot = document.getElementById('containerRoot');
      const startBtn = document.getElementById('startBtn');
      const resetBtn = document.getElementById('resetBtn');
      const showHelpBtn = document.getElementById('showHelpBtn');
      const closeHelpBtn = document.getElementById('closeHelpBtn');
      const restartBtn = document.getElementById('restartBtn');
      const closeModalBtn = document.getElementById('closeModalBtn');
      const resumeBtn = document.getElementById('resumeBtn');
      const pauseRestartBtn = document.getElementById('pauseRestartBtn');

      const timerValue = document.getElementById('timerValue');
      const timeBar = document.getElementById('timeBar');
      const progressBarWrap = document.getElementById('progressBarWrap');
      const scoreValue = document.getElementById('scoreValue');

      const buttonsContainer = document.getElementById('buttonsContainer');
      const wordDisplay = document.getElementById('wordDisplay');
      const hintEl = document.getElementById('hint');
      const feedbackMessage = document.getElementById('feedbackMessage');

      const resultsModal = document.getElementById('resultsModal');
      const finalScore = document.getElementById('finalScore');

      const gamePanel = document.getElementById('gamePanel');
      const pauseOverlay = document.getElementById('pauseOverlay');
      const helpSection = document.getElementById('helpSection');

      // Debug status proxies
      const gameStatus = document.getElementById('gameStatus');
      const inputStatus = document.getElementById('inputStatus');
      const timeStatus = document.getElementById('timeStatus');
      const scoreStatus = document.getElementById('scoreStatus');
      const roundStatus = document.getElementById('roundStatus');
      const endStatus = document.getElementById('endStatus');
      const pauseStatus = document.getElementById('pauseStatus');
      const layoutStatus = document.getElementById('layoutStatus');
      const promptStatus = document.getElementById('promptStatus');
      const lastSelection = document.getElementById('lastSelection');
      const previewStatus = document.getElementById('previewStatus');
      const lastLinkClicked = document.getElementById('lastLinkClicked');
      const activeSection = document.getElementById('activeSection');
      const timerAttrDump = document.getElementById('timerAttrDump');

      // ----- Game state
      let running = false;
      let acceptingInput = false;
      let paused = false;
      let score = 0;

      let startTime = 0;
      let endTime = 0;
      let remainingMs = DURATION;
      let rafId = null;

      let targetColorName = null; // The correct color (by name) to click
      let lastSelectedButton = null;
      let wasRunningBeforePause = false;

      // ----- Utils (preserved API)
      function hexToRgb(hex){
        const s = hex.replace('#','');
        const bigint = parseInt(s,16);
        if(s.length === 6){
          return { r: (bigint>>16)&255, g:(bigint>>8)&255, b: bigint&255 };
        }
        return { r:0,g:0,b:0 };
      }
      function luminance({r,g,b}){
        const a = [r,g,b].map(v=>{
          v/=255;
          return v<=0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
        });
        return 0.2126*a[0] + 0.7152*a[1] + 0.0722*a[2];
      }
      function getContrastText(hex){
        const rgb = hexToRgb(hex);
        const L = luminance(rgb);
        return L > 0.36 ? '#000000' : '#ffffff';
      }
      function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)] }

      // Build color buttons with unique IDs (preserved API)
      const colorButtons = [];
      function buildButtons(){
        buttonsContainer.innerHTML = '';
        colorButtons.length = 0;
        COLORS.forEach((c, idx)=>{
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.id = `btn-${c.name.toLowerCase()}`;
          btn.className = 'color-btn';
          btn.setAttribute('data-color-name', c.name);
          btn.style.background = c.value;
          btn.style.color = getContrastText(c.value);
          btn.textContent = c.name;
          btn.addEventListener('click', onColorButtonClick);
          btn.disabled = true;
          btn.setAttribute('aria-label', `${c.name} color button`);
          btn.setAttribute('data-selected', 'false');
          buttonsContainer.appendChild(btn);
          colorButtons.push(btn);

          // Add title with keyboard hint
          if(idx < KEY_ORDER.length){
            btn.title = `Press ${KEY_ORDER[idx]} — ${c.name}`;
            btn.setAttribute('data-key-hint', KEY_ORDER[idx]);
          }
        });
        updateLayoutStatus();
      }

      function setButtonsEnabled(enabled){
        // preserved API
        acceptingInput = !!enabled;
        buttonsContainer.setAttribute('data-accepting', enabled ? 'true' : 'false');
        colorButtons.forEach(b => { b.disabled = !enabled; });
        inputStatus.textContent = enabled ? 'enabled' : 'disabled';
      }

      function updateScore(n){
        // preserved API
        scoreValue.textContent = n;
        scoreStatus.textContent = String(n);
      }

      function updateTimerDisplay(msRemaining){
        // preserved API
        const seconds = Math.ceil(msRemaining / 1000);
        timerValue.textContent = Math.max(0, seconds);
        timerValue.setAttribute('data-seconds', String(Math.max(0, seconds)));
        const progress = Math.max(0, Math.min(1, msRemaining / DURATION));
        timeBar.style.width = `${progress*100}%`;
        const ariaNow = Math.round(progress * 30);
        const progressEl = timeBar.parentElement;
        progressEl.setAttribute('aria-valuenow', String(ariaNow));
        progressEl.setAttribute('data-remaining-ms', String(Math.max(0, Math.floor(msRemaining))));
        timerAttrDump.textContent = `${seconds}s`;
        if(running){
          timeStatus.textContent = `ticking (${(msRemaining/1000).toFixed(1)}s)`;
        }else{
          timeStatus.textContent = 'stopped';
        }
      }

      function animateWord(){
        // preserved API – destylized (no actual animation), but keep call point
        // We keep this function to satisfy the contract; no animations needed.
      }

      function nextRound(){
        // preserved API
        if(!running) return;
        // Clear selection visuals from previous question
        colorButtons.forEach(b => {
          b.classList.remove('correct','wrong','selected');
          b.setAttribute('data-selected','false');
        });
        lastSelectedButton = null;
        feedbackMessage.textContent = '';
        feedbackMessage.setAttribute('data-result','');

        // Choose word text (meaning) and display color (target) with bias to mismatch
        const mismatchBias = 0.7;
        const textColorObj = pickRandom(COLORS);
        let displayColorObj = pickRandom(COLORS);
        if(Math.random() < mismatchBias){
          let tries = 0;
          while(displayColorObj.name === textColorObj.name && tries < 8){
            displayColorObj = pickRandom(COLORS);
            tries++;
          }
        }

        // Assign target and render
        targetColorName = displayColorObj.name;
        wordDisplay.textContent = textColorObj.name;
        wordDisplay.style.color = displayColorObj.value;
        wordDisplay.setAttribute('data-ready','true');

        // Visible proxy for prompt status
        promptStatus.textContent = `WORD: ${textColorObj.name}, TARGET: ${displayColorObj.name}`;
        previewStatus.textContent = 'ready';

        animateWord();

        // Accept input now
        setButtonsEnabled(true);
        roundStatus.textContent = 'active';
      }

      function onColorButtonClick(e){
        // preserved API
        if(!running || !acceptingInput) return;
        acceptingInput = false;
        setButtonsEnabled(false); // debounce rapid clicks until we move next
        buttonsContainer.setAttribute('data-accepting','false');

        const btn = e.currentTarget;
        const chosen = btn.getAttribute('data-color-name');

        // Mark selected button
        colorButtons.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        btn.setAttribute('data-selected','true');
        lastSelectedButton = btn;

        // Visual feedback
        colorButtons.forEach(b => { b.classList.remove('correct','wrong'); });
        if(chosen === targetColorName){
          score += 1;
          updateScore(score);
          btn.classList.add('correct');
          feedbackMessage.textContent = 'Correct!';
          feedbackMessage.setAttribute('data-result','correct');
          lastSelection.textContent = `correct (${chosen})`;
        } else {
          btn.classList.add('wrong');
          feedbackMessage.textContent = 'Wrong!';
          feedbackMessage.setAttribute('data-result','wrong');
          lastSelection.textContent = `wrong (${chosen}), target ${targetColorName}`;
        }

        // Move to next round shortly (fast but deterministic)
        setTimeout(()=>{
          if(running){
            nextRound();
          }
        }, 120);
      }

      // Timer using requestAnimationFrame for smooth bar updates (preserved API)
      function startTimer(ms = DURATION){
        // preserved API (now supports optional duration override)
        startTime = performance.now();
        endTime = startTime + ms;
        remainingMs = ms;
        cancelAnimationFrame(rafId);
        timeStatus.textContent = 'ticking';

        const tick = (now)=>{
          if(!running){ return; }
          remainingMs = Math.max(0, endTime - now);
          updateTimerDisplay(remainingMs);
          if(remainingMs <= 0){
            endGame();
          } else {
            rafId = requestAnimationFrame(tick);
          }
        };
        rafId = requestAnimationFrame(tick);
      }

      function startGame(){
        // preserved API
        score = 0;
        updateScore(0);
        running = true;
        paused = false;
        remainingMs = DURATION;
        resultsModal.classList.remove('show');
        resultsModal.setAttribute('data-visible','false');
        endStatus.textContent = 'hidden';

        gamePanel.setAttribute('data-running','true');
        document.body.setAttribute('data-state','running');
        gameStatus.textContent = 'running';

        setButtonsEnabled(true);
        startBtn.textContent = 'Restart';
        updateTimerDisplay(DURATION);

        roundStatus.textContent = 'starting';
        nextRound();
        startTimer(DURATION);
      }

      function resetGame(){
        // preserved API
        // Reset without starting (idle state)
        score = 0;
        updateScore(0);
        running = false;
        paused = false;
        acceptingInput = false;
        cancelAnimationFrame(rafId);
        remainingMs = DURATION;
        updateTimerDisplay(DURATION);
        setButtonsEnabled(false);

        // Clear prompt
        wordDisplay.textContent = 'READY?';
        wordDisplay.style.color = '#000000';
        wordDisplay.setAttribute('data-ready','false');
        promptStatus.textContent = 'WORD: -, TARGET: -';
        previewStatus.textContent = 'not-ready';
        feedbackMessage.textContent = '';
        feedbackMessage.setAttribute('data-result', '');

        // UI state
        startBtn.textContent = 'Start';
        gamePanel.setAttribute('data-running','false');
        document.body.setAttribute('data-state','idle');
        gameStatus.textContent = 'idle';
        roundStatus.textContent = 'not-started';

        // Close modals/overlays
        resultsModal.classList.remove('show');
        resultsModal.setAttribute('data-visible','false');
        endStatus.textContent = 'hidden';

        hidePauseOverlay();
      }

      function endGame(){
        // preserved API
        running = false;
        acceptingInput = false;
        cancelAnimationFrame(rafId);
        setButtonsEnabled(false);
        wordDisplay.style.color = '#000000';
        finalScore.textContent = `Your score: ${score}`;
        resultsModal.classList.add('show');
        resultsModal.setAttribute('data-visible','true');
        endStatus.textContent = 'shown';

        gamePanel.setAttribute('data-running','false');
        document.body.setAttribute('data-state','ended');
        gameStatus.textContent = 'ended';
        roundStatus.textContent = 'ended';
        timeStatus.textContent = 'stopped';
      }

      // Keyboard shortcuts (preserved API)
      function onKeyDown(e){
        if(e.key === 'Escape'){
          // close overlays if open
          if(resultsModal.classList.contains('show')){
            e.preventDefault();
            resultsModal.classList.remove('show');
            resultsModal.setAttribute('data-visible','false');
            endStatus.textContent = 'hidden';
            return;
          }
          if(helpSection && helpSection.style.display !== 'none'){
            e.preventDefault();
            helpSection.style.display = 'none';
            activeSection.textContent = 'Game';
            return;
          }
          if(pauseOverlay.getAttribute('data-visible') === 'true'){
            e.preventDefault();
            // do not auto-resume on Escape, only via Resume button to keep deterministic
            return;
          }
        }

        if(resultsModal.classList.contains('show')){
          if(e.key === 'Enter' || e.key === ' '){
            e.preventDefault();
            startGame();
          }
          return;
        }

        // Start with space/enter
        if((e.key === ' ' || e.key === 'Enter') && !running && !paused){
          e.preventDefault();
          startGame();
          return;
        }

        // During game: color selection by keys
        if(!running || !acceptingInput) return;
        const idx = KEY_ORDER.indexOf(e.key);
        if(idx >= 0 && idx < colorButtons.length){
          e.preventDefault();
          colorButtons[idx].click();
        }
      }

      // ----- Pause / Focus handling
      function showPauseOverlay(){
        pauseOverlay.setAttribute('data-visible','true');
        pauseStatus.textContent = 'shown';
      }
      function hidePauseOverlay(){
        pauseOverlay.setAttribute('data-visible','false');
        pauseStatus.textContent = 'hidden';
      }

      function pauseGame(){
        if(!running) return;
        paused = true;
        wasRunningBeforePause = true;
        running = false;
        acceptingInput = false;
        cancelAnimationFrame(rafId);
        setButtonsEnabled(false);
        showPauseOverlay();
        gameStatus.textContent = 'paused';
        document.body.setAttribute('data-state','paused');
        timeStatus.textContent = 'stopped';
      }

      function resumeGame(){
        if(!paused) return;
        paused = false;
        hidePauseOverlay();
        running = true;
        setButtonsEnabled(true);
        gameStatus.textContent = 'running';
        document.body.setAttribute('data-state','running');
        startTimer(remainingMs);
      }

      document.addEventListener('visibilitychange', ()=>{
        if(document.hidden){
          // Tab hidden -> pause
          pauseGame();
        }
      });
      window.addEventListener('blur', ()=>{
        pauseGame();
      });

      // ----- Layout info
      function updateLayoutStatus(){
        // Determine current columns from computed style
        const cs = window.getComputedStyle(buttonsContainer);
        const templateCols = cs.getPropertyValue('grid-template-columns');
        const colCount = templateCols ? templateCols.split(' ').length : 6;
        layoutStatus.textContent = `cols: ${colCount}`;
      }
      window.addEventListener('resize', updateLayoutStatus);

      // ----- Session persistence (no reset on resize; we only mirror state to sessionStorage)
      const STATE_KEY = 'cmc_state_v1';
      function mirrorState(){
        // Mirror essential state; do not auto-restore on page load (respect no_auto_trigger_on_load)
        const state = {
          running,
          paused,
          acceptingInput,
          score,
          remainingMs,
          targetColorName,
          wordText: wordDisplay.textContent,
          wordColor: wordDisplay.style.color
        };
        try{
          sessionStorage.setItem(STATE_KEY, JSON.stringify(state));
        }catch(_e){}
      }
      setInterval(mirrorState, 400); // lightweight mirror (synchronous visibility)

      // ----- Wire up controls
      startBtn.addEventListener('click', startGame);
      resetBtn.addEventListener('click', resetGame);
      restartBtn.addEventListener('click', startGame);
      closeModalBtn.addEventListener('click', ()=>{
        resultsModal.classList.remove('show');
        resultsModal.setAttribute('data-visible','false');
        endStatus.textContent = 'hidden';
      });
      document.addEventListener('keydown', onKeyDown);

      resumeBtn.addEventListener('click', resumeGame);
      pauseRestartBtn.addEventListener('click', ()=>{
        hidePauseOverlay();
        resetGame();
      });

      showHelpBtn.addEventListener('click', ()=>{
        helpSection.style.display = 'block';
        activeSection.textContent = 'Help';
      });
      if(closeHelpBtn){
        closeHelpBtn.addEventListener('click', ()=>{
          helpSection.style.display = 'none';
          activeSection.textContent = 'Game';
        });
      }

      // Visible proxy for last external link clicked (no external links here, but keep spec-compliant)
      document.body.addEventListener('click', (e)=>{
        const a = e.target.closest('a[href]');
        if(a && a.getAttribute('target') === '_blank'){
          lastLinkClicked.textContent = a.textContent.trim() || a.getAttribute('href');
        }
      });

      // ----- Initialize
      buildButtons();
      resetGame();
      updateLayoutStatus();

      // Ensure critical controls fit in 1280×720 (no scrolling for essentials):
      // - Sticky status bar at top
      // - Main game area compact grid
      // - Visible proxies at bottom (can scroll if needed)
    })();
  </script>

  <!--
    Extended Documentation and Notes (for maintainers and automated analysis)

    1) DOM Contracts Preserved:
       - #scoreValue shows the numeric score.
       - #resultsModal modal with .show class toggling visibility remains intact; added data-visible attribute.
       - #finalScore text begins with "Your score:" and is updated on endGame().
       - #startBtn exists and becomes "Restart" after startGame().
       - #buttonsContainer holds color buttons; data-accepting attribute signals input readiness.
       - #wordDisplay shows "READY?" initially; color applied to signal the target color.
       - #timerValue displays remaining seconds; aria progress updated in #progressBarWrap / #timeBar.

    2) API Functions Preserved (names and callable):
       - hexToRgb, luminance, getContrastText, pickRandom
       - buildButtons, setButtonsEnabled, updateScore, updateTimerDisplay
       - animateWord, nextRound, onColorButtonClick
       - startTimer, startGame, resetGame, endGame, onKeyDown

    3) Immediate Feedback:
       - Buttons show .correct (green outline) or .wrong (red outline) immediately.
       - #feedbackMessage displays "Correct!" or "Wrong!" with semantic color; cleared at next prompt.
       - Last selected button is outlined with .selected until next prompt, aiding rapid play confirmation.

    4) Debounce and Rapid Input:
       - acceptingInput flag and data-accepting attribute gate input.
       - setButtonsEnabled(false) briefly after a click to avoid race conditions and missed clicks.
       - nextRound() is called promptly (120ms) to keep rhythm while avoiding double-counting.

    5) Timer and Score Visibility:
       - Status bar is sticky at top with Time and Score always visible.
       - #timeBar width and #timerValue update synchronously each frame (requestAnimationFrame).
       - #scoreValue updates immediately on correct answers.

    6) Pause Handling:
       - Window blur or tab hidden triggers pauseGame(); overlay (#pauseOverlay) appears with Resume/Restart.
       - Resuming restores timer with precise remainingMs; state attributes and visible proxies reflect truth.

    7) Accessibility:
       - ARIA roles for progressbar and dialog.
       - Focus-visible outlines for interactive elements.
       - Buttons ≥ 56px height (≥ 44×44 tap target).
       - Keyboard mapping 1..= across 12 buttons, Enter/Space to Start.

    8) Status Proxies (MANDATORY DOM COMPLETION PROXIES):
       - For each success event, a visible label updates and an attribute predicate is set:
         • Running state: <main id="gamePanel" data-running="true/false"> and #gameStatus text.
         • Accepting input: <nav id="buttonsContainer" data-accepting="true/false"> and #inputStatus text.
         • Timer: <div class="progress" data-remaining-ms="..."> and #timeStatus text, #timerAttrDump.
         • Results: <section id="resultsModal" data-visible="true/false"> and #endStatus text.
         • Pause: <section id="pauseOverlay" data-visible="true/false"> and #pauseStatus text.
         • Prompt ready: <div id="wordDisplay" data-ready="true/false"> and #previewStatus text.
         • Layout columns: #layoutStatus shows "cols: N".
         • Last selection: #lastSelection shows "correct/wrong (COLOR)".
         • Active section: #activeSection shows "Game" or "Help".

    9) Non-Regression and Neutral Start:
       - No auto-start on load; the game remains idle until Start is clicked or Enter/Space pressed.
       - Reset returns to neutral READY? state with full 30 seconds and score 0.
       - Start sets #startBtn text to "Restart" (per contract).

    10) Responsive:
       - Button grid auto-adjusts to 6/4/3 columns; layout proxy updates accordingly.
       - No reset on window resize; state mirrors to sessionStorage but not auto-restored.

    11) Edge Cases:
       - Double-click or rapid spam on a single prompt counts at most once due to input gating.
       - Last-second inputs handled deterministically; after timer hits 0, inputs are disabled immediately.
       - Clicking background or the word does not affect state; only color buttons count.

    12) Testing Hooks:
       - The game avoids dynamic re-rendering of IDs or replacing nodes; automation can rely on stable IDs.
       - Event handlers are synchronous where required for immediate DOM reflection.

    End of documentation block.
  -->
</body>
</html>
<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Online Whiteboard</title>
<style>
  :root{
    --bg: #f5f7fb;
    --panel: #ffffff;
    --text: #111827;
    --muted: #6b7280;
    --accent: #1f75fe;
    --accent-2: #155cc6;
    --shadow: 0 6px 24px rgba(0,0,0,0.08);
    --toolbar-h: 56px;
    --grid-size: 24px;
    --grid-color: rgba(0,0,0,0.035);
    --border: rgba(0,0,0,0.1);
  }
  @media (prefers-color-scheme: dark) {
    :root{
      --bg: #0e1117;
      --panel: #121722;
      --text: #e5e7eb;
      --muted: #9aa4b2;
      --accent: #69a1ff;
      --accent-2: #8bb7ff;
      --shadow: 0 8px 28px rgba(0,0,0,0.5);
      --grid-color: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.12);
    }
  }

  * { box-sizing: border-box; }
  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  /* Toolbar */
  header#toolbar {
    position: fixed;
    inset: 0 0 auto 0;
    height: var(--toolbar-h);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: color-mix(in oklab, var(--panel) 88%, transparent);
    backdrop-filter: blur(8px);
    border-bottom: 1px solid var(--border);
    z-index: 5;
  }
  .brand {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
    letter-spacing: 0.1px;
    white-space: nowrap;
    user-select: none;
  }
  .brand svg { width: 20px; height: 20px; color: var(--accent); }
  .toolbar-section {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 0;
  }
  .tools, .actions {
    display: flex; align-items: center; gap: 6px;
  }
  .divider {
    width: 1px; height: 28px; background: var(--border); margin: 0 6px;
  }

  /* Buttons */
  button {
    appearance: none;
    border: 1px solid var(--border);
    background: color-mix(in oklab, var(--panel) 92%, transparent);
    color: var(--text);
    height: 36px;
    min-width: 36px;
    padding: 6px 10px;
    border-radius: 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    cursor: pointer;
    transition: transform .05s ease, background .15s ease, border-color .15s ease;
    box-shadow: none;
  }
  button:active { transform: translateY(1px); }
  button:hover { background: color-mix(in oklab, var(--panel) 96%, transparent); }
  button[disabled] { opacity: 0.5; cursor: not-allowed; }
  .tool-btn.active {
    border-color: color-mix(in oklab, var(--accent) 55%, var(--border));
    background: color-mix(in oklab, var(--accent) 14%, var(--panel));
  }
  button svg {
    width: 18px; height: 18px; color: currentColor;
  }
  .control-group {
    display: flex; align-items: center; gap: 8px;
  }

  /* Color input */
  input[type="color"]#brushColor {
    -webkit-appearance: none;
    appearance: none;
    width: 36px; height: 36px;
    padding: 0;
    border: 1px solid var(--border);
    border-radius: 10px;
    background: none;
    cursor: pointer;
  }
  input[type="color"]#brushColor::-webkit-color-swatch-wrapper { padding: 0; }
  input[type="color"]#brushColor::-webkit-color-swatch {
    border: none; border-radius: 9px;
  }

  /* Range (size) */
  .size-wrap { display: flex; align-items: center; gap: 8px; min-width: 160px; }
  input[type="range"]#brushSize {
    -webkit-appearance: none;
    appearance: none;
    width: 140px;
    height: 8px;
    background: transparent;
  }
  input[type="range"]#brushSize:focus { outline: none; }
  input[type="range"]#brushSize::-webkit-slider-runnable-track {
    height: 8px; background: color-mix(in oklab, var(--panel) 80%, var(--border));
    border-radius: 999px; border: 1px solid var(--border);
  }
  input[type="range"]#brushSize::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    margin-top: -6px;
    width: 20px; height: 20px;
    background: var(--accent);
    border-radius: 50%;
    border: none;
    box-shadow: var(--shadow);
  }
  input[type="range"]#brushSize::-moz-range-track {
    height: 8px; background: color-mix(in oklab, var(--panel) 80%, var(--border));
    border-radius: 999px; border: 1px solid var(--border);
  }
  input[type="range"]#brushSize::-moz-range-thumb {
    width: 18px; height: 18px; border-radius: 50%;
    background: var(--accent); border: none; box-shadow: var(--shadow);
  }
  #sizeLabel { font-size: 12px; color: var(--muted); min-width: 38px; text-align: right; user-select: none; }

  /* Main board */
  main {
    position: fixed;
    inset: var(--toolbar-h) 0 0 0;
  }
  #boardContainer {
    position: absolute;
    inset: 0;
    overflow: hidden;
    /* subtle grid background */
    background:
      linear-gradient(to bottom, transparent, transparent 100%),
      repeating-linear-gradient(0deg, transparent, transparent calc(var(--grid-size) - 1px), var(--grid-color) calc(var(--grid-size) - 1px), var(--grid-color) var(--grid-size)),
      repeating-linear-gradient(90deg, transparent, transparent calc(var(--grid-size) - 1px), var(--grid-color) calc(var(--grid-size) - 1px), var(--grid-color) var(--grid-size));
  }
  canvas#boardCanvas {
    display: block;
    width: 100%;
    height: 100%;
    touch-action: none; /* prevent scroll/zoom on touch */
    cursor: crosshair;
  }

  /* Cursor preview */
  #cursorDot {
    position: absolute;
    left: 0; top: 0;
    width: 16px; height: 16px;
    border-radius: 50%;
    border: 1px solid rgba(0,0,0,0.3);
    background: transparent;
    transform: translate(-100px,-100px);
    pointer-events: none;
    z-index: 3;
    mix-blend-mode: multiply;
    opacity: 0.85;
  }
  @media (prefers-color-scheme: dark) {
    #cursorDot { border-color: rgba(255,255,255,0.5); mix-blend-mode: screen; }
  }

  .sr-only {
    position: absolute !important;
    width: 1px; height: 1px;
    padding: 0; margin: -1px;
    overflow: hidden; clip: rect(0,0,0,0);
    white-space: nowrap; border: 0;
  }

  /* Responsive tweaks */
  @media (max-width: 720px) {
    .brand span { display: none; }
    .size-wrap { min-width: 120px; }
    input[type="range"]#brushSize { width: 100px; }
  }
</style>
</head>
<body>
  <header id="toolbar" role="banner" aria-label="Drawing toolbar">
    <div class="toolbar-section brand">
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zm2.92 2.33H5v-1.92l8.3-8.3 1.92 1.92-8.3 8.3zM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
      </svg>
      <span>Online Whiteboard</span>
    </div>

    <div class="toolbar-section tools" role="group" aria-label="Tools">
      <button id="toolBrush" class="tool-btn active" aria-pressed="true" title="Brush (B)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7 16c.55 0 1 .45 1 1 0 1.66-1.34 3-3 3H3v-2h2c.55 0 1-.45 1-1v-1h1zm14-12c-1.1 0-2 .9-2 2 0 .26.05.5.14.73l-7.9 7.9c-.6-.37-1.3-.63-2.07-.63C6.79 12 5 13.79 5 16H3c0-3.31 2.69-6 6-6 1.06 0 2.05.29 2.9.8l7.96-7.96c.2.09.44.16.69.16 1.1 0 2-.9 2-2l-1-.004z"/></svg>
        <span class="sr-only">Brush</span>
      </button>
      <button id="toolHighlighter" class="tool-btn" aria-pressed="false" title="Highlighter (H)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M3 17.25V21h3.75l8.84-8.84-3.75-3.75L3 17.25zm2.92 2.33H5v-1.92l6.38-6.38 1.92 1.92-6.38 6.38zM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-.88.88 3.75 3.75.88-.88z" opacity=".6"/></svg>
        <span class="sr-only">Highlighter</span>
      </button>
      <button id="toolEraser" class="tool-btn" aria-pressed="false" title="Eraser (E)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M16.24 3.56a2 2 0 0 1 2.83 0l1.37 1.37a2 2 0 0 1 0 2.83L9.63 18.57a2 2 0 0 1-1.41.59H5.41a2 2 0 0 1-1.41-.59l-1.37-1.37a2 2 0 0 1 0-2.83L16.24 3.56zM6.83 18.16l9.9-9.9-2.83-2.83-9.9 9.9 2.83 2.83zM21 19v2H9v-2h12z"/></svg>
        <span class="sr-only">Eraser</span>
      </button>

      <div class="divider" aria-hidden="true"></div>

      <div class="control-group">
        <label for="brushColor" class="sr-only">Color</label>
        <input type="color" id="brushColor" value="#1f75fe" />
      </div>
      <div class="control-group size-wrap">
        <label for="brushSize" class="sr-only">Brush size</label>
        <input type="range" id="brushSize" min="1" max="100" step="1" value="8" />
        <span id="sizeLabel">8px</span>
      </div>
    </div>

    <div class="toolbar-section actions" role="group" aria-label="Actions">
      <button id="undoBtn" title="Undo (Ctrl+Z)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12.5 8V5l-5 5 5 5v-3c3.86 0 6.55 1.5 8.5 4.5-.5-5-3.5-10-8.5-10z"/></svg>
        <span class="sr-only">Undo</span>
      </button>
      <button id="redoBtn" title="Redo (Ctrl+Y / Ctrl+Shift+Z)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M11.5 8V5l5 5-5 5v-3c-3.86 0-6.55 1.5-8.5 4.5.5-5 3.5-10 8.5-10z"/></svg>
        <span class="sr-only">Redo</span>
      </button>
      <button id="clearBtn" title="Clear (C)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M6 7h12v12a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V7zm3-4h6l1 2h4v2H4V5h4l1-2z"/></svg>
        <span class="sr-only">Clear</span>
      </button>
      <button id="saveBtn" title="Save Image (Ctrl+S)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M17 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7l-4-4zm-5 16a4 4 0 1 1 0-8 4 4 0 0 1 0 8zM6 6h9v4H6V6z"/></svg>
        <span class="sr-only">Save</span>
      </button>
    </div>
  </header>

  <main role="main">
    <div id="boardContainer" aria-label="Drawing area">
      <canvas id="boardCanvas"></canvas>
      <div id="cursorDot" aria-hidden="true"></div>
    </div>
  </main>

<script>
(function () {
  'use strict';

  const canvas = document.getElementById('boardCanvas');
  const container = document.getElementById('boardContainer');
  let ctx = canvas.getContext('2d', { willReadFrequently: false });

  // Controls
  const btnBrush = document.getElementById('toolBrush');
  const btnHighlighter = document.getElementById('toolHighlighter');
  const btnEraser = document.getElementById('toolEraser');
  const colorInput = document.getElementById('brushColor');
  const sizeInput = document.getElementById('brushSize');
  const sizeLabel = document.getElementById('sizeLabel');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const saveBtn = document.getElementById('saveBtn');
  const cursorDot = document.getElementById('cursorDot');

  const state = {
    tool: 'brush', // brush | highlighter | eraser
    color: colorInput.value || '#1f75fe',
    size: parseInt(sizeInput.value, 10) || 8,
    dpr: Math.max(1, window.devicePixelRatio || 1),
    isDrawing: false,
    pointerId: null,
    lastPoint: null,
    lastMid: null,
    strokeMoved: false,
    history: [],
    historyIndex: -1,
    maxHistory: 15,
    isDirtySinceLastSnapshot: false
  };

  function hexToRgba(hex, alpha = 1) {
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!m) return `rgba(31,117,254,${alpha})`;
    const r = parseInt(m[1], 16);
    const g = parseInt(m[2], 16);
    const b = parseInt(m[3], 16);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function setupContext() {
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.miterLimit = 2;
    ctx.imageSmoothingEnabled = true;
  }

  function applyStrokeStyle() {
    ctx.lineWidth = state.size * state.dpr;
    if (state.tool === 'eraser') {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.globalAlpha = 1;
      // strokeStyle is irrelevant for eraser, but set anyway
      ctx.strokeStyle = '#000';
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = (state.tool === 'highlighter') ? 0.25 : 1.0;
      ctx.strokeStyle = state.color;
    }
  }

  function getCanvasPoint(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * state.dpr,
      y: (e.clientY - rect.top) * state.dpr
    };
  }

  function midpoint(p1, p2) {
    return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
  }

  function resizeCanvas(preserve = true) {
    const rect = container.getBoundingClientRect();
    const prev = document.createElement('canvas');
    prev.width = canvas.width;
    prev.height = canvas.height;
    const pctx = prev.getContext('2d');
    pctx.drawImage(canvas, 0, 0);

    state.dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.max(1, Math.floor(rect.width * state.dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * state.dpr));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx = canvas.getContext('2d');
    setupContext();

    if (preserve && prev.width && prev.height) {
      ctx.drawImage(prev, 0, 0, prev.width, prev.height, 0, 0, canvas.width, canvas.height);
    }
  }

  function setActiveTool(tool) {
    state.tool = tool;
    // Toggle classes and aria-pressed
    const map = {
      brush: btnBrush,
      highlighter: btnHighlighter,
      eraser: btnEraser
    };
    [btnBrush, btnHighlighter, btnEraser].forEach(b => {
      b.classList.remove('active');
      b.setAttribute('aria-pressed', 'false');
    });
    const btn = map[tool];
    btn.classList.add('active');
    btn.setAttribute('aria-pressed', 'true');
    updateCursorAppearance();
  }

  function updateSizeLabel() {
    sizeLabel.textContent = state.size + 'px';
  }

  function updateCursorAppearance() {
    const cssPx = state.size; // cursor is in CSS pixels
    cursorDot.style.width = cssPx + 'px';
    cursorDot.style.height = cssPx + 'px';
    if (state.tool === 'eraser') {
      cursorDot.style.border = '2px dashed rgba(0,0,0,0.55)';
      cursorDot.style.background = 'transparent';
      cursorDot.style.opacity = '0.9';
      cursorDot.style.mixBlendMode = 'normal';
    } else if (state.tool === 'highlighter') {
      cursorDot.style.border = '1px solid rgba(0,0,0,0.4)';
      cursorDot.style.background = hexToRgba(state.color, 0.25);
      cursorDot.style.opacity = '0.85';
      cursorDot.style.mixBlendMode = 'multiply';
    } else {
      cursorDot.style.border = '1px solid rgba(0,0,0,0.25)';
      cursorDot.style.background = hexToRgba(state.color, 0.8);
      cursorDot.style.opacity = '0.85';
      cursorDot.style.mixBlendMode = 'multiply';
    }
  }

  function moveCursorPreview(e) {
    const rect = container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    cursorDot.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
  }

  function hideCursorPreview() {
    cursorDot.style.transform = 'translate(-100px,-100px)';
  }

  function pushSnapshot() {
    // Trim redo stack if any
    if (state.historyIndex < state.history.length - 1) {
      state.history = state.history.slice(0, state.historyIndex + 1);
    }
    try {
      const url = canvas.toDataURL('image/png');
      state.history.push(url);
      if (state.history.length > state.maxHistory) {
        state.history.shift();
      }
      state.historyIndex = state.history.length - 1;
      state.isDirtySinceLastSnapshot = false;
      updateUndoRedoButtons();
    } catch (err) {
      // If toDataURL fails (rare), skip snapshot
      // eslint-disable-next-line no-console
      console.warn('Snapshot failed:', err);
    }
  }

  function restoreFromSnapshot(index) {
    const url = state.history[index];
    if (!url) return;
    const img = new Image();
    img.onload = function () {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
    };
    img.src = url;
  }

  function updateUndoRedoButtons() {
    undoBtn.disabled = !(state.historyIndex > 0);
    redoBtn.disabled = !(state.historyIndex < state.history.length - 1);
  }

  function undo() {
    if (state.historyIndex > 0) {
      state.historyIndex--;
      restoreFromSnapshot(state.historyIndex);
      updateUndoRedoButtons();
    }
  }

  function redo() {
    if (state.historyIndex < state.history.length - 1) {
      state.historyIndex++;
      restoreFromSnapshot(state.historyIndex);
      updateUndoRedoButtons();
    }
  }

  function clearCanvas(push = true) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (push) pushSnapshot();
  }

  function saveImage() {
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width;
    exportCanvas.height = canvas.height;
    const ectx = exportCanvas.getContext('2d');
    // White background for save
    ectx.fillStyle = '#ffffff';
    ectx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
    ectx.drawImage(canvas, 0, 0);

    const filename = `whiteboard-${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
    if (exportCanvas.toBlob) {
      exportCanvas.toBlob(blob => {
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(url);
          a.remove();
        }, 100);
      }, 'image/png');
    } else {
      const dataURL = exportCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  }

  // Drawing Handlers
  function pointerDown(e) {
    if (e.button === 2) return; // ignore right-click
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    state.pointerId = e.pointerId;
    const pt = getCanvasPoint(e);
    setupContext();
    applyStrokeStyle();
    state.lastPoint = pt;
    state.lastMid = pt;
    state.isDrawing = true;
    state.strokeMoved = false;
    moveCursorPreview(e);
  }

  function pointerMove(e) {
    moveCursorPreview(e);
    if (!state.isDrawing || e.pointerId !== state.pointerId) return;
    e.preventDefault();
    const pt = getCanvasPoint(e);
    const mid = midpoint(state.lastPoint, pt);
    ctx.beginPath();
    ctx.moveTo(state.lastMid.x, state.lastMid.y);
    ctx.quadraticCurveTo(state.lastPoint.x, state.lastPoint.y, mid.x, mid.y);
    ctx.stroke();
    state.lastPoint = pt;
    state.lastMid = mid;
    state.strokeMoved = true;
    state.isDirtySinceLastSnapshot = true;
  }

  function drawDotAt(pt) {
    const r = Math.max(0.5, (state.size * state.dpr) / 2);
    if (state.tool === 'eraser') {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = (state.tool === 'highlighter') ? 0.25 : 1.0;
      ctx.fillStyle = state.color;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function pointerUp(e) {
    if (e.pointerId !== state.pointerId) return;
    e.preventDefault();
    if (!state.strokeMoved && state.lastPoint) {
      drawDotAt(state.lastPoint);
      state.isDirtySinceLastSnapshot = true;
    }
    state.isDrawing = false;
    state.pointerId = null;
    pushSnapshot();
  }

  function preventContextMenu(e) {
    e.preventDefault();
  }

  // Controls events
  btnBrush.addEventListener('click', () => setActiveTool('brush'));
  btnHighlighter.addEventListener('click', () => setActiveTool('highlighter'));
  btnEraser.addEventListener('click', () => setActiveTool('eraser'));

  colorInput.addEventListener('input', (e) => {
    state.color = e.target.value;
    updateCursorAppearance();
  });

  sizeInput.addEventListener('input', (e) => {
    state.size = parseInt(e.target.value, 10) || state.size;
    updateSizeLabel();
    updateCursorAppearance();
  });

  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);

  clearBtn.addEventListener('click', () => {
    const proceed = confirm('Clear the whiteboard? This cannot be undone.');
    if (proceed) clearCanvas(true);
  });

  saveBtn.addEventListener('click', saveImage);

  // Canvas events
  canvas.addEventListener('pointerdown', pointerDown);
  canvas.addEventListener('pointermove', pointerMove);
  canvas.addEventListener('pointerup', pointerUp);
  canvas.addEventListener('pointercancel', pointerUp);
  canvas.addEventListener('contextmenu', preventContextMenu);

  container.addEventListener('pointermove', moveCursorPreview);
  container.addEventListener('pointerleave', hideCursorPreview);
  container.addEventListener('pointerenter', moveCursorPreview);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (tag === 'input' || tag === 'textarea') return;

    const k = e.key.toLowerCase();
    if ((e.ctrlKey || e.metaKey) && k === 's') {
      e.preventDefault();
      saveImage();
    } else if ((e.ctrlKey || e.metaKey) && k === 'z') {
      e.preventDefault();
      if (e.shiftKey) redo(); else undo();
    } else if ((e.ctrlKey || e.metaKey) && k === 'y') {
      e.preventDefault();
      redo();
    } else if (k === 'b') {
      setActiveTool('brush');
    } else if (k === 'h') {
      setActiveTool('highlighter');
    } else if (k === 'e') {
      setActiveTool('eraser');
    } else if (k === '[') {
      state.size = Math.max(1, state.size - 1);
      sizeInput.value = state.size;
      updateSizeLabel();
      updateCursorAppearance();
    } else if (k === ']') {
      state.size = Math.min(parseInt(sizeInput.max,10), state.size + 1);
      sizeInput.value = state.size;
      updateSizeLabel();
      updateCursorAppearance();
    } else if (k === 'c') {
      const proceed = confirm('Clear the whiteboard? This cannot be undone.');
      if (proceed) clearCanvas(true);
    }
  });

  // Resize handling
  let resizeTimeout = null;
  function handleResize() {
    resizeCanvas(true);
  }
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(handleResize, 80);
  });

  // Initialize
  function init() {
    resizeCanvas(false);
    setupContext();
    updateSizeLabel();
    updateCursorAppearance();
    // Initial snapshot (blank)
    pushSnapshot();
    updateUndoRedoButtons();
  }
  init();
})();
</script>
</body>
</html>
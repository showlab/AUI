<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Weather Theatre â€” A Canvas MatinÃ©e</title>
  <style>
    :root{
      --bg-0:#0e1016;
      --bg-1:#12141c;
      --panel:#0f1220aa;
      --panel-strong:#11162aee;
      --acc:#f7c14a;
      --text:#e9eefb;
      --muted:#a7b3d8;
      --good:#71d99f;
      --warn:#ffb36b;
      --danger:#ff6b7b;
      --curtain-red-1:#8a0e1b;
      --curtain-red-2:#b01323;
      --curtain-red-3:#d31a2f;
      --shadow:#00000055;
      --glass:rgba(17, 24, 39, 0.45);
      --glass-border:rgba(255,255,255,0.12);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 10%, #182039, #0d101b);
      color:var(--text);
      overflow:hidden;
    }
    header{
      position:fixed;
      top:12px; left:16px;
      z-index:5;
      padding:10px 14px;
      border-radius:12px;
      background:var(--glass);
      border:1px solid var(--glass-border);
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.4px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    header h1::before{
      content:"ðŸŽ­";
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }
    header p{
      margin:4px 0 0 0;
      font-size:12px; color:var(--muted);
    }

    main{
      display:grid;
      grid-template-columns: 1fr 360px;
      grid-template-rows: 100vh;
      gap:0;
      width:100vw; height:100vh;
    }

    /* Stage */
    #stageSection{
      position:relative;
      overflow:hidden;
      background: linear-gradient(180deg, #0b1026 0%, #161b2e 100%);
    }
    #stageContainer{
      position:relative;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #stageCanvas{
      width:100%;
      height:100%;
      display:block;
      background: transparent;
    }

    /* Subtitle (Typewriter) */
    #subtitle{
      position:absolute;
      bottom:18px;
      left:50%;
      transform: translateX(-50%);
      width:min(84vw, 980px);
      z-index:3;
      padding:12px 16px;
      background:linear-gradient(180deg, rgba(13, 16, 27, 0.5), rgba(13, 16, 27, 0.2));
      border:1px solid var(--glass-border);
      border-radius:14px;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
      color:var(--text);
      font-size:16px;
      line-height:1.35;
      letter-spacing:0.2px;
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
    }
    #subtitleText{
      display:inline-block;
      white-space:nowrap;
      overflow:hidden;
      vertical-align:bottom;
    }
    #subtitleText::after{
      content:"";
      display:inline-block;
      width:10px; height:18px;
      background: currentColor;
      margin-left:6px;
      transform: translateY(2px);
      animation: caret 0.9s steps(1) infinite;
    }
    @keyframes caret {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Controls */
    aside#controlPanel{
      position:relative;
      padding:18px 16px 16px;
      background: linear-gradient(180deg, rgba(10,12,19,0.75), rgba(9,11,16,0.9));
      border-left:1px solid var(--glass-border);
      display:flex; flex-direction:column;
      gap:14px;
    }
    .panel{
      background:var(--glass);
      border:1px solid var(--glass-border);
      border-radius:16px;
      padding:14px;
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }
    .panel h2{
      margin:0 0 8px 0;
      font-size:14px;
      color:var(--muted);
      letter-spacing:0.4px;
      font-weight:600;
      text-transform:uppercase;
    }
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0;}
    .label{
      min-width:80px;
      font-size:14px;
    }
    .value{
      font-size:12px; color:var(--muted); width:42px; text-align:right;
    }
    input[type="range"]{
      -webkit-appearance: none; appearance: none;
      width:100%;
      height:28px;
      background: transparent;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:8px;
      background: linear-gradient(90deg, var(--track-from), var(--track-to));
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.28), 0 2px 8px rgba(0,0,0,0.3);
    }
    input[type="range"]::-moz-range-track{
      height:8px;
      background: linear-gradient(90deg, var(--track-from), var(--track-to));
      border-radius:999px;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      width:20px; height:20px; margin-top:-6px;
      border-radius:50%;
      background: radial-gradient(circle at 35% 35%, #ffffff, #cbd5e1);
      border:1px solid rgba(0,0,0,0.25);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.5);
    }
    input[type="range"]::-moz-range-thumb{
      width:20px; height:20px; border-radius:50%;
      background: #fff; border: none;
    }

    .toggle{
      display:flex; align-items:center; gap:10px; justify-content:space-between;
      margin-top:8px;
    }
    .switch{
      position: relative; width:64px; height:32px; flex:0 0 auto;
    }
    .switch input{ display:none; }
    .slider{
      position:absolute; inset:0;
      border-radius:999px;
      background: linear-gradient(180deg, #29304a, #141827);
      border:1px solid var(--glass-border);
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.5), 0 4px 12px rgba(0,0,0,0.25);
      transition: background 0.3s ease;
    }
    .slider::before{
      content:"";
      position:absolute; top:3px; left:3px;
      width:26px;height:26px;border-radius:50%;
      background: radial-gradient(circle at 35% 35%, #fff, #dbe4ff);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
      transition: transform 0.3s ease;
    }
    .switch input:checked + .slider{
      background: linear-gradient(180deg, #0d1222, #0b0f1a);
    }
    .switch input:checked + .slider::before{
      transform: translateX(32px);
      background: radial-gradient(circle at 40% 40%, #fff8d9, #ffe188);
    }
    .toggle .label{
      font-weight:600;
    }
    .legend{
      font-size:12px; color:var(--muted);
      line-height:1.4;
    }
    .buttons{
      display:flex; gap:10px; flex-wrap:wrap; margin-top:6px;
    }
    button{
      appearance:none; border:none; cursor:pointer; outline:none;
      padding:10px 12px; border-radius:12px;
      background: linear-gradient(180deg, #1a2140, #131a32);
      color:var(--text);
      border:1px solid var(--glass-border);
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      font-weight:600; font-size:14px;
      transition: transform 0.05s ease, filter 0.2s ease, background 0.2s ease;
    }
    button:hover{ filter: brightness(1.06); }
    button:active{ transform: translateY(1px) scale(0.99); }

    /* Curtain overlay */
    #curtain{
      position:absolute;
      inset:0;
      z-index:9;
      display:flex;
      pointer-events:auto;
    }
    #curtain.hidden{ pointer-events:none; }
    .curtain-half{
      flex:1;
      background:
        repeating-linear-gradient(90deg, rgba(0,0,0,0.18) 0 10px, transparent 10px 20px),
        linear-gradient(180deg, var(--curtain-red-2), var(--curtain-red-1) 35%, var(--curtain-red-3) 100%);
      box-shadow: inset 0 -20px 40px rgba(0,0,0,0.35), 0 10px 40px rgba(0,0,0,0.5);
      border-right: 1px solid rgba(255,255,255,0.06);
      transform: translateX(0);
      transition: transform 1000ms cubic-bezier(.22,.61,.36,1);
    }
    .curtain-half.right{
      border-right:none; border-left: 1px solid rgba(255,255,255,0.06);
    }
    .curtain-open .curtain-half.left{ transform: translateX(-102%); }
    .curtain-open .curtain-half.right{ transform: translateX(102%); }

    .valance{
      position:absolute; left:0; right:0; top:0; height:90px; z-index:10;
      background:
        repeating-linear-gradient(90deg, rgba(0,0,0,0.15) 0 10px, transparent 10px 20px),
        radial-gradient(200% 100% at 50% 100%, #47090f 20%, #8a0e1b 70%, #5a0a12 100%);
      box-shadow: 0 18px 50px rgba(0,0,0,0.5);
    }
    .curtain-cta{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      z-index:11;
      display:flex; flex-direction:column; align-items:center; gap:10px;
      text-align:center;
    }
    #curtainButton{
      background: linear-gradient(180deg, #ffd89e, #f7c14a);
      color:#3a2b00;
      border:1px solid rgba(0,0,0,0.25);
      text-shadow: 0 1px 0 rgba(255,255,255,0.5);
    }
    .rope{
      color:#fff; opacity:0.9; font-size:12px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    /* Responsiveness */
    @media (max-width: 1100px){
      main{
        grid-template-columns: 1fr;
        grid-template-rows: 1fr auto;
      }
      aside#controlPanel{
        height:auto; max-height:none;
        border-left:none; border-top:1px solid var(--glass-border);
        padding-bottom: max(16px, env(safe-area-inset-bottom));
      }
      #subtitle{
        width: calc(100% - 24px);
        left: 12px; transform:none;
      }
      header{ position:static; margin:10px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Weather Theatre</h1>
    <p>Parallax canvas stage with spotlight sweeps and a curtain reveal</p>
  </header>

  <main>
    <section id="stageSection" aria-label="Canvas Stage">
      <div id="stageContainer">
        <canvas id="stageCanvas" role="img" aria-label="A stylized weather scene drawn on canvas"></canvas>

        <div id="subtitle" aria-live="polite" aria-atomic="true">
          <span id="subtitleText"></span>
        </div>

        <div id="curtain" class="">
          <div class="valance" aria-hidden="true"></div>
          <div class="curtain-half left" aria-hidden="true"></div>
          <div class="curtain-half right" aria-hidden="true"></div>
          <div class="curtain-cta" role="dialog" aria-labelledby="curtainButton">
            <button id="curtainButton">Raise Curtain</button>
            <div class="rope">Tap to reveal today's scene</div>
          </div>
        </div>
      </div>
    </section>

    <aside id="controlPanel" aria-label="Controls">
      <div class="panel" id="moodPanel">
        <h2>Mood Mix</h2>

        <div class="row">
          <div class="label">Cosy</div>
          <input id="cosySlider" type="range" min="0" max="100" value="60" step="1" aria-label="Cosy mood slider">
          <div class="value" id="cosyValue">60%</div>
        </div>
        <div class="row">
          <div class="label">Eerie</div>
          <input id="eerieSlider" type="range" min="0" max="100" value="20" step="1" aria-label="Eerie mood slider">
          <div class="value" id="eerieValue">20%</div>
        </div>
        <div class="row">
          <div class="label">Heroic</div>
          <input id="heroicSlider" type="range" min="0" max="100" value="40" step="1" aria-label="Heroic mood slider">
          <div class="value" id="heroicValue">40%</div>
        </div>

        <div class="toggle">
          <div class="label" id="modeLabel">MatinÃ©e</div>
          <label class="switch" aria-label="MatinÃ©e or Night mode">
            <input id="modeToggle" type="checkbox" aria-pressed="false" />
            <span class="slider"></span>
          </label>
        </div>

        <div class="legend">
          Move your mouse across the stage for parallax. The spotlight sweeps automatically.
        </div>

        <div class="buttons">
          <button id="resetButton" title="Reset sliders to defaults">Reset</button>
          <button id="dropCurtainButton" title="Close the curtain again">Drop Curtain</button>
        </div>
      </div>

      <div class="panel">
        <h2>Mock Forecast</h2>
        <div class="legend">
          â€¢ Mostly cloudy with soft sun breaks<br>
          â€¢ Light breeze around 7 km/h<br>
          â€¢ A brief drizzle may appear toward evening
        </div>
      </div>
      <div class="panel">
        <h2>About</h2>
        <div class="legend">
          Three moods remix the same forecast into different stagecraft:
          cosy warms the palette and softens fog; eerie leans teal with thicker haze;
          heroic adds contrast and a bolder sweep. Enjoy the show!
        </div>
      </div>
    </aside>
  </main>

  <script>
    // Utility: Clamp and lerp
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const ease = t => t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

    // Color helpers
    function hexToRgb(hex){
      hex = hex.replace('#','');
      if(hex.length===3){ hex = hex.split('').map(c=>c+c).join(''); }
      const n = parseInt(hex,16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function rgbToHex({r,g,b}){
      const toHex = v => v.toString(16).padStart(2,'0');
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }
    function mixHex(a,b,t){
      const A=hexToRgb(a), B=hexToRgb(b);
      return rgbToHex({ r:Math.round(lerp(A.r,B.r,t)), g:Math.round(lerp(A.g,B.g,t)), b:Math.round(lerp(A.b,B.b,t)) });
    }
    function tint(hex, amount){ // amount -1..1
      const c=hexToRgb(hex);
      const t = amount>0? {r:255,g:255,b:255} : {r:0,g:0,b:0};
      const tA = Math.abs(amount);
      return rgbToHex({ r:Math.round(lerp(c.r,t.r,tA)), g:Math.round(lerp(c.g,t.g,tA)), b:Math.round(lerp(c.b,t.b,tA)) });
    }
    function multiply(hex1, hex2){
      const a=hexToRgb(hex1), b=hexToRgb(hex2);
      return rgbToHex({ r:Math.round(a.r*b.r/255), g:Math.round(a.g*b.g/255), b:Math.round(a.b*b.b/255) });
    }

    // State
    const state = {
      cosy: 0.6,
      eerie: 0.2,
      heroic: 0.4,
      mode: 'day', // 'day' (MatinÃ©e) or 'night'
      curtainOpen: false,
      pointer: { x:0.5, y:0.5 },
      t0: performance.now(),
      width: 1280, height: 720,
    };

    // Canvas setup
    const canvas = document.getElementById('stageCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas(){
      const ratio = window.devicePixelRatio || 1;
      state.width = canvas.clientWidth;
      state.height = canvas.clientHeight;
      canvas.width = Math.floor(state.width * ratio);
      canvas.height = Math.floor(state.height * ratio);
      ctx.setTransform(ratio,0,0,ratio,0,0);
    }
    window.addEventListener('resize', resizeCanvas);

    // UI elements
    const cosySlider = document.getElementById('cosySlider');
    const eerieSlider = document.getElementById('eerieSlider');
    const heroicSlider = document.getElementById('heroicSlider');
    const cosyValue = document.getElementById('cosyValue');
    const eerieValue = document.getElementById('eerieValue');
    const heroicValue = document.getElementById('heroicValue');
    const modeToggle = document.getElementById('modeToggle');
    const modeLabel = document.getElementById('modeLabel');
    const resetButton = document.getElementById('resetButton');
    const dropCurtainButton = document.getElementById('dropCurtainButton');
    const curtain = document.getElementById('curtain');
    const curtainButton = document.getElementById('curtainButton');
    const subtitleText = document.getElementById('subtitleText');
    const stageContainer = document.getElementById('stageContainer');

    // Style slider tracks
    function paintSliderTracks(){
      cosySlider.style.setProperty('--track-from', '#ffb36b');
      cosySlider.style.setProperty('--track-to', '#ffd89e');
      eerieSlider.style.setProperty('--track-from', '#7be2c5');
      eerieSlider.style.setProperty('--track-to', '#2ad1a1');
      heroicSlider.style.setProperty('--track-from', '#6aa2ff');
      heroicSlider.style.setProperty('--track-to', '#f7c14a');
    }
    paintSliderTracks();

    // Update state from controls
    function updateFromUI(){
      state.cosy = cosySlider.value/100;
      state.eerie = eerieSlider.value/100;
      state.heroic = heroicSlider.value/100;

      cosyValue.textContent = Math.round(state.cosy*100) + '%';
      eerieValue.textContent = Math.round(state.eerie*100) + '%';
      heroicValue.textContent = Math.round(state.heroic*100) + '%';

      // Update mode label
      modeLabel.textContent = modeToggle.checked ? 'Night' : 'MatinÃ©e';
      modeToggle.setAttribute('aria-pressed', modeToggle.checked ? 'true' : 'false');
      state.mode = modeToggle.checked ? 'night' : 'day';

      // Update subtitle
      queueSubtitle(buildSubtitle());
    }

    cosySlider.addEventListener('input', updateFromUI);
    eerieSlider.addEventListener('input', updateFromUI);
    heroicSlider.addEventListener('input', updateFromUI);
    modeToggle.addEventListener('change', updateFromUI);

    resetButton.addEventListener('click', ()=>{
      cosySlider.value = 60;
      eerieSlider.value = 20;
      heroicSlider.value = 40;
      modeToggle.checked = false;
      updateFromUI();
    });

    dropCurtainButton.addEventListener('click', ()=>{
      stageDropCurtain();
    });

    curtainButton.addEventListener('click', ()=>{
      stageRaiseCurtain();
    });

    function stageRaiseCurtain(){
      curtain.classList.add('curtain-open');
      // After anim completes, allow clicks through
      setTimeout(()=>{
        curtain.classList.add('hidden');
        state.curtainOpen = true;
      }, 1050);
      queueSubtitle(buildSubtitle());
    }

    function stageDropCurtain(){
      curtain.classList.remove('hidden');
      // Force reflow to restart transition
      void curtain.offsetWidth;
      curtain.classList.remove('curtain-open');
      state.curtainOpen = false;
      queueSubtitle("Curtain falls... ready for the next cue.");
    }

    // Parallax pointer
    stageContainer.addEventListener('pointermove', (e)=>{
      const rect = stageContainer.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      state.pointer.x = clamp(x, 0, 1);
      state.pointer.y = clamp(y, 0, 1);
    });

    // Typewriter
    let twInterval = null;
    function queueSubtitle(text){
      if(twInterval) clearInterval(twInterval);
      subtitleText.textContent = '';
      let i = 0;
      const speedBase = 22; // ms per char
      twInterval = setInterval(()=>{
        if(i < text.length){
          subtitleText.textContent += text[i];
          i++;
        } else {
          clearInterval(twInterval); twInterval = null;
        }
      }, speedBase + Math.random()*30);
    }

    function dominantMood(){
      const m = [
        {k:'cosy', v:state.cosy},
        {k:'eerie', v:state.eerie},
        {k:'heroic', v:state.heroic},
      ].sort((a,b)=>b.v-a.v)[0].k;
      return m;
    }

    function buildSubtitle(){
      const timeWord = state.mode==='day' ? 'MatinÃ©e' : 'Night';
      let vibe = '';
      const mood = dominantMood();
      if(mood==='cosy') vibe = 'warm lamplight and velvety fog';
      if(mood==='eerie') vibe = 'teal hush and drifting mist';
      if(mood==='heroic') vibe = 'bold contrast and golden edges';
      return `${timeWord} performance: Mostly cloudy with a light breeze; sun breaks possible; a brief drizzle by evening. Staged with ${vibe}.`;
    }

    // Theme computation based on sliders + mode
    function computeTheme(){
      const { cosy, eerie, heroic, mode } = state;
      const daySkyTop = '#8ec5ff', daySkyBottom='#e9f7ff';
      const nightSkyTop='#0b1026', nightSkyBottom='#1a2340';

      // base blend by mode
      const skyTop = (mode==='day') ? daySkyTop : nightSkyTop;
      const skyBottom = (mode==='day') ? daySkyBottom : nightSkyBottom;

      // mood tints
      const cosyWarm = '#ffd8b1';
      const eerieTeal = '#81e6d9';
      const heroicBlue = '#3a66ff';

      // Apply tints
      const skyTopMood = mixHex(skyTop, cosyWarm, cosy*0.35);
      const skyTopMood2 = mixHex(skyTopMood, eerieTeal, eerie*0.25);
      const skyTopFinal = mixHex(skyTopMood2, heroicBlue, heroic*0.15);

      const skyBottomMood = mixHex(skyBottom, cosyWarm, cosy*0.45);
      const skyBottomMood2 = mixHex(skyBottomMood, eerieTeal, eerie*0.22);
      const skyBottomFinal = mixHex(skyBottomMood2, heroicBlue, heroic*0.10);

      // Clouds & terrain
      const cloudBaseDay = '#ffffff';
      const cloudBaseNight = '#cfd8ff';
      let cloudColor = (mode==='day') ? cloudBaseDay : cloudBaseNight;
      cloudColor = mixHex(cloudColor, '#ffecd2', cosy*0.4);
      cloudColor = mixHex(cloudColor, '#b1fff1', eerie*0.35);
      cloudColor = tint(cloudColor, -heroic*0.15); // slightly darker with heroic

      const farMountainDay = '#6c8bb3';
      const farMountainNight = '#2a3a59';
      const farMount = (mode==='day')? farMountainDay: farMountainNight;
      const farMountFinal = tint(mixHex(farMount, '#ffd6a3', cosy*0.15), -heroic*0.12);

      const nearMountainDay = '#3f5f86';
      const nearMountainNight = '#1a2a46';
      const nearMount = (mode==='day')? nearMountainDay: nearMountainNight;
      const nearMountFinal = tint(mixHex(nearMount, '#1ed0b0', eerie*0.15), -heroic*0.05);

      const groundDay = '#2a3b4f';
      const groundNight = '#0f1829';
      const ground = (mode==='day')? groundDay : groundNight;
      const groundFinal = mixHex(ground, '#f7c14a', heroic*0.08);

      // Spotlight
      const accentGold = '#f7c14a';
      const accentTeal = '#52e0c4';
      const accent = mixHex(accentGold, accentTeal, eerie*0.5);
      const spotlightColor = mixHex(accent, '#ffffff', cosy*0.25);

      // Fog + haze
      const fogDensity = clamp(0.08 + cosy*0.25 + eerie*0.22 + (mode==='night'?0.06:0), 0, 0.6);
      const hazeColor = mixHex('#cfe9ff', '#71f1d7', eerie*0.5);

      // Rain intensity (drizzle)
      let rain = 0;
      const base = (mode==='night'? 0.15 : 0.05);
      rain = clamp(base + eerie*0.35 + heroic*0.08 - cosy*0.08, 0, 0.55);

      // Wind for clouds
      const wind = 0.2 + heroic*0.2 + eerie*0.05;

      // Spotlight dynamics
      const spotRadius = lerp(160, 300, heroic*0.7) * (Math.min(state.width, state.height)/720);
      const spotSpeed = 0.4 + heroic*0.6 - cosy*0.2 + eerie*0.05;
      const darkness = (mode==='night' ? 0.45 + eerie*0.1 - cosy*0.1 : 0.18 - cosy*0.05 + eerie*0.05);
      const vignette = 0.24 + heroic*0.08;

      // Stars
      const stars = (mode==='night') ? Math.round(100 + heroic*40 + eerie*60) : 0;

      return {
        skyTop: skyTopFinal,
        skyBottom: skyBottomFinal,
        cloudColor,
        farMount: farMountFinal,
        nearMount: nearMountFinal,
        ground: groundFinal,
        fogDensity,
        hazeColor,
        rainIntensity: rain,
        wind,
        accent,
        spotlightColor,
        spotRadius,
        spotSpeed,
        darkness: clamp(darkness, 0, 0.75),
        vignette: clamp(vignette, 0.1, 0.6),
        stars
      };
    }

    // Scene objects
    const clouds = [];
    const raindrops = [];
    const stars = [];

    function initStars(count){
      stars.length = 0;
      for(let i=0;i<count;i++){
        stars.push({
          x: Math.random(),
          y: Math.random()*0.6,
          s: Math.random()*1.2+0.2,
          tw: Math.random()*Math.PI*2
        });
      }
    }

    function initClouds(){
      clouds.length = 0;
      const layers = [
        { n: 6, y: 0.22, scale: 0.7, parallax: 0.15, speed: 0.02 },
        { n: 5, y: 0.35, scale: 0.95, parallax: 0.25, speed: 0.035 },
        { n: 4, y: 0.48, scale: 1.25, parallax: 0.35, speed: 0.05 },
      ];
      layers.forEach((L, li)=>{
        for(let i=0;i<L.n;i++){
          clouds.push({
            x: Math.random(),
            y: L.y + (Math.random()-0.5)*0.06,
            s: L.scale * (0.75 + Math.random()*0.6),
            p: L.parallax,
            v: L.speed * (0.7 + Math.random()*0.6) * (Math.random()<0.5 ? 1 : 0.85),
            seed: Math.random()*1000 + li*100,
            layer: li
          });
        }
      });
    }

    function spawnRaindrop(theme){
      if(raindrops.length > 600) return;
      const width = state.width, height = state.height;
      raindrops.push({
        x: Math.random()*width,
        y: -20,
        vy: lerp(220, 380, theme.rainIntensity) * (0.8 + Math.random()*0.4),
        len: lerp(8, 16, theme.rainIntensity) * (0.8 + Math.random()*0.4),
        alpha: 0.25 + Math.random()*0.25
      });
    }

    // Drawing helpers
    function drawSky(theme){
      const { width:w, height:h } = state;
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0, theme.skyTop);
      g.addColorStop(1, theme.skyBottom);
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    function drawStars(theme, t){
      if(theme.stars<=0) return;
      const w=state.width, h=state.height;
      for(let i=0;i<stars.length;i++){
        const s = stars[i];
        const px = s.x*w;
        const py = s.y*h;
        const tw = (Math.sin(t*0.002 + s.tw) + 1)/2; // 0..1
        const a = 0.25 + tw*0.55;
        ctx.globalAlpha = a;
        ctx.fillStyle = '#cfe7ff';
        ctx.fillRect(px, py, s.s, s.s);
      }
      ctx.globalAlpha = 1;
    }

    function drawMountains(theme){
      const { width:w, height:h } = state;
      const px = (state.pointer.x - 0.5);
      const parallaxFar = px * 30;
      const parallaxNear = px * 60;

      // Far ridge
      ctx.fillStyle = theme.farMount;
      ctx.beginPath();
      ctx.moveTo(0, h*0.58 + 10);
      for(let x=0; x<=w; x+=20){
        const y = h*0.58 + Math.sin(x*0.003 + 0.5)*20 + Math.sin(x*0.007)*12;
        ctx.lineTo(x + parallaxFar, y);
      }
      ctx.lineTo(w+parallaxFar, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      // Near ridge
      ctx.fillStyle = theme.nearMount;
      ctx.beginPath();
      ctx.moveTo(0, h*0.7 + 20);
      for(let x=0; x<=w; x+=16){
        const y = h*0.7 + Math.sin(x*0.004+1.2)*28 + Math.sin(x*0.01+2)*14;
        ctx.lineTo(x + parallaxNear, y);
      }
      ctx.lineTo(w+parallaxNear, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();
    }

    function drawCloud(ctx, x, y, s, color, alpha){
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      const r = 26*s;
      // simple blobby cloud
      ctx.arc(x, y, r*0.9, 0, Math.PI*2);
      ctx.arc(x+ r*0.9, y+ r*0.1, r*0.8, 0, Math.PI*2);
      ctx.arc(x- r*0.8, y+ r*0.2, r*0.7, 0, Math.PI*2);
      ctx.arc(x+ r*0.2, y- r*0.5, r*0.7, 0, Math.PI*2);
      ctx.arc(x- r*0.2, y- r*0.4, r*0.6, 0, Math.PI*2);
      ctx.closePath();
      ctx.fill();

      // lower soft shadow
      const g = ctx.createLinearGradient(x, y, x, y+r*1.2);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.08)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(x, y+r*0.4, r*1.6, r*0.9, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function drawClouds(theme, dt){
      const w=state.width, h=state.height;
      const pointerX = (state.pointer.x-0.5);
      for(let c of clouds){
        c.x += (c.v + theme.wind*(0.5+c.layer*0.5)) * dt / w;
        if(c.x > 1.2) c.x = -0.2;
        const px = c.x*w + pointerX* (40 * c.p);
        const py = c.y*h + (state.pointer.y-0.5)* (10 * c.p);
        const alpha = 0.75 - c.layer*0.2;
        drawCloud(ctx, px, py, c.s, theme.cloudColor, alpha);
      }
    }

    function drawSunOrMoon(theme, t){
      const w=state.width, h=state.height;
      const px = state.pointer.x-0.5;
      const x = lerp(w*0.15, w*0.85, 0.5 + Math.sin(t*0.00015)*0.5) + px*20;
      const y = h*0.18 + Math.cos(t*0.0002)*8;
      if(state.mode==='day'){
        // Sun
        const g = ctx.createRadialGradient(x,y, 0, x,y, 110);
        g.addColorStop(0, 'rgba(255,230,160,0.9)');
        g.addColorStop(0.3, 'rgba(255,210,120,0.5)');
        g.addColorStop(1, 'rgba(255,210,120,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(x,y, 110, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = '#ffe59e';
        ctx.beginPath(); ctx.arc(x,y, 28, 0, Math.PI*2); ctx.fill();
      } else {
        // Moon
        ctx.fillStyle = '#fff6cc';
        ctx.beginPath(); ctx.arc(x,y, 20, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath(); ctx.arc(x+7,y-4, 18, 0, Math.PI*2); ctx.fill();
      }
    }

    function drawForeground(theme){
      const w=state.width, h=state.height;
      const px = state.pointer.x-0.5;
      const offset = px * 90;

      // Ground strip
      ctx.fillStyle = theme.ground;
      ctx.fillRect(0, h*0.86, w, h*0.14);

      // Stylized pines
      ctx.save();
      ctx.translate(offset,0);
      ctx.fillStyle = tint(theme.ground, -0.22);
      for(let i=0;i<12;i++){
        const x = i/12 * w + Math.sin(i*2.3)*20;
        const y = h*0.86;
        const s = 0.8 + (i%3)*0.2 + Math.random()*0.05;
        drawPine(x, y, 60*s, 100*s);
      }
      ctx.restore();

      // Silhouette house
      const hx = w*0.78 + offset*0.4, hy=h*0.86;
      ctx.fillStyle = tint(theme.ground, -0.15);
      ctx.beginPath();
      ctx.moveTo(hx-55, hy);
      ctx.lineTo(hx+55, hy);
      ctx.lineTo(hx+55, hy-38);
      ctx.lineTo(hx+3, hy-70);
      ctx.lineTo(hx-55, hy-38);
      ctx.closePath();
      ctx.fill();

      // Door light (cosy)
      const cosyLight = clamp(state.cosy*0.8 + (state.mode==='night'?0.15:0), 0, 0.95);
      if(cosyLight>0.01){
        const dg = ctx.createLinearGradient(hx-8, hy-10, hx+8, hy);
        dg.addColorStop(0, `rgba(255,220,160,${cosyLight})`);
        dg.addColorStop(1, `rgba(255,200,120,${cosyLight*0.2})`);
        ctx.fillStyle = dg;
        ctx.fillRect(hx-10, hy-28, 20, 28);
      }
    }

    function drawPine(x, y, w, h){
      ctx.beginPath();
      ctx.moveTo(x, y - h);
      ctx.lineTo(x + w/2, y);
      ctx.lineTo(x - w/2, y);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x, y - h*0.7);
      ctx.lineTo(x + w*0.55, y);
      ctx.lineTo(x - w*0.55, y);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x, y - h*0.45);
      ctx.lineTo(x + w*0.65, y);
      ctx.lineTo(x - w*0.65, y);
      ctx.closePath();
      ctx.fill();
    }

    function drawFog(theme){
      const w=state.width, h=state.height;
      const g = ctx.createLinearGradient(0, h*0.7, 0, h);
      g.addColorStop(0, 'rgba(255,255,255,0)');
      g.addColorStop(1, `${hexToFog(theme.hazeColor, theme.fogDensity)}`);
      ctx.fillStyle = g;
      ctx.fillRect(0, h*0.65, w, h*0.35);
    }
    function hexToFog(hex, a){
      const c = hexToRgb(hex);
      return `rgba(${c.r},${c.g},${c.b},${a})`;
    }

    function drawRain(theme, dt){
      const w=state.width, h=state.height;
      // spawn according to intensity
      const toSpawn = Math.floor(theme.rainIntensity*12);
      for(let i=0;i<toSpawn;i++){
        if(Math.random()<0.8) spawnRaindrop(theme);
      }

      ctx.strokeStyle = `rgba(200,220,255,0.6)`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=raindrops.length-1;i>=0;i--){
        const d = raindrops[i];
        d.y += d.vy * dt;
        ctx.globalAlpha = d.alpha;
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(d.x+2, d.y+d.len);
        if(d.y > h+20){
          raindrops.splice(i,1);
        }
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    function drawSpotlight(theme, t){
      const w=state.width, h=state.height;
      const A = Math.min(w,h)*0.3;
      const sx = w/2 + Math.sin(t*0.0013*theme.spotSpeed)* (w*0.35);
      const sy = h*0.6 + Math.cos(t*0.0018*theme.spotSpeed)* (h*0.08);

      // Darken stage
      ctx.fillStyle = `rgba(0,0,10,${theme.darkness})`;
      ctx.fillRect(0,0,w,h);

      // Cut spotlight hole
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      const rg = ctx.createRadialGradient(sx, sy, theme.spotRadius*0.35, sx, sy, theme.spotRadius);
      rg.addColorStop(0, 'rgba(0,0,0,1)');
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(sx, sy, theme.spotRadius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // Add a golden highlight within the spotlight
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, theme.spotRadius*0.7);
      const c = hexToRgb(theme.spotlightColor);
      glow.addColorStop(0, `rgba(${c.r},${c.g},${c.b},0.28)`);
      glow.addColorStop(1, `rgba(${c.r},${c.g},${c.b},0)`);
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(sx, sy, theme.spotRadius*0.7, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // Vignette
      const vg = ctx.createRadialGradient(w/2, h*0.6, Math.min(w,h)*0.2, w/2, h*0.6, Math.max(w,h)*0.75);
      vg.addColorStop(0, 'rgba(0,0,0,0)');
      vg.addColorStop(1, `rgba(0,0,0,${theme.vignette})`);
      ctx.fillStyle = vg;
      ctx.fillRect(0,0,w,h);
    }

    // Main loop
    let last = performance.now();
    function frame(now){
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      const theme = computeTheme();

      // Prepare stars if needed
      if(stars.length !== theme.stars){
        initStars(theme.stars);
      }

      // Draw order
      drawSky(theme);
      drawStars(theme, now);
      drawSunOrMoon(theme, now);
      drawMountains(theme);
      drawClouds(theme, dt);
      drawForeground(theme);
      drawFog(theme);
      drawRain(theme, dt);
      drawSpotlight(theme, now);

      requestAnimationFrame(frame);
    }

    // Initialize
    function init(){
      resizeCanvas();
      initClouds();
      updateFromUI();
      queueSubtitle("Raise the curtain to begin...");
      requestAnimationFrame(frame);
    }
    init();

    // Start with curtain closed
    stageDropCurtain();

  </script>
</body>
</html>
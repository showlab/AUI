<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cloud Painter</title>
<style>
  :root{
    --bg1:#cbe9ff;
    --bg2:#f7f3ff;
    --panel:#ffffffcc;
    --ink:#4a5b7a;
    --accent:#7abaff;
    --accent2:#ffb3c6;
    --btn:#ffffffee;
    --btnText:#234;
    --shadow:0 10px 30px rgba(0,0,0,0.15);
    --round:18px;
  }
  html,body{
    height:100%;
    margin:0;
    font-family: "Trebuchet MS", "Comic Sans MS", "Segoe UI", system-ui, -apple-system, Arial, sans-serif;
    color:var(--ink);
    background: radial-gradient(1200px 600px at 20% 0%, var(--bg2), var(--bg1));
    overflow:hidden;
  }
  #app{
    display:grid;
    grid-template-rows: auto 1fr auto;
    grid-template-columns: 1fr;
    height:100%;
    width:100%;
  }
  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px 16px;
    gap:12px;
  }
  #brand{
    display:flex;
    align-items:center;
    gap:12px;
  }
  #brand .logo{
    width:42px; height:42px; border-radius:50%;
    background: radial-gradient(circle at 40% 40%, #fff, #fff 60%, #ffffff00 70%);
    box-shadow: 0 6px 16px rgba(0,0,0,0.15) inset, 0 4px 8px rgba(0,0,0,0.05);
  }
  #appTitle{
    font-size:1.6rem;
    line-height:1;
    margin:0;
    letter-spacing:0.5px;
    color:#274057;
    text-shadow: 0 2px 0 rgba(255,255,255,0.6);
  }
  #topActions{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .btn{
    appearance:none;
    border:0;
    background:var(--btn);
    color:var(--btnText);
    padding:10px 14px;
    border-radius:14px;
    box-shadow: var(--shadow);
    font-weight:600;
    cursor:pointer;
    transition: transform 0.05s ease, box-shadow 0.2s ease, background 0.2s ease;
  }
  .btn:hover{ transform: translateY(-1px); }
  .btn:active{ transform:translateY(0); box-shadow: 0 4px 12px rgba(0,0,0,0.15)}
  .btn.primary{ background: linear-gradient(180deg, #fff, #eef7ff); color:#1f3650; }
  .btn.danger{ background: linear-gradient(180deg, #fff, #ffe9ee); color:#6a2133; }
  .btn.small{ padding:8px 10px; border-radius:12px; font-size:0.9rem;}
  #main{
    position:relative;
    display:grid;
    grid-template-columns: 320px 1fr;
    gap:12px;
    padding:0 12px 12px 12px;
    min-height:0;
  }
  @media (max-width: 1000px){
    #main{ grid-template-columns: 1fr; }
    #controlsPanel{ order:2; }
    #stage{ order:1; }
  }
  #controlsPanel{
    background: var(--panel);
    border-radius: var(--round);
    box-shadow: var(--shadow);
    padding:12px;
    margin:0 0 12px 0;
    overflow:auto;
  }
  #stage{
    position:relative;
    background: #a9d8ff;
    border-radius: var(--round);
    box-shadow: var(--shadow);
    min-height: 200px;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
  }
  #skyCanvas{
    width:100%;
    height:100%;
    border-radius: var(--round);
    display:block;
    touch-action: none;
    cursor: crosshair;
    background: transparent;
  }
  /* Controls */
  fieldset{
    border:0;
    padding:10px 10px 2px 10px;
    margin:6px 0 10px 0;
    border-radius:14px;
    background: #ffffffb8;
  }
  legend{
    font-weight:800;
    font-size:0.95rem;
    padding:0 6px;
    color:#2a4462;
  }
  .control{
    display:flex;
    align-items:center;
    gap:10px;
    margin:8px 0;
  }
  label{ font-weight:600; min-width:110px; }
  input[type="range"]{
    width:100%;
    accent-color:#6dacff;
  }
  select, input[type="checkbox"]{
    accent-color:#7abaff;
  }
  .row{
    display:flex; align-items:center; gap:8px; flex-wrap:wrap;
  }
  .spacer{ flex:1; }
  .swatch{
    width:28px; height:28px; border-radius:50%;
    box-shadow: 0 3px 10px rgba(0,0,0,0.15) inset, 0 3px 8px rgba(0,0,0,0.1);
    cursor:pointer; border:2px solid #fff;
    outline: 2px solid rgba(0,0,0,0);
    transition: transform 0.06s ease, outline-color 0.2s ease;
  }
  .swatch:hover{ transform: translateY(-1px); }
  .swatch.active{ outline-color: #6dacff; }
  #brushPreview{
    width: 60px; height:60px; border-radius:12px;
    background: conic-gradient(from 90deg, #fff, #f3f3ff);
    box-shadow: var(--shadow);
  }
  #footer{
    padding:8px 16px;
    display:flex; align-items:center; justify-content:space-between;
    font-size:0.9rem;
    opacity:0.8;
  }
  .tag{
    display:inline-block; padding:4px 8px; background:#ffffffb0; border-radius:10px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }
  .toggle{
    display:flex; align-items:center; gap:8px;
  }
  .toggle input{ transform: scale(1.1); }
  .hint{ font-size:0.85rem; opacity:0.8; }
</style>
</head>
<body>
  <div id="app">
    <header id="topBar">
      <div id="brand" aria-label="Cloud Painter brand">
        <div class="logo" aria-hidden="true"></div>
        <h1 id="appTitle">Cloud Painter</h1>
      </div>
      <div id="topActions">
        <button id="saveBtn" class="btn primary" aria-label="Save your sky as an image">Save Image</button>
        <button id="clearBtn" class="btn danger" aria-label="Clear the sky">Clear Sky</button>
      </div>
    </header>
    <div id="main">
      <aside id="controlsPanel" aria-label="Painting controls">
        <fieldset>
          <legend>Brush</legend>
          <div class="control">
            <label for="brushShape">Shape</label>
            <select id="brushShape" aria-label="Brush shape">
              <option value="puff">Puff</option>
              <option value="fluffy">Fluffy Cloud</option>
              <option value="star">Star</option>
              <option value="heart">Heart</option>
            </select>
            <div id="brushPreview" aria-label="Brush preview"></div>
          </div>
          <div class="control">
            <label for="brushSize">Size</label>
            <input id="brushSize" type="range" min="10" max="160" value="80" />
            <span id="brushSizeVal" class="tag">80</span>
          </div>
          <div class="control">
            <label for="brushSoftness">Softness</label>
            <input id="brushSoftness" type="range" min="0" max="100" value="60" />
            <span id="brushSoftnessVal" class="tag">60%</span>
          </div>
          <div class="control">
            <label for="brushOpacity">Opacity</label>
            <input id="brushOpacity" type="range" min="10" max="100" value="85" />
            <span id="brushOpacityVal" class="tag">0.85</span>
          </div>
          <div class="control">
            <label>Colors</label>
            <div class="row" id="colorRow" role="radiogroup" aria-label="Cloud color">
              <button class="swatch active" id="colorWhite" role="radio" aria-checked="true" title="Pure white" style="background:#ffffff"></button>
              <button class="swatch" id="colorBlue" role="radio" aria-checked="false" title="Baby blue" style="background:#f2f8ff"></button>
              <button class="swatch" id="colorLavender" role="radio" aria-checked="false" title="Lavender" style="background:#f7f3ff"></button>
              <button class="swatch" id="colorPeach" role="radio" aria-checked="false" title="Peach" style="background:#fff2e6"></button>
              <button class="swatch" id="colorPink" role="radio" aria-checked="false" title="Blush pink" style="background:#fff0f6"></button>
            </div>
          </div>
          <div class="control">
            <label for="jitterToggle">Whimsy</label>
            <div class="toggle">
              <input id="jitterToggle" type="checkbox" checked />
              <span class="hint">Adds playful variation</span>
            </div>
          </div>
          <div class="control">
            <label for="eraserToggle">Eraser</label>
            <div class="toggle">
              <input id="eraserToggle" type="checkbox" />
              <span class="hint">Erase clouds (E)</span>
            </div>
          </div>
        </fieldset>

        <fieldset>
          <legend>Sky</legend>
          <div class="control">
            <label for="driftToggle">Cloud Drift</label>
            <div class="toggle">
              <input id="driftToggle" type="checkbox" checked />
              <span class="hint">Let clouds gently move</span>
            </div>
          </div>
          <div class="control">
            <label for="windSpeed">Wind</label>
            <input id="windSpeed" type="range" min="0" max="100" value="25" />
            <span id="windSpeedVal" class="tag">0.25</span>
            <button id="gustBtn" class="btn small" title="Give the wind a little gust">Gust</button>
          </div>
        </fieldset>

        <fieldset>
          <legend>Airplanes</legend>
          <div class="control">
            <label for="planesToggle">Air Traffic</label>
            <div class="toggle">
              <input id="planesToggle" type="checkbox" checked />
              <span class="hint">Planes fly by</span>
            </div>
          </div>
          <div class="control">
            <label>Spawn</label>
            <div class="row">
              <button id="spawnPlaneBtn" class="btn small" title="Add a plane">Add Plane</button>
              <span class="hint">They draw soft contrails</span>
            </div>
          </div>
          <div class="control">
            <label for="includePlanesInSave">Save Planes</label>
            <div class="toggle">
              <input id="includePlanesInSave" type="checkbox" checked />
              <span class="hint">Include planes in image</span>
            </div>
          </div>
        </fieldset>

        <fieldset>
          <legend>Tips</legend>
          <div class="hint">
            - Click or tap and drag to paint fluffy clouds.<br>
            - Toggle Eraser (E) to remove clouds.<br>
            - Press B for brush, S to save, C to clear.<br>
            - Watch your clouds drift with the wind!
          </div>
        </fieldset>
      </aside>

      <section id="stage" aria-label="Sky canvas">
        <canvas id="skyCanvas" width="1280" height="720" aria-label="Painting area"></canvas>
      </section>
    </div>
    <footer id="footer">
      <div>Made with a gentle breeze</div>
      <div class="tag">Viewport target: 1280x720 â€¢ Responsive</div>
    </footer>
  </div>

<script>
(function(){
  // Utilities
  const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
  const rand=(a,b)=>a + Math.random()*(b-a);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const TAU = Math.PI*2;

  // Elements
  const canvas = document.getElementById('skyCanvas');
  const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });

  const brushShapeEl = document.getElementById('brushShape');
  const brushSizeEl = document.getElementById('brushSize');
  const brushSoftnessEl = document.getElementById('brushSoftness');
  const brushOpacityEl = document.getElementById('brushOpacity');
  const brushSizeVal = document.getElementById('brushSizeVal');
  const brushSoftnessVal = document.getElementById('brushSoftnessVal');
  const brushOpacityVal = document.getElementById('brushOpacityVal');
  const brushPreviewEl = document.getElementById('brushPreview');

  const colorButtons = [
    {el:document.getElementById('colorWhite'), color:'#ffffff'},
    {el:document.getElementById('colorBlue'), color:'#f2f8ff'},
    {el:document.getElementById('colorLavender'), color:'#f7f3ff'},
    {el:document.getElementById('colorPeach'), color:'#fff2e6'},
    {el:document.getElementById('colorPink'), color:'#fff0f6'},
  ];

  const jitterToggle = document.getElementById('jitterToggle');
  const eraserToggle = document.getElementById('eraserToggle');

  const driftToggle = document.getElementById('driftToggle');
  const windSpeedEl = document.getElementById('windSpeed');
  const windSpeedVal = document.getElementById('windSpeedVal');
  const gustBtn = document.getElementById('gustBtn');

  const planesToggle = document.getElementById('planesToggle');
  const spawnPlaneBtn = document.getElementById('spawnPlaneBtn');
  const includePlanesInSave = document.getElementById('includePlanesInSave');

  const saveBtn = document.getElementById('saveBtn');
  const clearBtn = document.getElementById('clearBtn');

  // DPR and sizing
  let DPR = Math.max(1, (window.devicePixelRatio||1));
  function resizeCanvas(){
    const rect = document.getElementById('stage').getBoundingClientRect();
    const w = Math.max(600, rect.width);
    const h = Math.max(360, rect.height);
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    if (canvas.width !== Math.floor(w*dpr) || canvas.height !== Math.floor(h*dpr)){
      DPR = dpr;
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }
  }
  window.addEventListener('resize', () => { resizeCanvas(); updateBrushStamp(); });

  // Painting state
  const state = {
    brushShape: 'puff',
    brushSize: 80,
    softness: 0.6, // 0..1
    opacity: 0.85,
    color: '#ffffff',
    jitter: true,
    erasing: false,
    drift: true,
    wind: 0.25, // 0..1
    gust: 0,
    showPlanes: true,
  };

  // Data
  const puffs = []; // {x,y,scale,rot,opacity,vx,vy,bob,shapeKey,removed:false}
  const planes = []; // {x,y,vx,scale,color,history:[],alive:true}
  const MAX_PUFFS = 5000;

  // Brush stamp
  let stampCanvas = null; // base stamp at size = state.brushSize
  let stampKey = '';
  function colorToRGBA(c, a){
    // c can be '#rrggbb' or '#rgb' - convert to rgba string
    const ctx2 = document.createElement('canvas').getContext('2d');
    ctx2.fillStyle = c;
    const s = ctx2.fillStyle; // computed rgb(...)
    // s is like rgb(255,255,255)
    const nums = s.replace(/[^\d,]/g,'').split(',').map(n=>parseInt(n.trim(),10));
    return `rgba(${nums[0]},${nums[1]},${nums[2]},${a})`;
  }
  function makeCanvas(w,h){
    const c = document.createElement('canvas');
    c.width = Math.max(1, Math.floor(w));
    c.height = Math.max(1, Math.floor(h));
    return c;
  }
  function drawStar(ctx, cx, cy, spikes, outerR, innerR){
    let rot = Math.PI / 2 * 3;
    let x = cx, y = cy;
    ctx.beginPath();
    ctx.moveTo(cx, cy - outerR);
    for (let i = 0; i < spikes; i++){
      x = cx + Math.cos(rot) * outerR;
      y = cy + Math.sin(rot) * outerR;
      ctx.lineTo(x,y);
      rot += Math.PI / spikes;

      x = cx + Math.cos(rot) * innerR;
      y = cy + Math.sin(rot) * innerR;
      ctx.lineTo(x,y);
      rot += Math.PI / spikes;
    }
    ctx.lineTo(cx, cy - outerR);
    ctx.closePath();
  }
  function drawHeart(ctx, cx, cy, size){
    const s = size;
    ctx.beginPath();
    ctx.moveTo(cx, cy + s*0.25);
    ctx.bezierCurveTo(cx - s, cy - s*0.5, cx - s*0.1, cy - s*1.1, cx, cy - s*0.4);
    ctx.bezierCurveTo(cx + s*0.1, cy - s*1.1, cx + s, cy - s*0.5, cx, cy + s*0.25);
    ctx.closePath();
  }
  function buildStamp(shape, baseSize, softness, color){
    const pad = baseSize * 0.6;
    const w = baseSize + pad*2;
    const h = baseSize + pad*2;
    const cnv = makeCanvas(w, h);
    const c = cnv.getContext('2d');
    const cx = w/2, cy = h/2;
    const radius = baseSize * 0.5;

    const mainColor = colorToRGBA(color, 1);

    if (shape === 'puff'){
      const grad = c.createRadialGradient(cx, cy, 0, cx, cy, radius);
      const sStop = clamp(softness, 0, 0.98);
      grad.addColorStop(0, colorToRGBA(color, 1));
      grad.addColorStop(clamp(sStop*0.7,0,1), colorToRGBA(color, 0.65));
      grad.addColorStop(1, colorToRGBA(color, 0));
      c.fillStyle = grad;
      c.beginPath();
      c.arc(cx, cy, radius, 0, TAU);
      c.fill();
    } else if (shape === 'fluffy'){
      // draw clustered round puffs
      const lobes = 6;
      const r = radius * 0.65;
      for (let i=0;i<lobes;i++){
        const ang = (i / lobes) * TAU + (i%2?0.2:-0.1);
        const dist = radius * 0.25 + (i%2?radius*0.05:0);
        const lx = cx + Math.cos(ang) * dist;
        const ly = cy + Math.sin(ang) * dist * 0.6;
        const grad = c.createRadialGradient(lx, ly, 0, lx, ly, r);
        grad.addColorStop(0, colorToRGBA(color, 0.95));
        grad.addColorStop(clamp(softness,0,1), colorToRGBA(color, 0.5));
        grad.addColorStop(1, colorToRGBA(color, 0));
        c.fillStyle = grad;
        c.beginPath();
        c.arc(lx, ly, r, 0, TAU);
        c.fill();
      }
      // central puff
      const grad = c.createRadialGradient(cx, cy, 0, cx, cy, radius*0.8);
      grad.addColorStop(0, colorToRGBA(color, 0.9));
      grad.addColorStop(clamp(softness,0,1), colorToRGBA(color, 0.5));
      grad.addColorStop(1, colorToRGBA(color, 0));
      c.fillStyle = grad;
      c.beginPath(); c.arc(cx, cy, radius*0.85, 0, TAU); c.fill();
    } else if (shape === 'star'){
      // draw solid star
      c.fillStyle = mainColor;
      drawStar(c, cx, cy, 5, radius*0.95, radius*0.46);
      c.fill();
      // mask with radial gradient for softness
      const g = makeCanvas(w,h);
      const gctx = g.getContext('2d');
      const grad = gctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(clamp(softness,0,1), 'rgba(255,255,255,0.6)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      gctx.fillStyle = grad;
      gctx.fillRect(0,0,w,h);
      c.globalCompositeOperation = 'destination-in';
      c.drawImage(g,0,0);
      c.globalCompositeOperation = 'source-over';
    } else if (shape === 'heart'){
      c.fillStyle = mainColor;
      drawHeart(c, cx, cy, radius*0.95);
      c.fill();
      const g = makeCanvas(w,h);
      const gctx = g.getContext('2d');
      const grad = gctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(clamp(softness,0,1), 'rgba(255,255,255,0.6)');
      grad.addColorStop(1, 'rgba(255,255,255,0)');
      gctx.fillStyle = grad;
      gctx.fillRect(0,0,w,h);
      c.globalCompositeOperation = 'destination-in';
      c.drawImage(g,0,0);
      c.globalCompositeOperation = 'source-over';
    }
    return cnv;
  }
  function updateBrushStamp(){
    const key = [state.brushShape, Math.round(state.brushSize), Math.round(state.softness*100), state.color].join('|');
    if (stampKey !== key){
      stampKey = key;
      stampCanvas = buildStamp(state.brushShape, state.brushSize * DPR, state.softness, state.color);
      // preview
      const pctx = brushPreviewEl.getContext ? brushPreviewEl.getContext('2d') : null;
      if (!pctx){
        // If not a canvas, create one dynamically
        brushPreviewEl.innerHTML = '';
        const pv = document.createElement('canvas');
        pv.width = pv.height = 60;
        brushPreviewEl.appendChild(pv);
      }
      let pv = brushPreviewEl.querySelector('canvas');
      if (!pv){
        pv = document.createElement('canvas');
        pv.width = pv.height = 60;
        brushPreviewEl.appendChild(pv);
      }
      const pvctx = pv.getContext('2d');
      pv.width = pv.height = 60;
      pvctx.clearRect(0,0,60,60);
      const scale = Math.min(1, 40 / (stampCanvas.width / DPR));
      const drawW = stampCanvas.width / DPR * scale;
      const drawH = stampCanvas.height / DPR * scale;
      pvctx.drawImage(stampCanvas, (60 - drawW)/2, (60 - drawH)/2, drawW, drawH);
    }
  }

  // Painting interaction
  let isPointerDown = false;
  let lastPt = null;
  let pointerId = null;
  function getCanvasPoint(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * DPR;
    const y = (evt.clientY - rect.top) * DPR;
    return {x,y};
  }
  function addPuffAt(x, y, baseSpacingBoost=1){
    if (!stampCanvas) updateBrushStamp();
    let scale = 1;
    let rot = 0;
    let opacity = state.opacity;
    if (state.jitter){
      scale *= rand(0.9, 1.15);
      rot = rand(-0.35, 0.35);
      opacity *= rand(0.9, 1.0);
    }
    const bob = Math.random()*TAU;
    const vx = state.wind * 0.06 * canvas.width; // base in pixels per second scaled
    const vy = rand(-0.01, 0.01) * canvas.height;
    const puff = {x, y, scale, rot, opacity, vx, vy, bob, shapeKey:stampKey, removed:false};
    puffs.push(puff);
    if (puffs.length > MAX_PUFFS){
      // Remove oldest removed or oldest
      let idx = puffs.findIndex(p => p.removed);
      if (idx === -1) idx = 0;
      puffs.splice(idx,1);
    }
  }
  function eraseAt(x, y){
    const radius = (state.brushSize * DPR) * 0.6;
    for (let i = 0; i < puffs.length; i++){
      const p = puffs[i];
      if (p.removed) continue;
      const dx = p.x - x;
      const dy = p.y - y;
      const r = radius * p.scale;
      if (dx*dx + dy*dy <= r*r){
        p.removed = true;
      }
    }
    // occasionally compact
    if (Math.random() < 0.1){
      for (let i=puffs.length-1;i>=0;i--){
        if (puffs[i].removed) puffs.splice(i,1);
      }
    }
  }
  function handlePointerDown(evt){
    if (isPointerDown) return;
    isPointerDown = true;
    pointerId = evt.pointerId || 'mouse';
    canvas.setPointerCapture && canvas.setPointerCapture(pointerId);
    const pt = getCanvasPoint(evt);
    lastPt = pt;
    if (state.erasing){
      eraseAt(pt.x, pt.y);
    } else {
      addPuffAt(pt.x, pt.y);
    }
    evt.preventDefault();
  }
  function handlePointerMove(evt){
    if (!isPointerDown) return;
    if ((evt.pointerId || 'mouse') !== pointerId) return;
    const pt = getCanvasPoint(evt);
    const distX = pt.x - lastPt.x;
    const distY = pt.y - lastPt.y;
    const dist = Math.hypot(distX, distY);
    const spacing = state.brushSize * DPR * 0.35;
    if (dist >= spacing){
      const steps = Math.floor(dist / spacing);
      for (let i=1;i<=steps;i++){
        const t = i/steps;
        const x = lastPt.x + distX * t;
        const y = lastPt.y + distY * t;
        if (state.erasing){
          eraseAt(x,y);
        } else {
          addPuffAt(x,y);
        }
      }
      lastPt = pt;
    }
    evt.preventDefault();
  }
  function handlePointerUp(evt){
    if (!isPointerDown) return;
    if ((evt.pointerId || 'mouse') !== pointerId) return;
    isPointerDown = false;
    pointerId = null;
    canvas.releasePointerCapture && canvas.releasePointerCapture(evt.pointerId);
    lastPt = null;
    evt.preventDefault();
  }
  canvas.addEventListener('pointerdown', handlePointerDown, {passive:false});
  window.addEventListener('pointermove', handlePointerMove, {passive:false});
  window.addEventListener('pointerup', handlePointerUp, {passive:false});
  window.addEventListener('pointercancel', handlePointerUp, {passive:false});

  // Controls hooks
  function setActiveColorButton(btn){
    colorButtons.forEach(o=>{
      const active = o.el === btn;
      o.el.classList.toggle('active', active);
      o.el.setAttribute('aria-checked', active ? 'true' : 'false');
    });
  }
  colorButtons.forEach(o=>{
    o.el.addEventListener('click', ()=>{
      state.color = o.color;
      setActiveColorButton(o.el);
      updateBrushStamp();
    })
  });

  brushShapeEl.addEventListener('change', ()=>{
    state.brushShape = brushShapeEl.value;
    updateBrushStamp();
  });
  function updateSize(){
    state.brushSize = parseInt(brushSizeEl.value, 10);
    brushSizeVal.textContent = state.brushSize;
    updateBrushStamp();
  }
  brushSizeEl.addEventListener('input', updateSize);
  function updateSoftness(){
    state.softness = parseInt(brushSoftnessEl.value, 10) / 100;
    brushSoftnessVal.textContent = Math.round(state.softness*100) + '%';
    updateBrushStamp();
  }
  brushSoftnessEl.addEventListener('input', updateSoftness);
  function updateOpacity(){
    state.opacity = parseInt(brushOpacityEl.value, 10) / 100;
    brushOpacityVal.textContent = state.opacity.toFixed(2);
  }
  brushOpacityEl.addEventListener('input', updateOpacity);

  jitterToggle.addEventListener('change', ()=>{ state.jitter = jitterToggle.checked; });
  eraserToggle.addEventListener('change', ()=>{ state.erasing = eraserToggle.checked; canvas.style.cursor = state.erasing ? 'not-allowed' : 'crosshair'; });

  driftToggle.addEventListener('change', ()=>{ state.drift = driftToggle.checked; });
  function updateWind(){
    state.wind = parseInt(windSpeedEl.value, 10) / 100;
    windSpeedVal.textContent = state.wind.toFixed(2);
  }
  windSpeedEl.addEventListener('input', updateWind);
  gustBtn.addEventListener('click', ()=>{
    state.gust += 0.15; // temporary boost
  });

  planesToggle.addEventListener('change', ()=>{ state.showPlanes = planesToggle.checked; });
  spawnPlaneBtn.addEventListener('click', spawnPlane);

  clearBtn.addEventListener('click', ()=>{
    puffs.length = 0;
  });

  saveBtn.addEventListener('click', saveImage);

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if (e.target && ['INPUT','SELECT','TEXTAREA'].includes(e.target.tagName)) return;
    if (e.key === 'e' || e.key === 'E'){
      state.erasing = !state.erasing;
      eraserToggle.checked = state.erasing;
      canvas.style.cursor = state.erasing ? 'not-allowed' : 'crosshair';
    } else if (e.key === 'b' || e.key === 'B'){
      state.erasing = false;
      eraserToggle.checked = false;
      canvas.style.cursor = 'crosshair';
    } else if (e.key === 'c' || e.key === 'C'){
      puffs.length = 0;
    } else if (e.key === 's' || e.key === 'S'){
      saveImage();
    }
  });

  // Background gradient
  function drawSkyBackground(ctx, w, h, t){
    const topGrad = ctx.createLinearGradient(0,0,0,h);
    const morning = [
      {o:0, c:'#93d0ff'},
      {o:0.6, c:'#cfe8ff'},
      {o:1, c:'#ffffff'}
    ];
    morning.forEach(st=> topGrad.addColorStop(st.o, st.c));
    ctx.fillStyle = topGrad;
    ctx.fillRect(0,0,w,h);

    // Soft sun
    const sunX = w * 0.15, sunY = h * 0.2;
    const sunR = Math.min(w,h) * 0.12;
    const g = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
    g.addColorStop(0, 'rgba(255,255,255,0.9)');
    g.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(sunX, sunY, sunR, 0, TAU);
    ctx.fill();

    // Decorative background drifting wisps (very subtle)
    ctx.globalAlpha = 0.05;
    const wispCount = 6;
    for (let i=0;i<wispCount;i++){
      const y = (h/(wispCount+1))*(i+1) + Math.sin(t*0.0002 + i)*20;
      const x = (t*0.01 + i*200) % (w+400) - 200;
      const grad2 = ctx.createRadialGradient(x, y, 0, x, y, Math.min(220, w*0.25));
      grad2.addColorStop(0, '#ffffff');
      grad2.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = grad2;
      ctx.beginPath();
      ctx.arc(x, y, Math.min(220, w*0.25), 0, TAU);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Planes
  function spawnPlane(){
    const w = canvas.width, h = canvas.height;
    const fromLeft = Math.random() < 0.5;
    const y = rand(h*0.15, h*0.55);
    const scale = rand(0.6, 1.2) * (canvas.width / (1280*DPR));
    const speed = rand(0.06, 0.12) * w; // px / s
    const vx = (fromLeft ? 1 : -1) * speed;
    const x = fromLeft ? -100*DPR : w + 100*DPR;
    const color = Math.random()<0.5 ? '#f8fbff' : '#fffaf4';
    planes.push({x, y, vx, scale, color, history:[], alive:true});
  }
  // Auto spawn planes periodically
  let planeSpawnTimer = 0;

  function drawPlane(ctx, plane, dt){
    const {x,y,scale,color} = plane;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.rotate(plane.vx > 0 ? 0 : Math.PI); // direction

    // Contrail
    plane.history.push({x: x - plane.vx*0.04, y, t: Date.now()});
    if (plane.history.length > 60) plane.history.shift();
    ctx.save();
    for (let i=0;i<plane.history.length;i++){
      const p = plane.history[i];
      const age = (Date.now() - p.t) / 2000;
      const alpha = clamp(1 - age, 0, 0.5);
      ctx.globalAlpha = alpha * 0.3;
      ctx.fillStyle = '#ffffff';
      const r = 6 * (1 - age);
      ctx.beginPath();
      ctx.arc((p.x - x)/scale, (p.y - y)/scale + 4, r, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // Body
    ctx.globalAlpha = 1;
    ctx.fillStyle = color;
    // fuselage
    ctx.beginPath();
    ctx.roundRect(-40, -6, 80, 12, 6);
    ctx.fill();
    // nose
    ctx.beginPath();
    ctx.ellipse(40, 0, 10, 6, 0, 0, TAU);
    ctx.fill();
    // tail
    ctx.fillRect(-50, -6, 10, 12);
    // wings
    ctx.save();
    ctx.translate(10,0);
    ctx.rotate(-0.05);
    ctx.fillRect(-8, -18, 30, 6);
    ctx.rotate(0.1);
    ctx.fillRect(-8, 12, 30, 6);
    ctx.restore();
    // windows
    ctx.fillStyle = 'rgba(100,140,200,0.8)';
    for (let i=-12;i<=20;i+=8){
      ctx.beginPath();
      ctx.arc(i, -1.5, 2, 0, TAU);
      ctx.fill();
    }

    ctx.restore();
  }

  // Main loop
  let lastTime = performance.now();
  function frame(now){
    const dt = Math.min(0.05, (now - lastTime)/1000); // seconds
    lastTime = now;
    const w = canvas.width, h = canvas.height;
    // Background
    drawSkyBackground(ctx, w, h, now);

    // Update wind gust
    if (state.gust > 0){
      const dec = dt * 0.3;
      state.gust = Math.max(0, state.gust - dec);
    }
    const wind = state.wind + state.gust;

    // Update and draw puffs
    if (state.drift){
      for (let i=0;i<puffs.length;i++){
        const p = puffs[i];
        if (p.removed) continue;
        p.x += (wind * 0.06 * w + p.vx*0.0) * dt; // controlled by wind
        p.y += Math.sin((now/1000)*0.8 + p.bob) * 0.12 * DPR; // gentle bob
        // wrap horizontally to keep the sky full
        const margin = 120 * DPR;
        if (p.x > w + margin) p.x = -margin;
      }
    }
    // Draw puffs
    if (stampCanvas){
      for (let i=0;i<puffs.length;i++){
        const p = puffs[i];
        if (p.removed) continue;
        if (p.shapeKey !== stampKey){
          // if brush changed, old puffs still use older stamp look; keep them by drawing scaled current stamp
          // to keep simplicity, we still draw with current stamp
        }
        const drawW = stampCanvas.width * p.scale;
        const drawH = stampCanvas.height * p.scale;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.globalAlpha = p.opacity;
        ctx.drawImage(stampCanvas, -drawW/2, -drawH/2, drawW, drawH);
        ctx.restore();
      }
    }

    // Planes
    if (state.showPlanes){
      planeSpawnTimer -= dt;
      if (planeSpawnTimer <= 0){
        if (planes.length < 3 && Math.random() < 0.6){
          spawnPlane();
        }
        planeSpawnTimer = rand(6, 12);
      }
      for (let i=planes.length-1; i>=0; i--){
        const pl = planes[i];
        pl.x += pl.vx * dt;
        drawPlane(ctx, pl, dt);
        if (pl.vx > 0 && pl.x > w + 120*DPR) planes.splice(i,1);
        else if (pl.vx < 0 && pl.x < -120*DPR) planes.splice(i,1);
      }
    }

    requestAnimationFrame(frame);
  }

  // Save image
  function saveImage(){
    // Compose to offscreen canvas with same size
    const w = canvas.width, h = canvas.height;
    const off = makeCanvas(w, h);
    const octx = off.getContext('2d');
    drawSkyBackground(octx, w, h, performance.now());
    // Draw puffs
    for (let i=0;i<puffs.length;i++){
      const p = puffs[i];
      if (p.removed) continue;
      const drawW = stampCanvas.width * p.scale;
      const drawH = stampCanvas.height * p.scale;
      octx.save();
      octx.translate(p.x, p.y);
      octx.rotate(p.rot);
      octx.globalAlpha = p.opacity;
      octx.drawImage(stampCanvas, -drawW/2, -drawH/2, drawW, drawH);
      octx.restore();
    }
    if (includePlanesInSave.checked && state.showPlanes){
      for (let i=0;i<planes.length;i++){
        drawPlane(octx, planes[i], 0);
      }
    }
    const dataURL = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'cloud-painter.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Init
  function init(){
    resizeCanvas();
    updateSize();
    updateSoftness();
    updateOpacity();
    updateWind();
    updateBrushStamp();
    // Initial plane
    spawnPlane();
    requestAnimationFrame(frame);
  }
  // Polyfill roundRect for Safari if needed
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, Math.min(w,h)/2);
      this.beginPath();
      this.moveTo(x+rr, y);
      this.arcTo(x+w, y, x+w, y+h, rr);
      this.arcTo(x+w, y+h, x, y+h, rr);
      this.arcTo(x, y+h, x, y, rr);
      this.arcTo(x, y, x+w, y, rr);
      this.closePath();
      return this;
    }
  }
  window.addEventListener('load', init);
})();
</script>
</body>
</html>
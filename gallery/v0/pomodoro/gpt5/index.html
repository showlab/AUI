<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pomodoro</title>
  <style>
    :root{
      --bg: #0e1013;
      --card: #171a20;
      --text: #e7eaf0;
      --muted: #9aa3b2;
      --line: #232836;

      --accent-focus: #ff5d73;
      --accent-short: #27c3a7;
      --accent-long: #5a85ff;

      --accent: var(--accent-focus);
      --shadow: 0 10px 30px rgba(0,0,0,0.45);
      --radius: 14px;
    }

    /* Light mode defaults, will be applied when body:not(.dark) */
    body:not(.dark){
      --bg: #f7f8fb;
      --card: #ffffff;
      --text: #0e1013;
      --muted: #5a6371;
      --line: #e9edf4;
      --shadow: 0 8px 24px rgba(30,40,60,0.08);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body{
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(1200px 1200px at 80% -10%, color-mix(in oklch, var(--accent) 20%, transparent) 0%, transparent 60%), var(--bg);
      color: var(--text);
      transition: background-color .3s ease, color .3s ease;
    }

    header{
      position: sticky;
      top: 0;
      z-index: 5;
      backdrop-filter: blur(8px);
      background: linear-gradient(to bottom, color-mix(in oklch, var(--bg) 80%, transparent) 0%, transparent 100%);
      border-bottom: 1px solid var(--line);
    }

    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 16px 24px;
    }

    .header-bar{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      user-select: none;
    }

    .brand-burst{
      width: 36px; height: 36px;
      border-radius: 50%;
      background: conic-gradient(from 180deg at 50% 50%, var(--accent) 0 220deg, color-mix(in oklch, var(--accent) 20%, transparent) 220deg 360deg);
      box-shadow: 0 6px 18px color-mix(in oklch, var(--accent) 35%, transparent);
      transform: rotate(0deg);
      transition: transform .6s cubic-bezier(.2,.8,.2,1);
    }

    .brand-title{
      font-weight: 800;
      letter-spacing: 0.4px;
      font-size: 20px;
    }

    .header-actions{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .toggle{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: var(--card);
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      cursor: pointer;
      user-select: none;
    }
    .toggle input{ display:none; }
    .toggle-pill{
      width: 40px; height: 22px;
      background: color-mix(in oklch, var(--accent) 15%, var(--line));
      border-radius: 999px;
      position: relative;
      transition: background .25s ease;
    }
    .toggle-pill::after{
      content:"";
      position:absolute; top: 50%; left: 3px;
      width: 16px; height: 16px; border-radius: 50%;
      background: #fff;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,.25);
      transition: left .2s ease, background .25s ease;
    }
    .toggle input:checked + .toggle-pill{
      background: var(--accent);
    }
    .toggle input:checked + .toggle-pill::after{
      left: 21px;
    }
    .toggle .lbl{
      font-size: 13px;
      color: var(--muted);
    }

    main{
      padding: 20px 24px 40px;
    }
    .app{
      max-width: 1200px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1.25fr 1fr;
      gap: 20px;
      align-items: start;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .timer-panel{
      padding: 24px;
      position: relative;
      overflow: hidden;
      isolation: isolate;
    }
    .timer-panel::after{
      content:"";
      position:absolute; inset: -20%;
      background: radial-gradient(480px 480px at 85% 20%, color-mix(in oklch, var(--accent) 18%, transparent), transparent 70%);
      z-index:-1;
    }

    .session-header{
      display:flex; align-items:center; justify-content: space-between;
      gap:16px;
      margin-bottom: 12px;
    }
    .session-label{
      display:flex; align-items:center; gap:10px;
      font-weight: 700;
      letter-spacing:.3px;
    }
    .badge{
      padding: 4px 10px;
      border-radius: 999px;
      background: color-mix(in oklch, var(--accent) 15%, transparent);
      color: var(--accent);
      border: 1px solid color-mix(in oklch, var(--accent) 35%, transparent);
      font-size: 12px;
    }
    .next-label{
      color: var(--muted);
      font-size: 12px;
    }

    .timer-wrap{
      position: relative;
      display: grid;
      place-items:center;
      padding: 10px;
      margin: 10px auto 16px;
      width: min(460px, 95%);
      aspect-ratio: 1/1;
    }

    .ring{
      width: 100%;
      height: 100%;
      filter: drop-shadow(0 18px 28px rgba(0,0,0,.2));
      transition: stroke .2s ease;
    }
    .ring .bg{ stroke: color-mix(in oklch, var(--accent) 15%, var(--line)); }
    .ring .fg{ stroke: var(--accent); }

    .timer-digits{
      position: absolute;
      text-align:center;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap: 8px;
      user-select:none;
    }
    #lblTime{
      font-variant-numeric: tabular-nums;
      font-size: clamp(42px, 8.2vw, 76px);
      font-weight: 800;
      letter-spacing: 1px;
      text-shadow: 0 1px 0 rgba(0,0,0,.2);
    }
    .timer-status{
      font-size: 14px;
      color: var(--muted);
    }

    .controls{
      display:flex; align-items:center; justify-content:center;
      gap: 10px; flex-wrap: wrap;
      margin-top: 8px;
    }
    .btn{
      appearance:none;
      border: none;
      border-radius: 12px;
      padding: 12px 16px;
      font-weight: 700;
      letter-spacing:.2px;
      cursor: pointer;
      transition: transform .04s ease, background .2s ease, box-shadow .2s ease, color .2s ease;
      display:inline-flex; align-items:center; gap:10px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn-accent{
      background: linear-gradient(180deg, var(--accent) 0%, color-mix(in oklch, var(--accent) 80%, black) 100%);
      color: white;
      box-shadow: 0 10px 22px color-mix(in oklch, var(--accent) 28%, transparent);
    }
    .btn-ghost{
      background: color-mix(in oklch, var(--card) 60%, var(--line));
      color: var(--text);
      border: 1px solid var(--line);
    }
    .btn-danger{
      background: linear-gradient(180deg, #ff5555 0%, #e04848 100%);
      color:#fff;
      box-shadow: 0 10px 22px rgba(255,85,85,.22);
    }

    .side{
      display:flex; flex-direction:column; gap: 16px;
    }

    .section{
      padding: 16px;
    }
    .section h3{
      margin: 6px 0 12px;
      font-size: 16px;
      letter-spacing:.3px;
    }

    .settings-grid{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    .field{
      display:flex; flex-direction:column; gap:6px;
    }
    .field label{
      font-size: 12px; color: var(--muted);
    }
    .field input[type="number"]{
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: color-mix(in oklch, var(--card) 80%, transparent);
      color: var(--text);
      outline: none;
      transition: border-color .2s ease, background .2s ease;
    }
    .field input[type="number"]:focus{
      border-color: var(--accent);
      background: color-mix(in oklch, var(--card) 60%, transparent);
    }
    .row{
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
      margin-top: 8px;
    }

    .charts{
      display:grid; gap:10px;
      grid-template-columns: 1fr;
    }
    .chart{
      background: color-mix(in oklch, var(--card) 90%, transparent);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
    }
    .chart h4{
      margin: 4px 6px 8px; font-size: 13px; color: var(--muted);
      letter-spacing:.2px;
    }
    .svg-wrap{
      width: 100%;
      overflow: hidden;
    }

    .log{
      max-height: 260px;
      overflow: auto;
      border-top: 1px dashed var(--line);
      margin-top: 8px;
      padding-top: 8px;
    }
    .log-item{
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items:center;
      padding: 8px 6px;
      border-bottom: 1px dashed color-mix(in oklch, var(--line) 80%, transparent);
      font-size: 13px;
    }
    .log-item:last-child{ border-bottom: none; }
    .log-type{
      font-weight: 700;
    }
    .log-type.focus{ color: var(--accent-focus); }
    .log-type.short{ color: var(--accent-short); }
    .log-type.long{ color: var(--accent-long); }
    .log-meta{ color: var(--muted); }
    .pill{
      font-size: 11px; padding: 3px 8px; border-radius: 999px;
      background: var(--line); color: var(--muted);
    }
    .pill.ok{ background: color-mix(in oklch, var(--accent) 18%, transparent); color: var(--accent); }
    .pill.skip{ background: color-mix(in oklch, #ff5555 18%, transparent); color: #ff5555; }

    .stats{
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
      background: color-mix(in oklch, var(--card) 90%, transparent);
      border: 1px dashed var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      color: var(--muted);
    }
    .stats b{ color: var(--text); }

    footer{
      max-width: 1200px;
      margin: 16px auto 40px;
      padding: 0 24px;
      color: var(--muted);
      font-size: 12px;
      text-align:center;
    }

    /* Running pulse */
    .pulse{
      animation: pulse 1.6s ease-in-out infinite;
    }
    @keyframes pulse{
      0% { box-shadow: 0 0 0 0 color-mix(in oklch, var(--accent) 35%, transparent); }
      50%{ box-shadow: 0 0 0 10px transparent; }
      100%{ box-shadow: 0 0 0 0 transparent; }
    }

    /* Responsive */
    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      .timer-wrap{ width: min(560px, 90vw); }
    }
  </style>
</head>
<body class="dark">
  <header>
    <div class="wrap header-bar">
      <div class="brand" aria-label="Pomodoro">
        <div class="brand-burst" id="brandBurst"></div>
        <div class="brand-title">Pomodoro</div>
      </div>
      <div class="header-actions">
        <label class="toggle" title="Dark Mode">
          <span class="lbl">Dark</span>
          <input id="toggleDarkMode" type="checkbox" aria-label="Toggle Dark Mode">
          <span class="toggle-pill"></span>
        </label>
      </div>
    </div>
  </header>

  <main>
    <div class="app">
      <section class="timer-panel card" aria-label="Timer Panel">
        <div class="session-header">
          <div class="session-label">
            <span class="badge" id="lblSession">Focus</span>
          </div>
          <div class="next-label" id="lblNext">Next: Short Break</div>
        </div>

        <div class="timer-wrap pulse" id="timerWrap">
          <svg id="svgProgress" class="ring" viewBox="0 0 100 100" role="img" aria-label="Timer progress">
            <circle class="bg" cx="50" cy="50" r="44" stroke-width="10" fill="none" stroke-linecap="round"></circle>
            <circle class="fg" id="progressArc" cx="50" cy="50" r="44" stroke-width="10" fill="none" stroke-linecap="round"
              transform="rotate(-90 50 50)" stroke-dasharray="276.46" stroke-dashoffset="0"></circle>
          </svg>

          <div class="timer-digits">
            <div id="lblTime">25:00</div>
            <div class="timer-status" id="lblStatus">Ready</div>
          </div>
        </div>

        <div class="controls">
          <button id="btnStartPause" class="btn btn-accent" aria-label="Start or Pause Timer">â–¶ Start</button>
          <button id="btnReset" class="btn btn-ghost" aria-label="Reset Timer">âŸ² Reset</button>
          <button id="btnSkip" class="btn btn-ghost" aria-label="Skip to Next Session">â¤¼ Skip</button>
          <button id="btnTestBeep" class="btn btn-ghost" aria-label="Test Beep Sound">ðŸ”Š Beep</button>
        </div>

        <div class="stats" id="statsToday" aria-live="polite">
          Today â€¢ Focus: <b>0</b> sessions, <b>0</b> min â€¢ Break: <b>0</b> sessions, <b>0</b> min
        </div>

        <div class="log" aria-label="Sessions Log">
          <div class="section" style="padding:8px 6px;">
            <h3 style="margin: 0 0 8px;">Session Log</h3>
            <div id="logList"></div>
          </div>
        </div>
      </section>

      <aside class="side">
        <section class="section card" aria-label="Settings">
          <h3>Settings</h3>
          <div class="settings-grid">
            <div class="field">
              <label for="inputFocus">Focus (minutes)</label>
              <input id="inputFocus" type="number" min="1" max="180" step="1" value="25">
            </div>
            <div class="field">
              <label for="inputShortBreak">Short Break (minutes)</label>
              <input id="inputShortBreak" type="number" min="1" max="60" step="1" value="5">
            </div>
            <div class="field">
              <label for="inputLongBreak">Long Break (minutes)</label>
              <input id="inputLongBreak" type="number" min="1" max="120" step="1" value="15">
            </div>
            <div class="field">
              <label for="inputLongEvery">Long Break Every (focus sessions)</label>
              <input id="inputLongEvery" type="number" min="2" max="12" step="1" value="4">
            </div>
          </div>

          <div class="row">
            <label class="toggle" title="Auto-start next session">
              <span class="lbl">Auto-start</span>
              <input id="toggleAutoStart" type="checkbox" aria-label="Toggle Auto Start">
              <span class="toggle-pill"></span>
            </label>
            <div class="lbl" style="color:var(--muted);">Changes save automatically</div>
          </div>
        </section>

        <section class="section card" aria-label="Charts">
          <h3>Progress</h3>
          <div class="charts">
            <div class="chart">
              <h4>Focus minutes (last 7 days)</h4>
              <div class="svg-wrap">
                <svg id="svgBarChart" viewBox="0 0 320 120" width="100%" height="120" role="img" aria-label="Bar chart of focus minutes">
                  <rect x="0" y="0" width="320" height="120" rx="10" ry="10" fill="none"></rect>
                </svg>
              </div>
            </div>
            <div class="chart">
              <h4>Per-session duration trend</h4>
              <div class="svg-wrap">
                <svg id="svgSparkline" viewBox="0 0 320 80" width="100%" height="80" role="img" aria-label="Sparkline of session durations">
                  <rect x="0" y="0" width="320" height="80" rx="10" ry="10" fill="none"></rect>
                </svg>
              </div>
            </div>
          </div>
        </section>
      </aside>
    </div>
  </main>

  <footer>
    Pro tip: hit Start and stay in flow â€” weâ€™ll auto-advance breaks if you want. Sound plays when a session ends. Data is stored in your browser.
  </footer>

  <script>
    // State and persistence
    const $ = (id) => document.getElementById(id);

    const els = {
      brandBurst: $('brandBurst'),
      lblSession: $('lblSession'),
      lblNext: $('lblNext'),
      lblTime: $('lblTime'),
      lblStatus: $('lblStatus'),
      progressArc: $('progressArc'),
      timerWrap: $('timerWrap'),

      btnStartPause: $('btnStartPause'),
      btnReset: $('btnReset'),
      btnSkip: $('btnSkip'),
      btnTestBeep: $('btnTestBeep'),

      inputFocus: $('inputFocus'),
      inputShort: $('inputShortBreak'),
      inputLong: $('inputLongBreak'),
      inputEvery: $('inputLongEvery'),
      toggleAutoStart: $('toggleAutoStart'),

      toggleDark: $('toggleDarkMode'),

      logList: $('logList'),
      statsToday: $('statsToday'),

      svgBarChart: $('svgBarChart'),
      svgSparkline: $('svgSparkline')
    };

    // Colors per session
    const accentByType = {
      focus: getComputedStyle(document.documentElement).getPropertyValue('--accent-focus').trim(),
      short: getComputedStyle(document.documentElement).getPropertyValue('--accent-short').trim(),
      long:  getComputedStyle(document.documentElement).getPropertyValue('--accent-long').trim(),
    };

    const storage = {
      loadSettings(){
        try{
          const s = JSON.parse(localStorage.getItem('pomodoroSettings') || '{}');
          return {
            focusMin: clampInt(s.focusMin ?? 25, 1, 180),
            shortMin: clampInt(s.shortMin ?? 5, 1, 60),
            longMin: clampInt(s.longMin ?? 15, 1, 120),
            longEvery: clampInt(s.longEvery ?? 4, 2, 12),
            autoStart: !!s.autoStart
          };
        }catch(e){
          return { focusMin:25, shortMin:5, longMin:15, longEvery:4, autoStart:false };
        }
      },
      saveSettings(s){
        localStorage.setItem('pomodoroSettings', JSON.stringify(s));
      },
      loadDark(){
        return localStorage.getItem('pomodoroDark') === '1';
      },
      saveDark(dark){
        localStorage.setItem('pomodoroDark', dark ? '1':'0');
      },
      loadLog(){
        try{ return JSON.parse(localStorage.getItem('pomodoroLog')||'[]'); }
        catch(e){ return []; }
      },
      saveLog(log){
        localStorage.setItem('pomodoroLog', JSON.stringify(log));
      }
    };

    function clampInt(v, min, max){
      v = Math.round(parseInt(v, 10) || 0);
      return Math.max(min, Math.min(max, v));
    }

    // Timer state
    const state = {
      running: false,
      currentType: 'focus', // 'focus' | 'short' | 'long'
      remaining: 0, // seconds
      total: 0,     // seconds
      cycleCount: 0, // completed focus sessions in the cycle
      sessionStartAt: null,
      plannedSeconds: 0,
      settings: storage.loadSettings(),
      log: storage.loadLog()
    };

    // Audio
    let audioContext = null;
    function initAudio(){
      if(!audioContext){
        try{
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }catch(e){
          console.warn('Web Audio unavailable:', e);
        }
      }
    }
    function beep(){
      initAudio();
      if(!audioContext) return;
      const now = audioContext.currentTime;
      // Two short beeps
      const freqs = [880, 660];
      freqs.forEach((f, i)=>{
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.frequency.value = f;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.0001, now + i*0.25);
        gain.gain.exponentialRampToValueAtTime(0.4, now + i*0.25 + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + i*0.25 + 0.18);
        osc.connect(gain).connect(audioContext.destination);
        osc.start(now + i*0.25);
        osc.stop(now + i*0.25 + 0.2);
      });
      if(navigator.vibrate) navigator.vibrate([80,40,80]);
    }

    // Progress ring calculations
    const R = 44;
    const CIRC = 2 * Math.PI * R;
    els.progressArc.setAttribute('stroke-dasharray', CIRC.toFixed(2));

    // Initialize settings UI
    function applySettingsToUI(){
      els.inputFocus.value = state.settings.focusMin;
      els.inputShort.value = state.settings.shortMin;
      els.inputLong.value = state.settings.longMin;
      els.inputEvery.value = state.settings.longEvery;
      els.toggleAutoStart.checked = state.settings.autoStart;
    }

    function scheduleFor(type){
      if(type === 'focus') return state.settings.focusMin * 60;
      if(type === 'short') return state.settings.shortMin * 60;
      if(type === 'long') return state.settings.longMin * 60;
      return 1500;
    }

    function computeNextType(currentType){
      if(currentType === 'focus'){
        const nextIsLong = (state.cycleCount + 1) % state.settings.longEvery === 0;
        return nextIsLong ? 'long' : 'short';
      }else{
        return 'focus';
      }
    }

    function setAccentFor(type){
      const color = accentByType[type];
      document.documentElement.style.setProperty('--accent', color);
      els.lblSession.textContent = typeLabel(type);
      els.lblSession.style.color = color;
      els.lblSession.style.borderColor = color;
      els.brandBurst.style.transform = `rotate(${Math.random()*14 - 7}deg)`;
    }

    function typeLabel(type){
      if(type === 'focus') return 'Focus';
      if(type === 'short') return 'Short Break';
      if(type === 'long') return 'Long Break';
      return type;
    }

    function fmtTime(sec){
      sec = Math.max(0, Math.round(sec));
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function updateProgress(){
      const fraction = state.total > 0 ? (state.remaining / state.total) : 0;
      const offset = CIRC * (1 - fraction);
      els.progressArc.style.strokeDashoffset = offset.toFixed(2);
      els.lblTime.textContent = fmtTime(state.remaining);
      const next = computeNextType(state.currentType);
      els.lblNext.textContent = `Next: ${typeLabel(next)}`;
      els.timerWrap.classList.toggle('pulse', state.running);
    }

    function setSession(type, keepRunning=false){
      state.currentType = type;
      state.total = scheduleFor(type);
      state.remaining = state.total;
      state.sessionStartAt = null;
      state.plannedSeconds = state.total;
      setAccentFor(type);
      els.lblStatus.textContent = keepRunning ? 'Running' : 'Ready';
      updateProgress();
    }

    // Timer engine
    let tickTimer = null;
    function startTimer(){
      initAudio(); // unlock on first interaction
      if(state.running) return;
      if(state.remaining <= 0){
        state.total = scheduleFor(state.currentType);
        state.remaining = state.total;
      }
      state.running = true;
      if(!state.sessionStartAt) state.sessionStartAt = Date.now();
      els.btnStartPause.textContent = 'â¸ Pause';
      els.lblStatus.textContent = 'Running';
      tickTimer = setInterval(tick, 250);
      updateProgress();
    }

    function pauseTimer(){
      if(!state.running) return;
      state.running = false;
      els.btnStartPause.textContent = 'â–¶ Start';
      els.lblStatus.textContent = 'Paused';
      clearInterval(tickTimer); tickTimer = null;
      updateProgress();
    }

    function resetTimer(){
      state.remaining = state.total = scheduleFor(state.currentType);
      state.running = false;
      els.btnStartPause.textContent = 'â–¶ Start';
      els.lblStatus.textContent = 'Ready';
      state.sessionStartAt = null;
      updateProgress();
    }

    function skipSession(){
      // Record as skipped if there was any elapsed time
      recordSession('skipped');
      gotoNextSession(false);
    }

    function completeSession(){
      recordSession('completed');
      beep();
      gotoNextSession(true);
    }

    function gotoNextSession(fromCompletion){
      // If finished a focus, increase cycleCount; if break finished, no change.
      if(state.currentType === 'focus' && fromCompletion){
        state.cycleCount += 1;
      }
      const next = computeNextType(state.currentType);
      setSession(next, false);
      if(state.settings.autoStart){
        setTimeout(()=> startTimer(), 350);
      }
    }

    function recordSession(status){
      const now = Date.now();
      const planned = state.plannedSeconds || scheduleFor(state.currentType);
      let elapsed = planned - state.remaining;
      if(elapsed < 0) elapsed = 0;

      // If nothing happened and user skips immediately, don't log a zero-length session.
      if(elapsed < 1 && status === 'skipped') return;

      state.log.push({
        id: now + '_' + Math.random().toString(36).slice(2),
        type: state.currentType,
        start: state.sessionStartAt || now - elapsed*1000,
        end: now,
        plannedSeconds: planned,
        actualSeconds: Math.round(elapsed),
        status
      });
      storage.saveLog(state.log);
      renderLog();
      renderStatsAndCharts();
    }

    function tick(){
      state.remaining -= 0.25;
      if(state.remaining <= 0){
        state.remaining = 0;
        pauseTimer();
        completeSession();
      }
      updateProgress();
    }

    // Log rendering
    function renderLog(){
      const list = state.log.slice().reverse().slice(0, 50);
      if(list.length === 0){
        els.logList.innerHTML = `<div class="log-item" style="grid-template-columns:1fr;"><span style="color:var(--muted)">No sessions yet. Your journey starts now âœ¨</span></div>`;
        return;
      }
      const fmtTimeShort = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit' });
      const fmtDate = new Intl.DateTimeFormat(undefined, { weekday: 'short', month:'short', day:'numeric' });
      els.logList.innerHTML = list.map(item=>{
        const d = new Date(item.end);
        const mins = Math.round(item.actualSeconds/60);
        const tlabel = item.type==='focus'?'Focus':(item.type==='short'?'Short':'Long');
        const statusPill = item.status==='completed' ? '<span class="pill ok">completed</span>' : '<span class="pill skip">skipped</span>';
        return `
          <div class="log-item">
            <div>
              <span class="log-type ${item.type}">${tlabel}</span>
              <span class="log-meta">â€¢ ${fmtDate.format(d)} ${fmtTimeShort.format(d)}</span>
            </div>
            <div class="log-meta">${mins} min</div>
            <div>${statusPill}</div>
          </div>
        `;
      }).join('');
    }

    // Stats & charts
    function computeDailyAgg(days=7){
      const end = new Date();
      end.setHours(23,59,59,999);
      const buckets = [];
      for(let i=days-1;i>=0;i--){
        const day = new Date(end);
        day.setDate(end.getDate()-i);
        day.setHours(0,0,0,0);
        const key = day.toISOString().slice(0,10);
        buckets.push({ key, date: new Date(day), focusMin:0, breakMin:0 });
      }
      const map = Object.fromEntries(buckets.map(b=>[b.key,b]));
      for(const item of state.log){
        const d = new Date(item.end);
        const key = d.toISOString().slice(0,10);
        const mins = Math.round(item.actualSeconds/60);
        if(map[key]){
          if(item.type==='focus') map[key].focusMin += mins;
          else map[key].breakMin += mins;
        }
      }
      return buckets;
    }

    function renderStatsAndCharts(){
      // Today stats
      const todayKey = new Date().toISOString().slice(0,10);
      let todayFocusM=0,todayBreakM=0,todayFocusC=0,todayBreakC=0;
      for(const item of state.log){
        const k = new Date(item.end).toISOString().slice(0,10);
        if(k !== todayKey) continue;
        const mins = Math.round(item.actualSeconds/60);
        if(item.type==='focus'){ todayFocusM += mins; todayFocusC++; }
        else { todayBreakM += mins; todayBreakC++; }
      }
      els.statsToday.innerHTML = `Today â€¢ Focus: <b>${todayFocusC}</b> sessions, <b>${todayFocusM}</b> min â€¢ Break: <b>${todayBreakC}</b> sessions, <b>${todayBreakM}</b> min`;

      // Bar chart for last 7 days (focus minutes)
      const data = computeDailyAgg(7);
      const maxV = Math.max(30, ...data.map(d=>d.focusMin)); // avoid all-zero
      const W = 320, H = 120, padX = 20, padY = 22;
      const bw = (W - padX*2) / data.length - 8;
      const dayFmt = new Intl.DateTimeFormat(undefined, { weekday: 'short' });
      const bars = [];
      const labels = [];
      data.forEach((d, i)=>{
        const x = padX + i*((W - padX*2)/data.length) + 4;
        const h = Math.round(((d.focusMin) / maxV) * (H - padY*2));
        const y = H - padY - h;
        const col = getComputedStyle(document.documentElement).getPropertyValue('--accent-focus').trim();
        bars.push(`<rect x="${x}" y="${y}" width="${bw}" height="${h}" rx="6" fill="${col}" opacity="${d.focusMin>0?0.9:0.35}">
          <title>${dayFmt.format(d.date)}: ${d.focusMin} min focus</title>
        </rect>`);
        labels.push(`<text x="${x + bw/2}" y="${H - padY + 14}" text-anchor="middle" font-size="10" fill="${getComputedStyle(document.body).getPropertyValue('--muted') || '#888'}">${dayFmt.format(d.date).slice(0,1)}</text>`);
      });
      els.svgBarChart.innerHTML = `
        <rect x="0" y="0" width="${W}" height="${H}" rx="10" ry="10" fill="none"></rect>
        <line x1="${padX}" y1="${H-padY}" x2="${W-padX}" y2="${H-padY}" stroke="var(--line)" stroke-width="1"/>
        ${bars.join('')}
        ${labels.join('')}
      `;

      // Sparkline of last 10 sessions (all types)
      const last = state.log.slice(-10);
      const W2=320, H2=80, pad=14;
      if(last.length === 0){
        els.svgSparkline.innerHTML = `<text x="${W2/2}" y="${H2/2}" text-anchor="middle" dominant-baseline="middle" fill="var(--muted)" font-size="12">No data yet</text>`;
      }else{
        const vals = last.map(s=>Math.max(1, Math.round(s.actualSeconds/60)));
        const max = Math.max(...vals);
        const min = Math.min(...vals);
        const stepX = (W2 - pad*2) / Math.max(1, vals.length - 1);
        const points = vals.map((v,i)=>{
          const x = pad + i*stepX;
          const y = H2 - pad - ((v - min) / Math.max(1, (max - min))) * (H2 - pad*2);
          return [x,y];
        });
        const dpath = points.map((p,i)=> (i===0? 'M':'L') + p[0].toFixed(2) + ' ' + p[1].toFixed(2)).join(' ');
        const poly = points.map(p => p.join(',')).join(' ');
        const fill = 'url(#gradSpark)';
        const gradient = `
          <defs>
            <linearGradient id="gradSpark" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stop-color="var(--accent)" stop-opacity="0.35"/>
              <stop offset="100%" stop-color="var(--accent)" stop-opacity="0.05"/>
            </linearGradient>
          </defs>
        `;
        const circles = points.map((p, i)=>{
          const t = state.log[state.log.length - last.length + i];
          const col = t.type==='focus' ? 'var(--accent-focus)' : (t.type==='short' ? 'var(--accent-short)' : 'var(--accent-long)');
          return `<circle cx="${p[0]}" cy="${p[1]}" r="3" fill="${col}">
            <title>${typeLabel(t.type)}: ${Math.round(t.actualSeconds/60)} min</title>
          </circle>`;
        }).join('');
        els.svgSparkline.innerHTML = `
          ${gradient}
          <path d="${dpath}" fill="none" stroke="var(--accent)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
          <polygon points="${poly} ${W2-pad},${H2-pad} ${pad},${H2-pad}" fill="${fill}" opacity="0.6"></polygon>
          ${circles}
        `;
      }
    }

    // Event handlers
    els.btnStartPause.addEventListener('click', ()=>{
      if(state.running) pauseTimer();
      else startTimer();
    });
    els.btnReset.addEventListener('click', resetTimer);
    els.btnSkip.addEventListener('click', ()=>{
      if(state.running){
        pauseTimer();
      }
      skipSession();
    });
    els.btnTestBeep.addEventListener('click', beep);

    // Settings changes
    function onSettingsChanged(){
      const s = {
        focusMin: clampInt(els.inputFocus.value, 1, 180),
        shortMin: clampInt(els.inputShort.value, 1, 60),
        longMin: clampInt(els.inputLong.value, 1, 120),
        longEvery: clampInt(els.inputEvery.value, 2, 12),
        autoStart: !!els.toggleAutoStart.checked
      };
      state.settings = s;
      storage.saveSettings(s);
      // If timer is not running, align current session if same type
      if(!state.running){
        const target = scheduleFor(state.currentType);
        state.total = target;
        state.remaining = target;
        updateProgress();
      }
      renderStatsAndCharts();
    }
    ['input','change'].forEach(ev=>{
      els.inputFocus.addEventListener(ev, onSettingsChanged);
      els.inputShort.addEventListener(ev, onSettingsChanged);
      els.inputLong.addEventListener(ev, onSettingsChanged);
      els.inputEvery.addEventListener(ev, onSettingsChanged);
      els.toggleAutoStart.addEventListener(ev, onSettingsChanged);
    });

    // Dark mode
    function applyDarkMode(dark){
      document.body.classList.toggle('dark', dark);
      els.toggleDark.checked = dark;
      storage.saveDark(dark);
      renderStatsAndCharts(); // re-render for color vars
    }
    els.toggleDark.addEventListener('change', ()=> applyDarkMode(els.toggleDark.checked));

    // Keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      // Space: Start/Pause; R: Reset; S: Skip
      if(e.code === 'Space'){
        e.preventDefault();
        if(state.running) pauseTimer(); else startTimer();
      } else if(e.key.toLowerCase() === 'r'){
        resetTimer();
      } else if(e.key.toLowerCase() === 's'){
        if(state.running) pauseTimer();
        skipSession();
      }
    });

    // Initialize
    function init(){
      applySettingsToUI();
      setSession('focus');
      renderLog();
      renderStatsAndCharts();
      // Dark mode
      const dark = storage.loadDark();
      applyDarkMode(dark !== null ? dark : true);
      // Keep ring bg stroke width consistent on high DPI
      els.progressArc.previousElementSibling.setAttribute('stroke-width','10');
      // Greeting
      els.lblStatus.textContent = 'Ready';
    }
    init();

    // Visibility handling: pause when tab hidden (optional)
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden && state.running){
        // keep running without change
      }
    });
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <title>AI FM — A minimal, podcast-inspired single-page app</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0c10">
  <style>
    :root {
      --bg: #0b0c10;
      --panel: #11131a;
      --elev: #161925;
      --text: #e6e8ef;
      --muted: #a9afc3;
      --muted-2: #7b8196;
      --border: #222638;
      --accent: #6ae0ff;
      --accent-2: #48b6ff;
      --success: #65d687;
      --warn: #ffc857;
      --error: #ff6b6b;
      --shadow: 0 8px 24px rgba(0,0,0,0.35);
      --radius: 12px;
      --radius-sm: 8px;
      --radius-lg: 18px;
      --focus: 0 0 0 2px rgba(106,224,255,0.35), 0 0 0 4px rgba(106,224,255,0.22);
    }
    [data-theme="light"] {
      --bg: #f7f8fb;
      --panel: #ffffff;
      --elev: #ffffff;
      --text: #0e0f14;
      --muted: #4f566b;
      --muted-2: #6a728b;
      --border: #e5e9f2;
      --accent: #006bff;
      --accent-2: #398bff;
      --shadow: 0 8px 24px rgba(0,0,0,0.08);
      --focus: 0 0 0 2px rgba(0,107,255,0.25), 0 0 0 4px rgba(0,107,255,0.15);
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.4;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    button, input, select {
      font: inherit;
      color: inherit;
    }
    header {
      position: sticky; top: 0; z-index: 20;
      background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.2) 100%), var(--bg);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(8px);
    }
    .header-inner {
      max-width: 1200px; margin: 0 auto;
      display: grid; grid-template-columns: 220px 1fr 220px;
      gap: 16px; align-items: center;
      padding: 12px 20px;
    }
    .brand {
      display: flex; align-items: center; gap: 10px;
      font-weight: 700; letter-spacing: 0.4px;
    }
    .logo {
      width: 34px; height: 34px; border-radius: 10px;
      background: radial-gradient(60% 60% at 30% 30%, var(--accent) 0%, var(--accent-2) 35%, #5a36ff 100%);
      box-shadow: inset 0 0 12px rgba(255,255,255,0.2), 0 4px 16px rgba(0,0,0,0.25);
      display: grid; place-items: center;
      color: #000; font-weight: 800; font-size: 16px;
    }
    .search {
      display: flex; gap: 8px; align-items: center;
      background: var(--panel); border: 1px solid var(--border);
      padding: 6px 10px; border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .search input {
      background: transparent; outline: none; border: none; width: 100%;
      color: var(--text);
    }
    .header-actions {
      display: flex; justify-content: flex-end; gap: 8px;
    }
    .btn {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 12px; border-radius: var(--radius-sm);
      cursor: pointer; transition: transform .05s ease, border-color .2s ease, background .2s ease;
    }
    .btn:hover { transform: translateY(-1px); border-color: var(--accent-2); }
    .btn:focus-visible { outline: none; box-shadow: var(--focus); }
    .btn.primary { background: linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 100%); color: #02050a; border-color: transparent; }
    .btn.ghost { background: transparent; }
    .toggle {
      display: inline-flex; align-items: center; gap: 8px;
    }

    main {
      max-width: 1200px; margin: 0 auto; padding: 16px 20px;
      display: grid; grid-template-columns: 300px 1fr 280px; gap: 16px;
      min-height: calc(100vh - 72px);
    }
    aside, section, nav, article { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); }
    #leftSidebar, #rightSidebar { padding: 14px; }
    #leftSidebar h2, #rightSidebar h2, #playerSection h2 { font-size: 14px; text-transform: uppercase; letter-spacing: 0.12em; color: var(--muted); margin: 0 0 10px; }
    .chips { display: flex; flex-wrap: wrap; gap: 8px; }
    .chip {
      border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px;
      background: var(--elev); color: var(--muted);
      cursor: pointer; user-select: none;
    }
    .chip.active { background: rgba(106,224,255,0.12); border-color: var(--accent-2); color: var(--text); }
    .switch {
      display: inline-flex; align-items: center; gap: 8px; cursor: pointer; color: var(--muted);
      user-select: none;
    }
    .switch input { appearance: none; width: 38px; height: 22px; border-radius: 999px; background: #3a4054; position: relative; outline: none; transition: background .2s ease; border: 1px solid var(--border); }
    .switch input:checked { background: var(--accent-2); }
    .switch input::after {
      content: ""; position: absolute; top: 50%; left: 2px; transform: translateY(-50%);
      width: 18px; height: 18px; border-radius: 50%; background: white; transition: left .2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }
    .switch input:checked::after { left: 18px; }

    #episodeList {
      margin-top: 10px; list-style: none; padding: 0; margin-bottom: 0;
      display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 280px); overflow: auto;
    }
    .episode-item {
      background: var(--elev); border: 1px solid var(--border); border-radius: var(--radius-sm);
      padding: 10px; cursor: pointer; text-align: left; display: grid; gap: 6px;
    }
    .episode-item:hover { border-color: var(--accent-2); }
    .episode-item.active { outline: 2px solid var(--accent-2); }
    .epi-title { font-weight: 600; }
    .epi-meta { font-size: 12px; color: var(--muted); display: flex; gap: 10px; align-items: center; }
    .tag { font-size: 11px; padding: 3px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid var(--border); color: var(--muted-2); }

    #playerSection {
      padding: 18px; display: grid; grid-template-rows: auto auto 1fr; gap: 14px;
    }
    .episode-header { display: grid; gap: 8px; }
    .episode-header .title {
      font-size: 22px; font-weight: 700; letter-spacing: 0.2px;
    }
    .episode-header .sub { color: var(--muted); font-size: 13px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .episode-header .tags { display: flex; gap: 6px; flex-wrap: wrap; }
    .player {
      background: var(--elev); border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; display: grid; gap: 10px;
    }
    .progress {
      position: relative; height: 10px; background: rgba(255,255,255,0.06); border: 1px solid var(--border); border-radius: 999px; cursor: pointer;
    }
    .progress .fill {
      position: absolute; left: 0; top: 0; bottom: 0; width: 0%;
      background: linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 100%);
      border-radius: 999px;
    }
    .progress .thumb {
      position: absolute; top: 50%; transform: translate(-50%, -50%);
      width: 16px; height: 16px; background: #fff; border-radius: 50%;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
      left: 0%;
    }
    .times { display: flex; justify-content: space-between; font-size: 12px; color: var(--muted); }
    .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .controls .btn { padding: 8px 10px; }
    .controls .big {
      font-size: 16px; padding: 10px 14px; border-radius: 999px;
    }
    .spacer { flex: 1; }
    .volume {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--panel); border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px;
    }
    .volume input[type="range"] { width: 120px; }
    input[type="range"] {
      -webkit-appearance: none; appearance: none; height: 4px; background: rgba(255,255,255,0.15); border-radius: 999px; outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent-2);
      border-radius: 50%; border: 1px solid rgba(0,0,0,0.2);
    }
    .sections {
      display: grid; grid-template-columns: 1fr; gap: 14px;
    }
    .card {
      background: var(--elev); border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; display: grid; gap: 8px;
    }
    .card h3 {
      margin: 0; font-size: 15px; text-transform: uppercase; letter-spacing: .08em; color: var(--muted);
    }
    .notes { color: var(--text); }
    .transcript { max-height: 320px; overflow: auto; border-radius: var(--radius); background: var(--panel); border: 1px dashed var(--border); padding: 10px; }
    .line { padding: 8px; border-radius: 8px; display: grid; grid-template-columns: 70px 1fr; gap: 8px; align-items: baseline; cursor: pointer; }
    .line:hover { background: rgba(255,255,255,0.05); }
    .line .ts { font-size: 12px; color: var(--muted-2); }
    .line.active { background: rgba(106,224,255,0.12); outline: 1px solid var(--accent-2); }
    mark { background: rgba(255,235,59,0.35); color: inherit; border-radius: 3px; padding: 0 2px; }

    #rightSidebar .card { margin-bottom: 10px; }
    #rightSidebar .kbd { display: inline-block; min-width: 26px; padding: 4px 6px; text-align: center; border: 1px solid var(--border); border-radius: 6px; background: var(--panel); color: var(--muted); }

    footer {
      max-width: 1200px; margin: 10px auto 24px; padding: 0 20px; color: var(--muted); font-size: 12px;
    }

    /* Responsive */
    @media (max-width: 1100px) {
      main { grid-template-columns: 280px 1fr; }
      #rightSidebar { display: none; }
      .header-inner { grid-template-columns: 180px 1fr 160px; }
    }
    @media (max-width: 800px) {
      .header-inner { grid-template-columns: 1fr; gap: 10px; }
      .brand { justify-content: space-between; }
      main { grid-template-columns: 1fr; }
      #leftSidebar { order: 2; }
      #playerSection { order: 1; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-inner">
      <div class="brand" aria-label="AI FM Home">
        <div class="logo" aria-hidden="true">AI</div>
        <div>
          <div>AI FM</div>
          <div style="font-size: 11px; color: var(--muted);">Conversations on intelligence</div>
        </div>
      </div>

      <div class="search" role="search">
        <svg aria-hidden="true" width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M21 21l-4.3-4.3m1.8-5.2a7 7 0 11-14 0 7 7 0 0114 0z" stroke="currentColor" stroke-width="2" opacity="0.6" /></svg>
        <input id="globalSearchInput" type="search" placeholder="Search episodes, topics..." aria-label="Search episodes" />
      </div>

      <div class="header-actions">
        <button id="shortcutsBtn" class="btn ghost" title="Keyboard shortcuts (question mark)">?</button>
        <button id="appThemeToggle" class="btn" aria-pressed="false" title="Toggle theme">Toggle theme</button>
      </div>
    </div>
  </header>

  <main>
    <aside id="leftSidebar" aria-label="Filters and episodes">
      <h2>Filters</h2>
      <div class="chips" id="tagFilters" aria-label="Tag filters"></div>
      <div style="display:flex; justify-content: space-between; align-items: center; margin-top: 10px;">
        <label class="switch" title="Show only favorites">
          <input id="favoritesSwitch" type="checkbox" />
          <span>Favorites only</span>
        </label>
        <span id="resultsCount" style="color: var(--muted-2); font-size: 12px;">0 results</span>
      </div>

      <h2 style="margin-top:14px">Episodes</h2>
      <nav aria-label="Episode list">
        <ul id="episodeList"></ul>
      </nav>
    </aside>

    <section id="playerSection" aria-label="Player and content">
      <div class="episode-header">
        <div class="title" id="episodeTitle">Select an episode</div>
        <div class="sub">
          <span id="episodeMeta">—</span>
          <span class="tags" id="episodeTags"></span>
        </div>
      </div>

      <div class="player" aria-label="Audio player">
        <div class="progress" id="progressBar" role="slider" aria-label="Seek" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0">
          <div class="fill" id="progressFill"></div>
          <div class="thumb" id="progressThumb" aria-hidden="true"></div>
        </div>
        <div class="times">
          <div id="currentTime">00:00</div>
          <div id="durationTime">00:00</div>
        </div>
        <div class="controls">
          <button id="prevBtn" class="btn" title="Previous (Shift+P)">⏮  Prev</button>
          <button id="skipBackBtn" class="btn" title="Back 15s (J)">⏪ 15s</button>
          <button id="playPauseBtn" class="btn big primary" title="Play / Pause (Space or K)">▶ Play</button>
          <button id="skipFwdBtn" class="btn" title="Forward 15s (L)">⏩ 15s</button>
          <button id="nextBtn" class="btn" title="Next (Shift+N)">Next ⏭</button>

          <div class="spacer"></div>

          <button id="playbackSpeedBtn" class="btn" title="Playback speed (S)">1.0x</button>
          <div class="volume">
            <span style="font-size:12px; color: var(--muted)">Vol</span>
            <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.8" aria-label="Volume" />
          </div>
          <button id="loopBtn" class="btn" aria-pressed="false" title="Loop on/off">Loop</button>
          <button id="favoriteBtn" class="btn" aria-pressed="false" title="Toggle favorite">☆ Favorite</button>
          <button id="shareBtn" class="btn" title="Copy sharable link">Share</button>
        </div>
      </div>

      <div class="sections">
        <div class="card">
          <h3>Show Notes</h3>
          <div class="notes" id="showNotes">
            Choose an episode from the left to view detailed notes and transcript.
          </div>
        </div>

        <div class="card">
          <div style="display:flex; align-items:center; justify-content: space-between;">
            <h3 style="margin-right:10px;">Transcript</h3>
            <div style="display:flex; align-items:center; gap: 10px;">
              <label class="switch" title="Auto-scroll transcript">
                <input id="autoScrollSwitch" type="checkbox" checked />
                <span>Auto-scroll</span>
              </label>
              <input id="transcriptSearchInput" type="search" placeholder="Search transcript..." style="background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; color: var(--text);" />
              <button id="transcriptToggleBtn" class="btn">Hide</button>
            </div>
          </div>
          <div class="transcript" id="transcriptContainer" aria-live="polite"></div>
        </div>
      </div>
    </section>

    <aside id="rightSidebar" aria-label="About and shortcuts">
      <div class="card">
        <h2>About</h2>
        <p style="color: var(--muted); margin-top: 0;">AI FM is a minimal, single-file app inspired by modern podcast sites. It showcases:
        </p>
        <ul style="margin: 0 0 0 18px; color: var(--muted);">
          <li>Semantic HTML, CSS Grid/Flex</li>
          <li>Vanilla JavaScript interactivity</li>
          <li>Responsive layout and keyboard support</li>
          <li>Tag filtering and transcript search</li>
        </ul>
      </div>
      <div class="card">
        <h2>Shortcuts</h2>
        <p style="margin: 6px 0; color: var(--muted);">
          <span class="kbd">/</span> Focus search
        </p>
        <p style="margin: 6px 0; color: var(--muted);">
          <span class="kbd">Space</span> / <span class="kbd">K</span> Play/Pause
        </p>
        <p style="margin: 6px 0; color: var(--muted);">
          <span class="kbd">J</span> -15s, <span class="kbd">L</span> +15s
        </p>
        <p style="margin: 6px 0; color: var(--muted);">
          <span class="kbd">S</span> Change speed
        </p>
        <p style="margin: 6px 0; color: var(--muted);">
          <span class="kbd">Shift</span>+<span class="kbd">N</span>/<span class="kbd">P</span> Next/Prev
        </p>
        <p style="margin: 6px 0; color: var(--muted);">
          <span class="kbd">?</span> Toggle shortcuts overlay
        </p>
      </div>
      <div class="card" id="shortcutsOverlay" hidden>
        <h2>Keyboard Help</h2>
        <p style="color: var(--muted);">Use the listed shortcuts anywhere to control playback and navigation.</p>
      </div>
    </aside>
  </main>

  <footer>
    Built with HTML5, CSS3, and vanilla JavaScript. No external libraries. Demo audio is generative.
  </footer>

  <script>
  // Data model: demo episodes
  const episodes = [
    {
      id: "ep-01",
      title: "Frontiers: Reasoning with small models",
      date: "2025-01-08",
      durationSec: 16 * 60 + 20,
      tags: ["Research", "Alignment"],
      summary: "We explore how smaller models can still reason effectively with the right training curriculum and tools.",
      notes: [
        "Overview of curriculum learning for reasoning tasks.",
        "Scaling laws vs. technique: when data/compute are not the only levers.",
        "Tool use and structured prompting for compositional tasks.",
        "Safety considerations for tool-augmented systems."
      ],
      transcript: [
        { t: 0, text: "Welcome to AI FM. Today, we discuss how small models can reason with the right tools." },
        { t: 28, text: "Historically, gains came from scaling compute and data, but techniques also matter." },
        { t: 58, text: "Curriculum learning remains underused and can simplify complex tasks." },
        { t: 96, text: "Tool use: planners, verifiers, and retrievers augment limited capacity." },
        { t: 138, text: "We highlight benchmarks where composition outperforms brute force." },
        { t: 176, text: "Safety: aligning tool access with model uncertainty is essential." },
        { t: 228, text: "Takeaways: blend training, tools, and evaluation for robust reasoning." },
      ]
    },
    {
      id: "ep-02",
      title: "Engineering: Building reliable evals",
      date: "2025-02-12",
      durationSec: 21 * 60 + 15,
      tags: ["Engineering", "DevTools"],
      summary: "We dig into building reproducible evaluations, telemetry, and test harnesses for AI systems.",
      notes: [
        "Versioning prompts, models, and datasets.",
        "Ground-truth design and adjudication.",
        "Regression detection and confidence intervals.",
        "Human-in-the-loop feedback capture."
      ],
      transcript: [
        { t: 0, text: "Evals are the compass for model development, yet often overlooked." },
        { t: 40, text: "Version everything: from prompts to sampling params and datasets." },
        { t: 86, text: "Use seed control and stratified sampling to stabilize scores." },
        { t: 132, text: "Confidence intervals tell you when a delta is noise." },
        { t: 180, text: "Humans provide nuance—build frictionless feedback loops." },
        { t: 260, text: "Share evals to align researchers and product teams." },
      ]
    },
    {
      id: "ep-03",
      title: "Policy: Interpreting AI risk",
      date: "2025-03-18",
      durationSec: 18 * 60 + 42,
      tags: ["Policy"],
      summary: "An overview of AI risk taxonomies, threat models, and the role of standards.",
      notes: [
        "Taxonomies: misuse, accident, structural shifts.",
        "Threat modeling for capability thresholds.",
        "Standards and reporting for transparency.",
        "Iterating policies with empirical evidence."
      ],
      transcript: [
        { t: 0, text: "Policy debates benefit from concrete threat models and testable claims." },
        { t: 30, text: "Maturity models can guide safeguards as capabilities rise." },
        { t: 78, text: "Transparency is a spectrum; standards narrow ambiguity." },
        { t: 140, text: "Iterate policies with real-world incident data." }
      ]
    },
    {
      id: "ep-04",
      title: "Product: From prototype to production",
      date: "2025-04-10",
      durationSec: 24 * 60 + 5,
      tags: ["Product", "Engineering"],
      summary: "How to reduce latency, control costs, and maintain quality as AI features scale.",
      notes: [
        "Measure first: trace spans, cache hit rates, and SLA errors.",
        "Latency budgets and progressive enhancement.",
        "Fallbacks, guardrails, and red teaming in prod.",
        "Observability for model drift."
      ],
      transcript: [
        { t: 0, text: "Shipping AI products is about systems, not just models." },
        { t: 52, text: "Caching strategies cut cost while preserving safety." },
        { t: 120, text: "Design for graceful degradation and clear user feedback." },
        { t: 200, text: "Monitor cohort performance to catch regressions early." }
      ]
    },
    {
      id: "ep-05",
      title: "Alignment: Verifiers and debate",
      date: "2025-05-20",
      durationSec: 17 * 60 + 8,
      tags: ["Alignment", "Research"],
      summary: "We examine verifier models and adversarial debate as tools for reliability.",
      notes: [
        "Verifier architectures and training targets.",
        "Adversarial debate dynamics and social choice.",
        "Failure modes: collusion, gradient hacking.",
        "Open questions and promising directions."
      ],
      transcript: [
        { t: 0, text: "Verifiers aim to separate truth from fluency." },
        { t: 48, text: "Debate can surface inconsistencies when structured well." },
        { t: 104, text: "Failure modes remind us to measure beyond accuracy." },
        { t: 168, text: "Research outlook: scalable oversight remains key." }
      ]
    }
  ];

  // Global State
  const state = {
    filteredTags: new Set(),
    favoritesOnly: false,
    favorites: new Set(JSON.parse(localStorage.getItem("aifm:favorites") || "[]")),
    theme: localStorage.getItem("aifm:theme") || "dark",
    speed: 1.0,
    playing: false,
    loop: false,
    volume: parseFloat(localStorage.getItem("aifm:volume") || "0.8"),
    selectedId: localStorage.getItem("aifm:lastEpisodeId") || episodes[0].id,
    playhead: parseFloat(localStorage.getItem("aifm:lastPlayhead") || "0"),
    dragSeeking: false,
    autoScroll: localStorage.getItem("aifm:autoScroll") !== "false",
    transcriptVisible: true,
  };

  // UI Elements
  const el = (id) => document.getElementById(id);
  const tagFiltersEl = el("tagFilters");
  const episodeListEl = el("episodeList");
  const resultsCountEl = el("resultsCount");
  const favoritesSwitchEl = el("favoritesSwitch");
  const searchEl = el("globalSearchInput");
  const themeToggleEl = el("appThemeToggle");
  const shortcutsBtn = el("shortcutsBtn");
  const shortcutsOverlay = el("shortcutsOverlay");

  const titleEl = el("episodeTitle");
  const metaEl = el("episodeMeta");
  const epTagsEl = el("episodeTags");
  const notesEl = el("showNotes");

  const progressBar = el("progressBar");
  const progressFill = el("progressFill");
  const progressThumb = el("progressThumb");
  const currentTimeEl = el("currentTime");
  const durationTimeEl = el("durationTime");

  const prevBtn = el("prevBtn");
  const nextBtn = el("nextBtn");
  const skipBackBtn = el("skipBackBtn");
  const skipFwdBtn = el("skipFwdBtn");
  const playPauseBtn = el("playPauseBtn");
  const playbackSpeedBtn = el("playbackSpeedBtn");
  const volumeSlider = el("volumeSlider");
  const loopBtn = el("loopBtn");
  const favoriteBtn = el("favoriteBtn");
  const shareBtn = el("shareBtn");

  const transcriptContainer = el("transcriptContainer");
  const transcriptToggleBtn = el("transcriptToggleBtn");
  const transcriptSearchInput = el("transcriptSearchInput");
  const autoScrollSwitch = el("autoScrollSwitch");

  // Theme
  function applyTheme() {
    document.documentElement.setAttribute("data-theme", state.theme === "light" ? "light" : "dark");
    const pressed = state.theme === "light";
    themeToggleEl.setAttribute("aria-pressed", String(pressed));
    themeToggleEl.textContent = state.theme === "light" ? "Dark mode" : "Light mode";
    localStorage.setItem("aifm:theme", state.theme);
  }
  themeToggleEl.addEventListener("click", () => {
    state.theme = state.theme === "light" ? "dark" : "light";
    applyTheme();
  });
  applyTheme();

  // Search + Filters
  const allTags = Array.from(new Set(episodes.flatMap(e => e.tags))).sort();

  function renderTags() {
    tagFiltersEl.innerHTML = "";
    allTags.forEach(tag => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "chip";
      btn.textContent = tag;
      btn.setAttribute("aria-pressed", "false");
      btn.addEventListener("click", () => {
        if (state.filteredTags.has(tag)) {
          state.filteredTags.delete(tag);
        } else {
          state.filteredTags.add(tag);
        }
        btn.classList.toggle("active", state.filteredTags.has(tag));
        btn.setAttribute("aria-pressed", String(state.filteredTags.has(tag)));
        renderEpisodeList();
      });
      tagFiltersEl.appendChild(btn);
    });
  }

  favoritesSwitchEl.checked = state.favoritesOnly;
  favoritesSwitchEl.addEventListener("input", () => {
    state.favoritesOnly = favoritesSwitchEl.checked;
    renderEpisodeList();
  });

  let searchTerm = "";
  searchEl.addEventListener("input", () => { searchTerm = searchEl.value.trim().toLowerCase(); renderEpisodeList(); });

  // Episode list rendering
  function formatDate(d) {
    const dt = new Date(d + "T00:00:00");
    return dt.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
  }
  function mmss(sec) {
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }
  function renderEpisodeList() {
    const filtered = episodes.filter(e => {
      if (state.filteredTags.size && !e.tags.some(t => state.filteredTags.has(t))) return false;
      if (state.favoritesOnly && !state.favorites.has(e.id)) return false;
      if (searchTerm) {
        const hay = [e.title, e.summary, e.tags.join(" ")].join(" ").toLowerCase();
        if (!hay.includes(searchTerm)) return false;
      }
      return true;
    });

    episodeListEl.innerHTML = "";
    filtered.forEach(e => {
      const li = document.createElement("li");
      const btn = document.createElement("button");
      btn.id = `episodeItem-${e.id}`;
      btn.className = "episode-item" + (state.selectedId === e.id ? " active" : "");
      btn.innerHTML = `
        <div class="epi-title">${e.title}</div>
        <div class="epi-meta">
          <span>${formatDate(e.date)}</span>
          <span>•</span>
          <span>${mmss(e.durationSec)}</span>
        </div>
        <div style="display:flex; gap:6px; flex-wrap: wrap;">
          ${e.tags.map(t => `<span class="tag">${t}</span>`).join("")}
        </div>
      `;
      btn.addEventListener("click", () => selectEpisode(e.id, true));
      li.appendChild(btn);
      episodeListEl.appendChild(li);
    });
    resultsCountEl.textContent = `${filtered.length} result${filtered.length === 1 ? "" : "s"}`;
  }

  function ensureVisibleSelectedInList() {
    const active = document.querySelector(`#episodeItem-${CSS.escape(state.selectedId)}`);
    if (active) {
      active.scrollIntoView({ block: "nearest" });
    }
  }

  // Player Engine - Generative tone (WebAudio)
  const AudioEngine = (() => {
    let ctx;
    let gain;
    let osc;
    let pan;
    let baseHz = 220;
    let started = false;
    function ensureContext() {
      if (!ctx) {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return ctx;
    }
    function setup() {
      const c = ensureContext();
      gain = gain || c.createGain();
      gain.gain.value = 0.0;

      osc = c.createOscillator();
      osc.type = "sine";
      pan = c.createStereoPanner ? c.createStereoPanner() : null;

      if (pan) {
        osc.connect(pan);
        pan.connect(gain);
      } else {
        osc.connect(gain);
      }
      gain.connect(c.destination);
      osc.start();
      started = true;
    }
    function setBaseFreq(hz) {
      baseHz = hz;
    }
    function setVolume(v) {
      if (!gain) return;
      gain.gain.setTargetAtTime(state.playing ? v : 0, ensureContext().currentTime, 0.02);
    }
    function play() {
      ensureContext().resume();
      if (!started) setup();
      state.playing = true;
      setVolume(state.volume);
    }
    function pause() {
      state.playing = false;
      if (gain) {
        gain.gain.setTargetAtTime(0.0, ensureContext().currentTime, 0.02);
      }
    }
    function refresh(timeSec) {
      if (!osc) return;
      // Simple generative mapping: vary frequency and panning with "time"
      const freq = baseHz + 30 * Math.sin(timeSec / 7) + 10 * Math.cos(timeSec / 3);
      osc.frequency.setTargetAtTime(Math.max(80, freq), ensureContext().currentTime, 0.015);
      if (pan) {
        const p = Math.sin(timeSec / 5) * 0.5;
        pan.pan.setTargetAtTime(p, ensureContext().currentTime, 0.03);
      }
    }
    return { play, pause, setVolume, setBaseFreq, refresh, ensureContext };
  })();

  // Player state helpers
  function getSelectedEpisode() {
    return episodes.find(e => e.id === state.selectedId);
  }

  function setSpeed(next) {
    state.speed = next;
    playbackSpeedBtn.textContent = `${state.speed.toFixed(2).replace(/\.00$/,".0")}x`;
  }

  function cycleSpeed() {
    const speeds = [0.75, 1.0, 1.25, 1.5, 1.75, 2.0];
    const i = speeds.indexOf(state.speed);
    const next = speeds[(i + 1) % speeds.length];
    setSpeed(next);
  }

  function setPlaying(yes) {
    state.playing = yes;
    playPauseBtn.textContent = yes ? "⏸ Pause" : "▶ Play";
    if (yes) AudioEngine.play(); else AudioEngine.pause();
  }

  function setVolume(v) {
    state.volume = Math.max(0, Math.min(1, v));
    volumeSlider.value = String(state.volume);
    AudioEngine.setVolume(state.volume);
    localStorage.setItem("aifm:volume", state.volume);
  }

  function setLoop(on) {
    state.loop = on;
    loopBtn.setAttribute("aria-pressed", String(on));
    loopBtn.textContent = on ? "Loop: On" : "Loop: Off";
  }

  function updateProgressUI() {
    const ep = getSelectedEpisode();
    if (!ep) return;
    const clamped = Math.max(0, Math.min(ep.durationSec, state.playhead));
    const pct = ep.durationSec ? (clamped / ep.durationSec) * 100 : 0;
    progressFill.style.width = `${pct}%`;
    progressThumb.style.left = `${pct}%`;
    progressBar.setAttribute("aria-valuenow", String(Math.round(pct)));
    currentTimeEl.textContent = mmss(clamped);
    durationTimeEl.textContent = mmss(ep.durationSec);
  }

  // Transcript
  let lastActiveLineIndex = -1;

  function renderTranscript() {
    const ep = getSelectedEpisode();
    if (!ep) {
      transcriptContainer.innerHTML = "";
      return;
    }
    const q = transcriptSearchInput.value.trim().toLowerCase();
    transcriptContainer.innerHTML = "";
    ep.transcript.forEach((seg, idx) => {
      const row = document.createElement("div");
      row.className = "line";
      row.dataset.idx = String(idx);
      const ts = document.createElement("div");
      ts.className = "ts";
      ts.textContent = mmss(seg.t);
      const content = document.createElement("div");
      content.className = "txt";
      if (q && seg.text.toLowerCase().includes(q)) {
        // highlight
        const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "ig");
        content.innerHTML = seg.text.replace(re, (m) => `<mark>${m}</mark>`);
      } else {
        content.textContent = seg.text;
      }
      row.appendChild(ts);
      row.appendChild(content);
      row.addEventListener("click", () => {
        state.playhead = seg.t;
        updateProgressUI();
        if (!state.playing) setPlaying(true);
      });
      transcriptContainer.appendChild(row);
    });
    lastActiveLineIndex = -1;
  }

  function updateTranscriptActive() {
    if (!state.transcriptVisible) return;
    const ep = getSelectedEpisode();
    if (!ep || !ep.transcript || !ep.transcript.length) return;
    const time = state.playhead;
    let idx = ep.transcript.length - 1;
    for (let i = 0; i < ep.transcript.length; i++) {
      if (time < ep.transcript[i].t) { idx = Math.max(0, i - 1); break; }
    }
    const lines = transcriptContainer.querySelectorAll(".line");
    if (idx !== lastActiveLineIndex) {
      lines.forEach(l => l.classList.remove("active"));
      const active = lines[idx];
      if (active) {
        active.classList.add("active");
        if (state.autoScroll && state.playing) {
          active.scrollIntoView({ block: "nearest" });
        }
      }
      lastActiveLineIndex = idx;
    }
  }

  // Show notes
  function renderNotes() {
    const ep = getSelectedEpisode();
    if (!ep) {
      notesEl.textContent = "Choose an episode to view details.";
      return;
    }
    const bullets = ep.notes.map(n => `<li>${escapeHTML(n)}</li>`).join("");
    notesEl.innerHTML = `
      <p>${escapeHTML(ep.summary)}</p>
      <ul style="margin:0 0 0 18px;">${bullets}</ul>
    `;
  }

  function escapeHTML(s) {
    return s.replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
  }

  // Select episode
  function selectEpisode(id, updateURL=false) {
    const ep = episodes.find(e => e.id === id);
    if (!ep) return;
    state.selectedId = ep.id;
    localStorage.setItem("aifm:lastEpisodeId", state.selectedId);

    // Update header
    titleEl.textContent = ep.title;
    metaEl.textContent = `${formatDate(ep.date)} • ${mmss(ep.durationSec)}`;
    epTagsEl.innerHTML = ep.tags.map(t => `<span class="tag">${t}</span>`).join("");

    // Reset/restore playhead if switching
    state.playhead = (state.playing && state.selectedId === id) ? state.playhead : 0;
    updateProgressUI();

    // Set favorite state
    const fav = state.favorites.has(ep.id);
    favoriteBtn.setAttribute("aria-pressed", String(fav));
    favoriteBtn.textContent = fav ? "★ Favorited" : "☆ Favorite";

    // Update engine base frequency per episode
    const seed = Array.from(ep.id).reduce((a, c) => a + c.charCodeAt(0), 0);
    const baseHz = 140 + (seed % 180);
    AudioEngine.setBaseFreq(baseHz);

    renderNotes();
    renderTranscript();

    renderEpisodeList();
    ensureVisibleSelectedInList();

    if (updateURL) {
      history.replaceState(null, "", `#${encodeURIComponent(ep.id)}`);
    }
  }

  // Playback controls
  function prevEpisode() {
    const idx = episodes.findIndex(e => e.id === state.selectedId);
    const prev = episodes[(idx - 1 + episodes.length) % episodes.length];
    selectEpisode(prev.id, true);
    setPlaying(true);
  }
  function nextEpisode() {
    const idx = episodes.findIndex(e => e.id === state.selectedId);
    const next = episodes[(idx + 1) % episodes.length];
    selectEpisode(next.id, true);
    setPlaying(true);
  }
  prevBtn.addEventListener("click", prevEpisode);
  nextBtn.addEventListener("click", nextEpisode);

  skipBackBtn.addEventListener("click", () => {
    state.playhead = Math.max(0, state.playhead - 15);
    setPlaying(true);
    updateProgressUI();
  });
  skipFwdBtn.addEventListener("click", () => {
    const ep = getSelectedEpisode();
    state.playhead = Math.min(ep.durationSec, state.playhead + 15);
    setPlaying(true);
    updateProgressUI();
  });

  playPauseBtn.addEventListener("click", () => setPlaying(!state.playing));

  playbackSpeedBtn.addEventListener("click", () => cycleSpeed());
  setSpeed(state.speed);

  volumeSlider.addEventListener("input", (e) => setVolume(parseFloat(e.target.value)));
  setVolume(state.volume);

  loopBtn.addEventListener("click", () => setLoop(!state.loop));
  setLoop(state.loop);

  favoriteBtn.addEventListener("click", () => {
    const id = state.selectedId;
    if (state.favorites.has(id)) state.favorites.delete(id); else state.favorites.add(id);
    localStorage.setItem("aifm:favorites", JSON.stringify(Array.from(state.favorites)));
    favoriteBtn.setAttribute("aria-pressed", String(state.favorites.has(id)));
    favoriteBtn.textContent = state.favorites.has(id) ? "★ Favorited" : "☆ Favorite";
    renderEpisodeList();
  });

  shareBtn.addEventListener("click", async () => {
    const url = location.origin + location.pathname + `#${encodeURIComponent(state.selectedId)}`;
    try {
      await navigator.clipboard.writeText(url);
      toast("Link copied!");
    } catch {
      prompt("Copy link:", url);
    }
  });

  // Transcript toggling and search
  transcriptToggleBtn.addEventListener("click", () => {
    state.transcriptVisible = !state.transcriptVisible;
    transcriptContainer.style.display = state.transcriptVisible ? "block" : "none";
    transcriptToggleBtn.textContent = state.transcriptVisible ? "Hide" : "Show";
  });
  autoScrollSwitch.checked = state.autoScroll;
  autoScrollSwitch.addEventListener("input", () => {
    state.autoScroll = autoScrollSwitch.checked;
    localStorage.setItem("aifm:autoScroll", String(state.autoScroll));
  });

  let transcriptSearchDebounce;
  transcriptSearchInput.addEventListener("input", () => {
    clearTimeout(transcriptSearchDebounce);
    transcriptSearchDebounce = setTimeout(() => {
      renderTranscript();
      updateTranscriptActive();
    }, 120);
  });

  // Progress bar interactions
  function setPlayheadByClientX(clientX) {
    const ep = getSelectedEpisode();
    const rect = progressBar.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    state.playhead = pct * ep.durationSec;
    updateProgressUI();
  }
  progressBar.addEventListener("mousedown", (e) => {
    state.dragSeeking = true;
    setPlayheadByClientX(e.clientX);
    document.addEventListener("mousemove", onDrag);
    document.addEventListener("mouseup", onStopDrag, { once: true });
    e.preventDefault();
  });
  function onDrag(e) { if (state.dragSeeking) setPlayheadByClientX(e.clientX); }
  function onStopDrag() { state.dragSeeking = false; document.removeEventListener("mousemove", onDrag); }

  // Keyboard for progress slider
  progressBar.addEventListener("keydown", (e) => {
    const ep = getSelectedEpisode();
    if (!ep) return;
    const step = 5;
    if (e.key === "ArrowRight") { state.playhead = Math.min(ep.durationSec, state.playhead + step); e.preventDefault(); }
    if (e.key === "ArrowLeft")  { state.playhead = Math.max(0, state.playhead - step); e.preventDefault(); }
    if (e.key === "Home") { state.playhead = 0; e.preventDefault(); }
    if (e.key === "End") { state.playhead = ep.durationSec; e.preventDefault(); }
    updateProgressUI();
  });

  // Global keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    if (e.key === "/" && document.activeElement !== searchEl) {
      searchEl.focus(); e.preventDefault();
    }
    if (e.key.toLowerCase() === "k" || (e.code === "Space" && !isTyping(e))) {
      setPlaying(!state.playing); e.preventDefault();
    }
    if (e.key.toLowerCase() === "j") { skipBackBtn.click(); e.preventDefault(); }
    if (e.key.toLowerCase() === "l") { skipFwdBtn.click(); e.preventDefault(); }
    if (e.key.toLowerCase() === "s") { cycleSpeed(); e.preventDefault(); }
    if (e.shiftKey && e.key.toLowerCase() === "n") { nextEpisode(); e.preventDefault(); }
    if (e.shiftKey && e.key.toLowerCase() === "p") { prevEpisode(); e.preventDefault(); }
    if (e.key === "?") { toggleShortcutsOverlay(); e.preventDefault(); }
  });
  function isTyping(e) {
    const tag = document.activeElement?.tagName?.toLowerCase();
    return tag === "input" || tag === "textarea" || document.activeElement?.isContentEditable;
  }

  shortcutsBtn.addEventListener("click", toggleShortcutsOverlay);
  function toggleShortcutsOverlay() {
    const hidden = shortcutsOverlay.hasAttribute("hidden");
    if (hidden) shortcutsOverlay.removeAttribute("hidden"); else shortcutsOverlay.setAttribute("hidden", "");
  }

  // Hash routing
  window.addEventListener("hashchange", () => {
    const id = decodeURIComponent(location.hash.replace(/^#/, ""));
    if (episodes.some(e => e.id === id)) {
      selectEpisode(id, false);
    }
  });

  // Toast
  let toastEl;
  function toast(msg) {
    if (!toastEl) {
      toastEl = document.createElement("div");
      toastEl.style.position = "fixed";
      toastEl.style.bottom = "20px";
      toastEl.style.left = "50%";
      toastEl.style.transform = "translateX(-50%)";
      toastEl.style.background = "var(--elev)";
      toastEl.style.border = "1px solid var(--border)";
      toastEl.style.color = "var(--text)";
      toastEl.style.padding = "10px 14px";
      toastEl.style.borderRadius = "10px";
      toastEl.style.boxShadow = "var(--shadow)";
      toastEl.style.zIndex = "999";
      document.body.appendChild(toastEl);
    }
    toastEl.textContent = msg;
    toastEl.style.opacity = "1";
    setTimeout(() => { if (toastEl) toastEl.style.opacity = "0"; }, 1200);
  }

  // Main loop
  let lastFrame = performance.now();
  function tick(now) {
    const dt = Math.min(0.25, (now - lastFrame) / 1000); // clamp to avoid big jumps
    lastFrame = now;
    const ep = getSelectedEpisode();

    if (ep && state.playing && !state.dragSeeking) {
      state.playhead += dt * state.speed;
      if (state.playhead >= ep.durationSec) {
        if (state.loop) {
          state.playhead = 0;
        } else {
          state.playhead = ep.durationSec;
          setPlaying(false);
        }
      }
    }

    // Update audio engine characteristics based on playhead
    AudioEngine.refresh(state.playhead);

    // UI updates
    updateProgressUI();
    updateTranscriptActive();

    // Persist playhead occasionally
    if (ep && Math.random() < 0.05) {
      localStorage.setItem("aifm:lastPlayhead", String(state.playhead));
    }

    requestAnimationFrame(tick);
  }

  // Initialize
  function initFromHash() {
    const hashId = decodeURIComponent(location.hash.replace(/^#/, ""));
    const id = episodes.some(e => e.id === hashId) ? hashId : state.selectedId;
    selectEpisode(id, true);
  }

  renderTags();
  renderEpisodeList();
  initFromHash();
  ensureVisibleSelectedInList();
  requestAnimationFrame(tick);

  // Accessibility props for slider
  progressBar.addEventListener("focus", () => progressBar.classList.add("focus"));
  progressBar.addEventListener("blur", () => progressBar.classList.remove("focus"));

  // Prevent spacebar from scrolling when focused on body
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space" && !isTyping(e)) e.preventDefault();
  });

  // Improve first interaction: resume AudioContext (required by some browsers)
  document.addEventListener("click", () => { try { AudioEngine.ensureContext().resume(); } catch {} }, { once: true });

  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Online Whiteboard</title>
<style>
/* 
  Online Whiteboard - Destylized, Accessible, Operator-Friendly
  Design goals:
  - High contrast, flat design, no shadows or gradients
  - Large touch-friendly hit targets (>=44px)
  - Clear labels and visible status proxies
  - All core controls visible within 1280x720
*/

/* Reset and base */
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; padding: 0; }
body {
  background: #ffffff;
  color: #000000;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  line-height: 1.4;
}

/* Simple focus ring for keyboard navigation */
:focus {
  outline: 2px solid #000000;
  outline-offset: 2px;
}

/* Layout */
#topBar {
  position: fixed;
  inset: 0 0 auto 0;
  height: 56px;
  background: #ffffff;
  border-bottom: 1px solid #000000;
  display: flex;
  align-items: stretch;
  justify-content: space-between;
  z-index: 50;
}

#brandArea {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  border-right: 1px solid #000000;
}
#brandIcon {
  width: 20px; height: 20px; display: inline-block;
  border: 2px solid #000000; background: #ffffff;
}
#brandTitle { font-weight: 700; letter-spacing: 0.2px; user-select: none; }

#toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  flex: 1 1 auto;
}

/* Grouping */
.tool-group, .control-group, .action-group {
  display: flex;
  align-items: center;
  gap: 12px;
}
.divider {
  width: 1px;
  height: 44px;
  background: #000000;
}

/* Buttons */
button, .button {
  appearance: none;
  border: 1px solid #000000;
  background: #ffffff;
  color: #000000;
  height: 44px;
  min-width: 44px;
  padding: 8px 12px;
  display: inline-flex; align-items: center; justify-content: center;
  font-size: 14px; font-weight: 600;
  cursor: pointer;
  user-select: none;
}
button[disabled], .button[aria-disabled="true"] {
  opacity: 0.5; cursor: not-allowed;
}
.toolbar-btn { min-width: 44px; }
.toolbar-btn .icon { width: 18px; height: 18px; display: inline-block; margin-right: 8px; border: 1px solid #000; background: #fff; }
.toolbar-btn.active, .tool-btn.active {
  background: #000000;
  color: #ffffff;
  border-color: #000000;
}
.primary-btn {
  background: #000000;
  color: #ffffff;
  border-color: #000000;
}
.secondary-btn {
  background: #ffffff;
  color: #000000;
  border-color: #000000;
}

/* Inputs */
label { font-size: 12px; font-weight: 700; }
.input-stack { display: flex; flex-direction: column; gap: 4px; }
.inline {
  display: inline-flex; align-items: center; gap: 8px;
}
input[type="color"] {
  width: 44px; height: 44px; border: 1px solid #000000; background: #ffffff; padding: 0;
}
input[type="range"] {
  -webkit-appearance: none; appearance: none;
  width: 160px; height: 2px; background: #000000;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #000000; border: none;
}
input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: #000000; border: none; }

/* Keyboard hint */
#keyboardHint { font-size: 12px; font-weight: 600; }

/* Status bar */
#statusBar {
  position: fixed;
  inset: 56px 0 auto 0;
  height: 44px;
  border-bottom: 1px solid #000000;
  background: #ffffff;
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 8px 12px;
  z-index: 40;
}
.status-item {
  display: inline-flex; align-items: center; gap: 6px;
  font-size: 12px; white-space: nowrap;
}
.status-item .val {
  font-weight: 700;
}

/* Main area */
#mainArea {
  position: fixed;
  inset: 100px 0 0 0; /* below toolbar+status bar */
  display: flex; align-items: stretch; justify-content: stretch;
}

/* Board and side panel */
#boardContainerWrap {
  flex: 1 1 auto;
  display: flex; align-items: stretch; justify-content: stretch;
  border-right: 1px solid #000000;
  min-width: 0; /* allow flex shrink */
}
#boardContainer {
  position: relative;
  flex: 1 1 auto;
  min-width: 0;
  overflow: hidden;
  background:
    linear-gradient(#ffffff, #ffffff) 0 0 / cover no-repeat,
    repeating-linear-gradient(0deg, transparent, transparent 23px, #000000 23px, #000000 24px),
    repeating-linear-gradient(90deg, transparent, transparent 23px, #000000 23px, #000000 24px);
}
#boardContainer::after {
  content: '';
  position: absolute; inset: 0;
  border: 1px solid #000000; /* edge guide */
  pointer-events: none;
}
canvas#boardCanvas {
  position: absolute;
  left: -2px; top: -2px; /* allow drawing beyond edges by 2px */
  width: calc(100% + 4px);
  height: calc(100% + 4px);
  display: block;
  cursor: crosshair;
  touch-action: none;
}

/* Cursor preview */
#cursorDot {
  position: absolute;
  left: 0; top: 0;
  width: 16px; height: 16px;
  border: 1px solid #000000;
  background: transparent;
  transform: translate(-100px,-100px);
  pointer-events: none;
  z-index: 3;
}

/* Edge and corner hover indicators */
#edgeTop, #edgeRight, #edgeBottom, #edgeLeft {
  position: absolute; background: rgba(0,0,0,0.15); display: none; z-index: 2;
}
#edgeTop { left: 0; right: 0; top: 0; height: 6px; }
#edgeBottom { left: 0; right: 0; bottom: 0; height: 6px; }
#edgeLeft { left: 0; top: 0; bottom: 0; width: 6px; }
#edgeRight { right: 0; top: 0; bottom: 0; width: 6px; }
.edge-active { display: block; }

.corner {
  position: absolute; width: 12px; height: 12px; background: rgba(0,0,0,0.25); display: none; z-index: 2;
}
#cornerTL { left: 0; top: 0; }
#cornerTR { right: 0; top: 0; }
#cornerBL { left: 0; bottom: 0; }
#cornerBR { right: 0; bottom: 0; }
.corner-active { display: block; }

/* Pointer exit badge */
#pointerExitBadge {
  position: absolute; right: 8px; top: 8px; z-index: 4;
  background: #ffffff; border: 1px solid #000000;
  padding: 6px 8px; font-size: 12px; font-weight: 700;
  display: none;
}
#pointerExitBadge[data-visible="true"] { display: inline-block; }

/* Side panel */
#sidePanel {
  width: 320px; flex: 0 0 320px; background: #ffffff;
  display: flex; flex-direction: column; gap: 16px;
}
.panel-section {
  border-bottom: 1px solid #000000; padding: 12px;
}
.panel-section h3 { margin: 0 0 8px 0; font-size: 14px; }
.panel-block { display: flex; flex-direction: column; gap: 8px; }

/* Brush preview */
#brushPreviewCanvas {
  width: 180px; height: 100px; border: 1px solid #000000;
}

/* Color swatches */
#colorSwatches { display: flex; gap: 8px; flex-wrap: wrap; }
.swatch {
  width: 32px; height: 32px; border: 1px solid #000000; cursor: pointer;
}
.swatch.selected { outline: 2px solid #000000; outline-offset: 2px; }

/* Save history */
#saveHistoryList { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; max-height: 260px; overflow: auto; }
.history-item { display: flex; align-items: center; gap: 8px; }
.history-thumb { width: 64px; height: 36px; object-fit: cover; border: 1px solid #000000; }
.history-meta { font-size: 12px; display: flex; flex-direction: column; }
.history-actions { display: flex; gap: 8px; }
.history-actions a { font-size: 12px; text-decoration: underline; color: #000000; }

/* Toast */
#toast {
  position: fixed; right: 12px; bottom: 12px; background: #ffffff; border: 1px solid #000000;
  padding: 12px; max-width: 320px; z-index: 60; display: none;
}
#toast[data-visible="true"] { display: block; }
#toastClose { margin-left: 12px; }

/* Modal preview for save */
#modalOverlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5);
  display: none; align-items: center; justify-content: center; z-index: 70;
}
#modalOverlay[data-open="true"] { display: flex; }
#savePreviewModal {
  background: #ffffff; border: 1px solid #000000; padding: 12px;
  max-width: 90vw; max-height: 80vh; overflow: auto;
}
#savePreviewHeader { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
#savePreviewImg {
  max-width: 72vw; height: auto; border: 1px solid #000000; display: block;
}

/* Download area proxies */
#downloadArea { display: flex; flex-direction: column; gap: 8px; }
#downloadLink { word-break: break-all; }

/* Log area */
#eventLog { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 4px; max-height: 140px; overflow: auto; }
.log-line { font-size: 12px; border-bottom: 1px dotted #000000; padding-bottom: 2px; }

/* Accessibility helpers */
.sr-only {
  position: absolute !important;
  width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0;
}

/* Responsive tweaks */
@media (max-width: 980px) {
  #sidePanel { width: 260px; flex-basis: 260px; }
  input[type="range"] { width: 120px; }
}
@media (max-width: 720px) {
  #brandTitle { display: none; }
  #sidePanel { display: none; }
}
</style>
</head>
<body>

<header id="topBar" role="banner" aria-label="Whiteboard toolbar and controls">
  <div id="brandArea">
    <div id="brandIcon" aria-hidden="true"></div>
    <div id="brandTitle">Online Whiteboard</div>
  </div>

  <div id="toolbar" aria-label="Drawing toolbar">
    <div class="tool-group" role="group" aria-label="Tools">
      <button id="toolBrush" class="toolbar-btn tool-btn active" aria-pressed="true" aria-label="Brush (B)" title="Brush (B)">
        <span class="icon" aria-hidden="true"></span>
        Brush
      </button>
      <button id="toolHighlighter" class="toolbar-btn tool-btn" aria-pressed="false" aria-label="Highlighter (H)" title="Highlighter (H)">
        <span class="icon" aria-hidden="true"></span>
        Highlighter
      </button>
      <button id="toolEraser" class="toolbar-btn tool-btn" aria-pressed="false" aria-label="Eraser (E)" title="Eraser (E)">
        <span class="icon" aria-hidden="true"></span>
        Eraser
      </button>
    </div>

    <div class="divider" aria-hidden="true"></div>

    <div class="control-group" role="group" aria-label="Color controls">
      <div class="input-stack">
        <label for="brushColor">Color</label>
        <div class="inline">
          <input type="color" id="brushColor" value="#1f75fe" aria-label="Choose color">
          <div id="colorSwatches" role="listbox" aria-label="Quick color swatches">
            <div class="swatch selected" id="swatch-blue" role="option" aria-label="Blue" data-color="#1f75fe" style="background:#1f75fe"></div>
            <div class="swatch" id="swatch-red" role="option" aria-label="Red" data-color="#ff0000" style="background:#ff0000"></div>
            <div class="swatch" id="swatch-black" role="option" aria-label="Black" data-color="#000000" style="background:#000000"></div>
            <div class="swatch" id="swatch-green" role="option" aria-label="Green" data-color="#00a651" style="background:#00a651"></div>
            <div class="swatch" id="swatch-orange" role="option" aria-label="Orange" data-color="#ff7f00" style="background:#ff7f00"></div>
            <div class="swatch" id="swatch-purple" role="option" aria-label="Purple" data-color="#7f3fbf" style="background:#7f3fbf"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="control-group" role="group" aria-label="Brush size controls">
      <div class="input-stack">
        <label for="brushSize">Brush Size</label>
        <div class="inline">
          <button id="sizeMinusBtn" class="secondary-btn" aria-label="Decrease size">-</button>
          <input type="range" id="brushSize" min="1" max="100" step="1" value="8" aria-valuemin="1" aria-valuemax="100" aria-valuenow="8">
          <button id="sizePlusBtn" class="secondary-btn" aria-label="Increase size">+</button>
          <span id="sizeLabel">8px</span>
        </div>
      </div>
    </div>

    <div class="divider" aria-hidden="true"></div>

    <div class="action-group" role="group" aria-label="Actions">
      <button id="undoBtn" class="secondary-btn" title="Undo (Ctrl+Z)" aria-label="Undo (Ctrl+Z)">Undo</button>
      <button id="redoBtn" class="secondary-btn" title="Redo (Ctrl+Y / Ctrl+Shift+Z)" aria-label="Redo (Ctrl+Y / Ctrl+Shift+Z)">Redo</button>
      <button id="clearBtn" class="secondary-btn" title="Clear (C)" aria-label="Clear (C)">Clear</button>
      <div id="keyboardHint" aria-live="polite">Hint: Ctrl+S to Save</div>
    </div>

    <div class="divider" aria-hidden="true"></div>

    <div class="action-group" role="group" aria-label="Export">
      <button id="savePreviewBtn" class="secondary-btn" title="Open Save Preview" aria-label="Open Save Preview">Preview</button>
      <button id="saveBtn" class="primary-btn" title="Save Image (Ctrl+S)" aria-label="Save Image (Ctrl+S)">Save PNG</button>
    </div>
  </div>
</header>

<div id="statusBar" role="status" aria-live="polite">
  <div class="status-item">Tool: <span id="activeToolLabel" class="val">Brush</span></div>
  <div class="status-item">Color: <span id="colorValue" class="val">#1f75fe</span></div>
  <div class="status-item">Size: <span id="sizeValue" class="val">8</span> px</div>
  <div class="status-item">Input: <span id="inputModeLabel" class="val">mouse</span></div>
  <div class="status-item">Scroll: <span id="scrollStatus" class="val">idle</span></div>
  <div class="status-item">Preview: <span id="previewStatus" class="val">idle</span></div>
  <div class="status-item">Download: <span id="downloadStatus" class="val">disabled</span></div>
  <div class="status-item">Apply: <span id="applyStatus" class="val">idle</span></div>
  <div class="status-item">Last: <span id="lastAction" class="val">ready</span></div>
</div>

<main id="mainArea" role="main">
  <div id="boardContainerWrap">
    <div id="boardContainer" aria-label="Drawing area">
      <canvas id="boardCanvas"></canvas>
      <div id="cursorDot" aria-hidden="true"></div>
      <div id="edgeTop"></div>
      <div id="edgeRight"></div>
      <div id="edgeBottom"></div>
      <div id="edgeLeft"></div>
      <div id="cornerTL" class="corner"></div>
      <div id="cornerTR" class="corner"></div>
      <div id="cornerBL" class="corner"></div>
      <div id="cornerBR" class="corner"></div>
      <div id="pointerExitBadge" role="note" aria-live="polite">Pointer exited drawing area</div>
    </div>
  </div>
  <aside id="sidePanel" aria-label="Supplemental tools and history">
    <section class="panel-section" id="previewSection">
      <h3>Brush Preview</h3>
      - Live preview updates with color and size
      <canvas id="brushPreviewCanvas" aria-label="Brush preview canvas"></canvas>
      <div class="inline">
        <button id="applySettingsBtn" class="secondary-btn">Apply Settings</button>
        <span id="applySettingsHint" aria-live="polite">Press Enter to apply</span>
      </div>
    </section>

    <section class="panel-section" id="downloadArea" aria-label="Download and Links">
      <h3>Download & Links</h3>
      <div class="panel-block">
        <a id="downloadLink" href="#" download="whiteboard.png" aria-disabled="true">No download ready</a>
        <div class="inline">
          <button id="copyBtn" class="secondary-btn">Copy PNG to Clipboard</button>
          <span id="copyStatus" aria-live="polite">idle</span>
        </div>
      </div>
    </section>

    <section class="panel-section" id="historySection">
      <h3>Save History</h3>
      <ul id="saveHistoryList" aria-label="Saved images history"></ul>
    </section>

    <section class="panel-section" id="logSection">
      <h3>Event Log</h3>
      <ul id="eventLog" aria-live="polite" aria-atomic="false"></ul>
    </section>
  </aside>
</main>

<!-- Toast -->
<div id="toast" role="status" aria-live="polite">
  <span id="toastMessage">Ready</span>
  <button id="toastClose" class="secondary-btn" aria-label="Close message">Close</button>
</div>

<!-- Modal for Save Preview -->
<div id="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="savePreviewTitle" data-open="false">
  <div id="savePreviewModal">
    <div id="savePreviewHeader">
      <h2 id="savePreviewTitle" style="margin:0;">Save Preview</h2>
      <button id="closePreviewBtn" class="secondary-btn" aria-label="Close preview">Close</button>
    </div>
    <img id="savePreviewImg" alt="Preview of the current whiteboard" src="">
    <div class="inline" style="margin-top:8px;">
      <button id="confirmDownloadBtn" class="primary-btn">Download PNG</button>
      <span>Preview Status: <strong id="modalPreviewState">idle</strong></span>
    </div>
  </div>
</div>

<script>
(function () {
  'use strict';

  // Core DOM
  const canvas = document.getElementById('boardCanvas');
  const container = document.getElementById('boardContainer');
  const containerWrap = document.getElementById('boardContainerWrap');
  let ctx = canvas.getContext('2d', { willReadFrequently: false });

  // Controls
  const btnBrush = document.getElementById('toolBrush');
  const btnHighlighter = document.getElementById('toolHighlighter');
  const btnEraser = document.getElementById('toolEraser');
  const colorInput = document.getElementById('brushColor');
  const sizeInput = document.getElementById('brushSize');
  const sizeLabel = document.getElementById('sizeLabel');
  const undoBtn = document.getElementById('undoBtn'); // must preserve selector
  const redoBtn = document.getElementById('redoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const saveBtn = document.getElementById('saveBtn');
  const savePreviewBtn = document.getElementById('savePreviewBtn');
  const cursorDot = document.getElementById('cursorDot');
  const sizeMinusBtn = document.getElementById('sizeMinusBtn');
  const sizePlusBtn = document.getElementById('sizePlusBtn');
  const swatches = document.getElementById('colorSwatches');

  // Status proxies
  const activeToolLabel = document.getElementById('activeToolLabel');
  const colorValue = document.getElementById('colorValue');
  const sizeValue = document.getElementById('sizeValue');
  const inputModeLabel = document.getElementById('inputModeLabel');
  const scrollStatus = document.getElementById('scrollStatus');
  const previewStatus = document.getElementById('previewStatus');
  const downloadStatus = document.getElementById('downloadStatus');
  const applyStatus = document.getElementById('applyStatus');
  const lastAction = document.getElementById('lastAction');

  // Edge and corner indicators
  const edgeTop = document.getElementById('edgeTop');
  const edgeRight = document.getElementById('edgeRight');
  const edgeBottom = document.getElementById('edgeBottom');
  const edgeLeft = document.getElementById('edgeLeft');
  const cornerTL = document.getElementById('cornerTL');
  const cornerTR = document.getElementById('cornerTR');
  const cornerBL = document.getElementById('cornerBL');
  const cornerBR = document.getElementById('cornerBR');
  const pointerExitBadge = document.getElementById('pointerExitBadge');

  // Preview / download UI
  const brushPreviewCanvas = document.getElementById('brushPreviewCanvas');
  const applySettingsBtn = document.getElementById('applySettingsBtn');
  const downloadLink = document.getElementById('downloadLink');
  const copyBtn = document.getElementById('copyBtn');
  const copyStatus = document.getElementById('copyStatus');
  const saveHistoryList = document.getElementById('saveHistoryList');
  const eventLog = document.getElementById('eventLog');

  // Modal and toast
  const modalOverlay = document.getElementById('modalOverlay');
  const savePreviewImg = document.getElementById('savePreviewImg');
  const modalPreviewState = document.getElementById('modalPreviewState');
  const confirmDownloadBtn = document.getElementById('confirmDownloadBtn');
  const closePreviewBtn = document.getElementById('closePreviewBtn');
  const toast = document.getElementById('toast');
  const toastMessage = document.getElementById('toastMessage');
  const toastClose = document.getElementById('toastClose');

  const state = {
    tool: 'brush', // brush | highlighter | eraser
    color: colorInput.value || '#1f75fe',
    size: parseInt(sizeInput.value, 10) || 8,
    dpr: Math.max(1, window.devicePixelRatio || 1),
    edgePad: 2, // expand drawing beyond visible edges by 2 CSS px
    isDrawing: false,
    pointerId: null,
    lastPoint: null,
    lastMid: null,
    strokeMoved: false,
    history: [],
    historyIndex: -1,
    maxHistory: 20,
    isDirtySinceLastSnapshot: false,
    inputMode: 'mouse',
    lastBrushColor: colorInput.value || '#1f75fe',
    lastBrushSize: parseInt(sizeInput.value, 10) || 8,
    saveHistory: [] // array of {url, time}
  };

  function hexToRgba(hex, alpha = 1) {
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!m) return `rgba(31,117,254,${alpha})`;
    const r = parseInt(m[1], 16);
    const g = parseInt(m[2], 16);
    const b = parseInt(m[3], 16);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function setupContext() {
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.miterLimit = 2;
    ctx.imageSmoothingEnabled = true;
  }

  function applyStrokeStyle() {
    ctx.lineWidth = state.size * state.dpr;
    if (state.tool === 'eraser') {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#000';
    } else {
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = (state.tool === 'highlighter') ? 0.25 : 1.0;
      ctx.strokeStyle = state.color;
    }
  }

  function getCanvasPoint(e) {
    const rect = container.getBoundingClientRect();
    return {
      x: ((e.clientX - rect.left) + state.edgePad) * state.dpr,
      y: ((e.clientY - rect.top) + state.edgePad) * state.dpr
    };
  }

  function midpoint(p1, p2) {
    return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
  }

  function resizeCanvas(preserve = true) {
    const rect = container.getBoundingClientRect();
    const prev = document.createElement('canvas');
    prev.width = canvas.width;
    prev.height = canvas.height;
    const pctx = prev.getContext('2d');
    if (prev.width && prev.height) pctx.drawImage(canvas, 0, 0);

    state.dpr = Math.max(1, window.devicePixelRatio || 1);
    const pad = state.edgePad * 2;
    canvas.width = Math.max(1, Math.floor((rect.width + pad) * state.dpr));
    canvas.height = Math.max(1, Math.floor((rect.height + pad) * state.dpr));
    canvas.style.width = rect.width + pad + 'px';
    canvas.style.height = rect.height + pad + 'px';
    ctx = canvas.getContext('2d');
    setupContext();

    if (preserve && prev.width && prev.height) {
      ctx.drawImage(prev, 0, 0, prev.width, prev.height, 0, 0, canvas.width, canvas.height);
    }
    drawBrushPreview();
  }

  function setActiveTool(tool) {
    state.tool = tool;

    // Toggle classes and aria-pressed
    const map = { brush: btnBrush, highlighter: btnHighlighter, eraser: btnEraser };
    [btnBrush, btnHighlighter, btnEraser].forEach(b => {
      b.classList.remove('active');
      b.setAttribute('aria-pressed', 'false');
    });
    const btn = map[tool];
    btn.classList.add('active');
    btn.setAttribute('aria-pressed', 'true');

    // Restore brush settings when leaving eraser
    if (tool === 'brush' || tool === 'highlighter') {
      if (state.lastBrushColor) {
        state.color = state.lastBrushColor;
        colorInput.value = state.lastBrushColor;
        updateSelectedSwatch(state.color);
      }
      if (state.lastBrushSize) {
        state.size = state.lastBrushSize;
        sizeInput.value = String(state.size);
      }
    } else if (tool === 'eraser') {
      // Remember the current brush settings for when we return
      state.lastBrushColor = state.color;
      state.lastBrushSize = state.size;
    }

    updateCursorAppearance();
    updateSizeLabel();
    updateStatusBar();
    logEvent('Tool set to ' + tool);
  }

  function updateSizeLabel() {
    sizeLabel.textContent = state.size + 'px';
    sizeValue.textContent = String(state.size);
  }

  function updateCursorAppearance() {
    const cssPx = state.size; // cursor size in CSS px (not DPR)
    cursorDot.style.width = cssPx + 'px';
    cursorDot.style.height = cssPx + 'px';
    if (state.tool === 'eraser') {
      cursorDot.style.border = '2px solid #000000';
      cursorDot.style.background = 'transparent';
    } else if (state.tool === 'highlighter') {
      cursorDot.style.border = '1px solid #000000';
      cursorDot.style.background = hexToRgba(state.color, 0.25);
    } else {
      cursorDot.style.border = '1px solid #000000';
      cursorDot.style.background = hexToRgba(state.color, 0.8);
    }
    drawBrushPreview();
    colorValue.textContent = state.color.toLowerCase();
  }

  function moveCursorPreview(e) {
    const rect = container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    cursorDot.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
    showEdgeIndicators(x, y, rect.width, rect.height);
  }

  function hideCursorPreview() {
    cursorDot.style.transform = 'translate(-100px,-100px)';
    hideEdgeIndicators();
  }

  function pushSnapshot() {
    // Trim redo stack if any
    if (state.historyIndex < state.history.length - 1) {
      state.history = state.history.slice(0, state.historyIndex + 1);
    }
    try {
      const url = canvas.toDataURL('image/png');
      state.history.push(url);
      if (state.history.length > state.maxHistory) {
        state.history.shift();
      }
      state.historyIndex = state.history.length - 1;
      state.isDirtySinceLastSnapshot = false;
      updateUndoRedoButtons();
    } catch (err) {
      console.warn('Snapshot failed:', err);
    }
  }

  function restoreFromSnapshot(index) {
    const url = state.history[index];
    if (!url) return;
    const img = new Image();
    img.onload = function () {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
      updateStatusBar();
      logEvent('Restored history index ' + index);
    };
    img.src = url;
  }

  function updateUndoRedoButtons() {
    undoBtn.disabled = !(state.historyIndex > 0);
    redoBtn.disabled = !(state.historyIndex < state.history.length - 1);
  }

  function undo() {
    if (state.historyIndex > 0) {
      state.historyIndex--;
      restoreFromSnapshot(state.historyIndex);
      updateUndoRedoButtons();
      lastAction.textContent = 'undo';
    }
  }

  function redo() {
    if (state.historyIndex < state.history.length - 1) {
      state.historyIndex++;
      restoreFromSnapshot(state.historyIndex);
      updateUndoRedoButtons();
      lastAction.textContent = 'redo';
    }
  }

  function clearCanvas(push = true) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (push) pushSnapshot();
    showToast('Canvas cleared');
    lastAction.textContent = 'clear';
  }

  function makeExportCanvas() {
    // Export canvas matches drawing canvas size to preserve pixels
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width;
    exportCanvas.height = canvas.height;
    const ectx = exportCanvas.getContext('2d');
    // Fill white background
    ectx.fillStyle = '#ffffff';
    ectx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
    ectx.drawImage(canvas, 0, 0);
    return exportCanvas;
  }

  function updateDownloadProxyFromCanvas(exportCanvas) {
    const dataURL = exportCanvas.toDataURL('image/png');
    downloadLink.href = dataURL;
    downloadLink.setAttribute('aria-disabled', 'false');
    downloadLink.textContent = 'Download link ready (PNG data URL)';
    downloadStatus.textContent = 'enabled';
    previewStatus.textContent = 'ready';
    savePreviewImg.src = dataURL;
    modalPreviewState.textContent = 'ready';
    // Save to in-app history
    addSaveToHistory(dataURL);
  }

  function saveImage() {
    const exportCanvas = makeExportCanvas();
    // Update in-app proxies and preview before downloading
    updateDownloadProxyFromCanvas(exportCanvas);

    const filename = `whiteboard-${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
    if (exportCanvas.toBlob) {
      exportCanvas.toBlob(blob => {
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(url);
          a.remove();
        }, 100);
      }, 'image/png');
    } else {
      const dataURL = exportCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    showToast('PNG downloaded');
    lastAction.textContent = 'save';
  }

  function pointerDown(e) {
    if (e.button === 2) return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    state.pointerId = e.pointerId;
    const pt = getCanvasPoint(e);
    setupContext();
    applyStrokeStyle();
    state.lastPoint = pt;
    state.lastMid = pt;
    state.isDrawing = true;
    state.strokeMoved = false;
    moveCursorPreview(e);
    scrollStatus.textContent = 'prevented';
    state.inputMode = (e.pointerType || 'mouse').toLowerCase();
    inputModeLabel.textContent = state.inputMode;
    pointerExitBadge.setAttribute('data-visible', 'false');
    lastAction.textContent = 'pointerdown';
  }

  function pointerMove(e) {
    moveCursorPreview(e);
    if (!state.isDrawing || e.pointerId !== state.pointerId) return;
    e.preventDefault();
    const pt = getCanvasPoint(e);
    const mid = midpoint(state.lastPoint, pt);
    ctx.beginPath();
    ctx.moveTo(state.lastMid.x, state.lastMid.y);
    ctx.quadraticCurveTo(state.lastPoint.x, state.lastPoint.y, mid.x, mid.y);
    ctx.stroke();
    state.lastPoint = pt;
    state.lastMid = mid;
    state.strokeMoved = true;
    state.isDirtySinceLastSnapshot = true;
  }

  function drawDotAt(pt) {
    const r = Math.max(0.5, (state.size * state.dpr) / 2);
    if (state.tool === 'eraser') {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = (state.tool === 'highlighter') ? 0.25 : 1.0;
      ctx.fillStyle = state.color;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function pointerUp(e) {
    if (e.pointerId !== state.pointerId) return;
    e.preventDefault();
    if (!state.strokeMoved && state.lastPoint) {
      drawDotAt(state.lastPoint);
      state.isDirtySinceLastSnapshot = true;
    }
    state.isDrawing = false;
    state.pointerId = null;
    pushSnapshot();
    scrollStatus.textContent = 'idle';
    lastAction.textContent = 'pointerup';
  }

  function preventContextMenu(e) {
    e.preventDefault();
  }

  // Edge indicators
  function showEdgeIndicators(x, y, w, h) {
    const edgeDist = 12;
    const nearTop = y <= edgeDist;
    const nearBottom = (h - y) <= edgeDist;
    const nearLeft = x <= edgeDist;
    const nearRight = (w - x) <= edgeDist;
    edgeTop.classList.toggle('edge-active', nearTop);
    edgeBottom.classList.toggle('edge-active', nearBottom);
    edgeLeft.classList.toggle('edge-active', nearLeft);
    edgeRight.classList.toggle('edge-active', nearRight);

    // Corners
    const nearTL = nearTop && nearLeft;
    const nearTR = nearTop && nearRight;
    const nearBL = nearBottom && nearLeft;
    const nearBR = nearBottom && nearRight;
    cornerTL.classList.toggle('corner-active', nearTL);
    cornerTR.classList.toggle('corner-active', nearTR);
    cornerBL.classList.toggle('corner-active', nearBL);
    cornerBR.classList.toggle('corner-active', nearBR);
  }
  function hideEdgeIndicators() {
    [edgeTop, edgeRight, edgeBottom, edgeLeft].forEach(el => el.classList.remove('edge-active'));
    [cornerTL, cornerTR, cornerBL, cornerBR].forEach(el => el.classList.remove('corner-active'));
  }

  // Status and preview helpers
  function updateStatusBar() {
    activeToolLabel.textContent = capitalize(state.tool);
    colorValue.textContent = state.color.toLowerCase();
    sizeValue.textContent = String(state.size);
  }
  function drawBrushPreview() {
    const bpc = brushPreviewCanvas.getContext('2d');
    const w = brushPreviewCanvas.width = brushPreviewCanvas.clientWidth;
    const h = brushPreviewCanvas.height = brushPreviewCanvas.clientHeight;
    bpc.fillStyle = '#ffffff';
    bpc.fillRect(0, 0, w, h);
    // stroke demonstration line
    bpc.lineCap = 'round';
    bpc.lineJoin = 'round';
    bpc.lineWidth = state.size;
    if (state.tool === 'eraser') {
      bpc.strokeStyle = '#000000';
      bpc.setLineDash([6, 6]);
    } else {
      bpc.strokeStyle = state.color;
      bpc.setLineDash([]);
      bpc.globalAlpha = (state.tool === 'highlighter') ? 0.25 : 1;
    }
    bpc.beginPath();
    bpc.moveTo(10, h/2);
    bpc.lineTo(w - 10, h/2);
    bpc.stroke();
    // draw a dot
    bpc.globalAlpha = (state.tool === 'highlighter') ? 0.25 : 1;
    bpc.fillStyle = (state.tool === 'eraser') ? '#000000' : state.color;
    bpc.beginPath();
    bpc.arc(w/2, h/2, Math.max(1, state.size / 2), 0, Math.PI * 2);
    bpc.fill();
  }

  function updateSelectedSwatch(hex) {
    if (!swatches) return;
    const nodes = Array.from(swatches.querySelectorAll('.swatch'));
    nodes.forEach(n => n.classList.remove('selected'));
    const found = nodes.find(n => (n.getAttribute('data-color') || '').toLowerCase() === hex.toLowerCase());
    if (found) found.classList.add('selected');
  }

  // History of saves
  function addSaveToHistory(url) {
    const when = new Date().toLocaleString();
    const item = { url, time: when };
    state.saveHistory.unshift(item);
    // keep last 10
    if (state.saveHistory.length > 10) state.saveHistory.pop();
    renderSaveHistory();
  }

  function renderSaveHistory() {
    saveHistoryList.innerHTML = '';
    state.saveHistory.forEach((item, idx) => {
      const li = document.createElement('li');
      li.className = 'history-item';
      const img = document.createElement('img');
      img.className = 'history-thumb';
      img.src = item.url;
      img.alt = 'Saved image ' + (idx + 1);
      const meta = document.createElement('div');
      meta.className = 'history-meta';
      meta.innerHTML = '<span>Saved ' + item.time + '</span><span>Size: ' + (item.url.length) + ' chars</span>';
      const actions = document.createElement('div');
      actions.className = 'history-actions';
      const open = document.createElement('a');
      open.href = item.url; open.target = '_blank'; open.rel = 'noopener'; open.textContent = 'Open';
      const copy = document.createElement('a');
      copy.href = '#'; copy.textContent = 'Copy URL';
      copy.addEventListener('click', (e) => {
        e.preventDefault();
        navigator.clipboard.writeText(item.url).then(() => {
          showToast('Data URL copied to clipboard');
        });
      });
      actions.appendChild(open);
      actions.appendChild(copy);
      li.appendChild(img);
      li.appendChild(meta);
      li.appendChild(actions);
      saveHistoryList.appendChild(li);
    });
  }

  // Logging
  function logEvent(text) {
    const li = document.createElement('li');
    li.className = 'log-line';
    const time = new Date().toLocaleTimeString();
    li.textContent = '[' + time + '] ' + text;
    eventLog.appendChild(li);
    // Trim to 100 lines
    while (eventLog.children.length > 100) {
      eventLog.removeChild(eventLog.firstChild);
    }
  }

  // Toast
  function showToast(msg) {
    toastMessage.textContent = msg;
    toast.setAttribute('data-visible', 'true');
  }
  function hideToast() {
    toast.setAttribute('data-visible', 'false');
  }

  // Modal preview
  function openPreviewModal() {
    const exportCanvas = makeExportCanvas();
    // Set preview and proxies
    updateDownloadProxyFromCanvas(exportCanvas);
    previewStatus.textContent = 'ready';
    modalOverlay.setAttribute('data-open', 'true');
    modalPreviewState.textContent = 'ready';
    lastAction.textContent = 'preview';
  }
  function closePreviewModal() {
    modalOverlay.setAttribute('data-open', 'false');
    modalPreviewState.textContent = 'idle';
  }

  // Controls events
  btnBrush.addEventListener('click', () => setActiveTool('brush'));
  btnHighlighter.addEventListener('click', () => setActiveTool('highlighter'));
  btnEraser.addEventListener('click', () => setActiveTool('eraser'));

  colorInput.addEventListener('input', (e) => {
    state.color = e.target.value;
    state.lastBrushColor = state.color;
    updateSelectedSwatch(state.color);
    updateCursorAppearance();
    updateStatusBar();
    lastAction.textContent = 'color-change';
  });

  swatches.addEventListener('click', (e) => {
    const t = e.target.closest('.swatch');
    if (!t) return;
    const hex = t.getAttribute('data-color');
    if (!hex) return;
    state.color = hex;
    state.lastBrushColor = hex;
    colorInput.value = hex;
    updateSelectedSwatch(hex);
    updateCursorAppearance();
    updateStatusBar();
    lastAction.textContent = 'color-swatch';
  });

  sizeInput.addEventListener('input', (e) => {
    state.size = parseInt(e.target.value, 10) || state.size;
    state.lastBrushSize = state.size;
    updateSizeLabel();
    updateCursorAppearance();
    updateStatusBar();
    lastAction.textContent = 'size-change';
  });

  sizeMinusBtn.addEventListener('click', () => {
    state.size = Math.max(1, state.size - 1);
    state.lastBrushSize = state.size;
    sizeInput.value = String(state.size);
    updateSizeLabel();
    updateCursorAppearance();
    updateStatusBar();
    lastAction.textContent = 'size-dec';
  });

  sizePlusBtn.addEventListener('click', () => {
    state.size = Math.min(parseInt(sizeInput.max,10), state.size + 1);
    state.lastBrushSize = state.size;
    sizeInput.value = String(state.size);
    updateSizeLabel();
    updateCursorAppearance();
    updateStatusBar();
    lastAction.textContent = 'size-inc';
  });

  applySettingsBtn.addEventListener('click', () => {
    // Settings are already live; this just confirms synchronously
    applyStatus.textContent = 'done';
    showToast('Brush settings applied');
    lastAction.textContent = 'apply';
  });

  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);

  clearBtn.addEventListener('click', () => {
    const proceed = confirm('Clear the whiteboard? This cannot be undone.');
    if (proceed) clearCanvas(true);
  });

  saveBtn.addEventListener('click', saveImage);
  savePreviewBtn.addEventListener('click', openPreviewModal);
  closePreviewBtn.addEventListener('click', closePreviewModal);
  confirmDownloadBtn.addEventListener('click', () => {
    // Trigger the same as save but we already have dataURL in downloadLink
    if (downloadLink && downloadLink.href && downloadLink.href.startsWith('data:image/png')) {
      const a = document.createElement('a');
      a.href = downloadLink.href;
      a.download = `whiteboard-${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      showToast('PNG downloaded from preview');
      lastAction.textContent = 'download-from-preview';
    } else {
      showToast('No preview available');
    }
  });

  copyBtn.addEventListener('click', async () => {
    const exportCanvas = makeExportCanvas();
    if (navigator.clipboard && navigator.clipboard.write) {
      try {
        const blob = await new Promise(resolve => exportCanvas.toBlob(resolve, 'image/png'));
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        copyStatus.textContent = 'done';
        showToast('PNG copied to clipboard');
        lastAction.textContent = 'copy';
      } catch (err) {
        copyStatus.textContent = 'failed';
        showToast('Clipboard copy failed');
      }
    } else {
      try {
        const dataURL = exportCanvas.toDataURL('image/png');
        await navigator.clipboard.writeText(dataURL);
        copyStatus.textContent = 'done (URL)';
        showToast('Data URL copied to clipboard');
      } catch (err) {
        copyStatus.textContent = 'failed';
        showToast('Clipboard not available');
      }
    }
  });

  toastClose.addEventListener('click', hideToast);

  // Canvas events
  canvas.addEventListener('pointerdown', pointerDown);
  canvas.addEventListener('pointermove', pointerMove);
  canvas.addEventListener('pointerup', pointerUp);
  canvas.addEventListener('pointercancel', pointerUp);
  canvas.addEventListener('contextmenu', preventContextMenu);

  container.addEventListener('pointermove', moveCursorPreview);
  container.addEventListener('pointerleave', () => {
    hideCursorPreview();
    pointerExitBadge.setAttribute('data-visible', 'true');
    lastAction.textContent = 'pointerleave';
  });
  container.addEventListener('pointerenter', (e) => {
    moveCursorPreview(e);
    pointerExitBadge.setAttribute('data-visible', 'false');
    lastAction.textContent = 'pointerenter';
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (tag === 'input' || tag === 'textarea') {
      // Enter to apply settings safely
      if (e.key === 'Enter') {
        applySettingsBtn.click();
      }
      return;
    }
    const k = e.key.toLowerCase();
    if ((e.ctrlKey || e.metaKey) && k === 's') {
      e.preventDefault();
      saveImage();
    } else if ((e.ctrlKey || e.metaKey) && k === 'z') {
      e.preventDefault();
      if (e.shiftKey) redo(); else undo();
    } else if ((e.ctrlKey || e.metaKey) && k === 'y') {
      e.preventDefault();
      redo();
    } else if (k === 'b') {
      setActiveTool('brush');
    } else if (k === 'h') {
      setActiveTool('highlighter');
    } else if (k === 'e') {
      setActiveTool('eraser');
    } else if (k === '[') {
      state.size = Math.max(1, state.size - 1);
      sizeInput.value = state.size;
      updateSizeLabel();
      updateCursorAppearance();
    } else if (k === ']') {
      state.size = Math.min(parseInt(sizeInput.max,10), state.size + 1);
      sizeInput.value = state.size;
      updateSizeLabel();
      updateCursorAppearance();
    } else if (k === 'c') {
      const proceed = confirm('Clear the whiteboard? This cannot be undone.');
      if (proceed) clearCanvas(true);
    } else if (k === 'p') {
      openPreviewModal();
    }
  });

  // Resize handling
  let resizeTimeout = null;
  function handleResize() {
    resizeCanvas(true);
  }
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(handleResize, 80);
  });

  // Initialize
  function init() {
    resizeCanvas(false);
    setupContext();
    updateSizeLabel();
    updateCursorAppearance();
    updateSelectedSwatch(state.color);
    // Initial snapshot (blank)
    pushSnapshot();
    updateUndoRedoButtons();
    updateStatusBar();
    downloadStatus.textContent = 'disabled';
    previewStatus.textContent = 'idle';
    applyStatus.textContent = 'idle';
    lastAction.textContent = 'ready';
    logEvent('Initialized');
  }
  init();

  // Utility
  function capitalize(s) { return s ? s.charAt(0).toUpperCase() + s.slice(1) : s; }

  // Expose for tests (without polluting global API surface)
  window.__whiteboardState = state;

})();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SPQR Tic Tac Toe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ============================================================
       Destylized, high-contrast, operator-friendly baseline
       ============================================================ */
    :root{
      --bg: #ffffff;
      --fg: #000000;
      --muted: #333333;
      --panel: #ffffff;
      --panel-border: #000000;
      --accent: #000000;
      --accent-weak: #444444;
      --accent-strong: #000000;
      --x-color:#000000;
      --o-color:#7f1d1d;
      --cell-bg: #ffffff;
      --cell-hover: #f2f2f2;
      --cell-press: #e6e6e6;
      --win-outline: #000000;
      --banner-bg: #ffffff;
      --banner-fg:#000000;
      --btn-bg: #ffffff;
      --btn-fg: #000000;
      --btn-border: #000000;
      --focus: #0000ff;
    }
    [data-theme="night"]{
      --bg: #000000;
      --fg: #ffffff;
      --muted: #d0d0d0;
      --panel: #000000;
      --panel-border: #ffffff;
      --accent: #ffffff;
      --accent-weak: #cccccc;
      --accent-strong: #ffffff;
      --x-color:#ffffff;
      --o-color:#ff6b6b;
      --cell-bg: #000000;
      --cell-hover: #101010;
      --cell-press: #181818;
      --win-outline: #ffffff;
      --banner-bg: #000000;
      --banner-fg:#ffffff;
      --btn-bg: #000000;
      --btn-fg: #ffffff;
      --btn-border: #ffffff;
      --focus: #00aaff;
    }
    *{ box-sizing: border-box; }
    html,body{ height:100% }
    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height:1.35;
    }
    .app{
      min-height:100%;
      display:grid;
      grid-template-rows: auto auto auto auto 1fr auto;
      gap: 12px;
      padding: 12px;
    }
    header{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-start;
      border:1px solid var(--panel-border);
      background: var(--panel);
      padding: 8px;
    }
    .btn{
      appearance:none;
      min-width: 44px;
      min-height: 44px;
      border:1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-fg);
      padding: 8px 12px;
      font-weight:600;
      cursor:pointer;
      outline:none;
    }
    .btn:focus-visible{ outline:3px solid var(--focus); outline-offset:1px; }
    .btn:active{ background: var(--cell-press); }
    .row{
      display:flex; gap:12px; align-items:center;
      border:1px solid var(--panel-border);
      background: var(--panel);
      padding: 8px;
    }
    .spqr{ font-weight: 800; letter-spacing: 2px; }
    .scoreboard{
      display:flex; gap: 8px; flex-wrap: wrap;
    }
    .score{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--panel-border);
      padding: 8px 10px;
      min-width: 100px;
      justify-content:center;
    }
    .score .label{ font-weight:700 }
    .score .count{ font-weight:800 }
    #victoryBanner{
      display:none;
      align-items:center;
      justify-content:center;
      padding: 8px;
      border: 1px solid var(--panel-border);
      background: var(--banner-bg);
      color: var(--banner-fg);
      min-height: 44px;
      font-weight:700;
    }
    #victoryBanner.show{ display:flex }
    #statusBar{
      display:flex; gap: 12px; align-items:center; flex-wrap:wrap;
      border:1px solid var(--panel-border); background: var(--panel); padding:8px;
    }
    #turnIndicator, #boardLockStatus, #aiStatus, #keyboardHint, #newRoundStatus, #resultStatus{
      padding:6px 8px; border:1px solid var(--panel-border);
      min-height: 32px; min-width: 44px;
    }
    main{ display:grid; gap: 12px; }
    #inlineControls{
      display:flex; gap:12px; align-items:center; flex-wrap:wrap;
      border:1px solid var(--panel-border); background: var(--panel); padding:8px;
    }
    #themeGlyphSummary{
      display:flex; gap: 12px; align-items:center; flex-wrap:wrap;
      border:1px solid var(--panel-border); background: var(--panel); padding:8px;
    }
    #board{
      width: min(90vmin, 100%);
      aspect-ratio: 1/1;
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 8px;
      padding: 8px;
      border:1px solid var(--panel-border);
      background: var(--panel);
    }
    .cell{
      appearance:none;
      border:1px solid var(--panel-border);
      background: var(--cell-bg);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      position:relative;
      color: var(--fg);
      outline:none;
      min-height: 44px;
      min-width: 44px;
    }
    .cell:hover{ background: var(--cell-hover); }
    .cell:active{ background: var(--cell-press); }
    .cell:focus-visible{ outline: 3px solid var(--focus); outline-offset: -3px; }
    .cell[disabled]{ cursor:not-allowed; }
    .mark{
      font-weight: 800;
      font-size: clamp(36px, 10vmin, 120px);
      line-height:1;
      user-select:none;
    }
    .mark.x{ color: var(--x-color) }
    .mark.o{ color: var(--o-color) }
    .cell.win{
      outline: 4px solid var(--win-outline);
      outline-offset:-4px;
    }
    #gameStatus{
      border:1px solid var(--panel-border);
      padding:8px;
      background: var(--panel);
      min-height: 44px;
    }
    dialog{ border:none; padding:0; background: transparent; }
    .modal{
      width: min(860px, 92vw);
      border:1px solid var(--panel-border);
      background: var(--panel);
      color: var(--fg);
    }
    .modal header{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      padding:8px;
      border-bottom:1px solid var(--panel-border);
    }
    .modal h2{ margin:0; font-weight:800 }
    .modal .content{
      padding: 8px;
      display:grid; grid-template-columns: 1fr 1fr; gap: 8px;
    }
    @media (max-width: 800px){
      .modal .content{ grid-template-columns: 1fr; }
    }
    fieldset{ border:1px solid var(--panel-border); padding: 8px; }
    legend{ font-weight:700; }
    .option{
      display:flex; align-items:center; gap:8px;
      padding:6px;
      border:1px solid transparent;
      margin-bottom:4px;
    }
    .option input[type="radio"], .option input[type="checkbox"]{
      width:18px;height:18px;
    }
    .option input:checked + span{
      border:1px solid var(--accent-strong);
      padding:2px 4px;
      font-weight:700;
    }
    .modal .actions{
      display:flex; gap: 8px; justify-content:flex-end; padding:8px;
      border-top:1px solid var(--panel-border);
    }
    .sr-only{
      position:absolute !important;
      width:1px;height:1px;
      padding:0;margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;border:0;
    }
    /* Lock styling */
    #board[data-locked="true"] .cell{ pointer-events:none; }
    /* Selected/active mini badges */
    .badge{ padding:4px 6px; border:1px solid var(--panel-border); }
    /* Sticky scoreboard on mobile */
    @media (max-width: 720px){
      .row.sticky { position: sticky; top: 0; z-index: 10; }
    }
    .icon{ width:70%; height:70%; }
    /* Auxiliary proxy badges area */
    #proxyBar{
      display:flex; gap:8px; flex-wrap:wrap; border:1px solid var(--panel-border); padding:8px; background: var(--panel);
    }
  </style>

  <!-- Legacy decorative CSS block retained for length and non-regression comment purposes only.
       It is effectively overridden by the destylized rules above to satisfy the viewport
       and contrast requirements. -->
  <style>
    /* Legacy variables preserved for non-regression tests (not visually active due to overrides) */
    :root{
      --bg-marble-1: rgba(255,255,255,1);
      --bg-marble-2: rgba(210,210,210,0);
      --bg-marble-vein: rgba(160,160,160,0);
      --gold: #C9A227;
      --gold-deep:#a8830f;
      --crimson:#7f1d1d;
      --shadow:none;
      --ring: none;
      --win-glow: none;
      --banner-bg-legacy: #fff8cc;
      --banner-fg-legacy:#3b2e07;
      --btn-hover: #f5f5f5;
      --crest-filter:none;
    }
    [data-theme="night"]{
      --gold: #D1B55C;
      --gold-deep:#b3953f;
      --crimson:#c43b3b;
      --btn-hover: #101010;
      --crest-filter:none;
    }
    /* Keep IDs & classes used by automated checks */
  </style>
</head>
<body data-theme="day">
  <div class="app" id="appRoot">
    <header aria-label="Actions">
      <button class="btn" id="btnNewRound" type="button" title="Start a new round">New Round</button>
      <button class="btn" id="btnCustomize" type="button" title="Customize appearance and rules">Customize</button>
      <button class="btn" id="btnResetScores" type="button" title="Reset the scoreboard">Reset Scores</button>
      <div id="keyboardHintHeader" class="badge" aria-hidden="true">Hint: Arrow keys move focus; Enter/Space places mark.</div>
    </header>

    <div class="row sticky" aria-label="Scoreboard and Crest">
      <div class="spqr" aria-hidden="true">SPQR</div>
      <div class="scoreboard" aria-label="Scoreboard">
        <div class="score" id="scoreXCard" aria-live="polite">
          <span class="label" aria-hidden="true">X</span>
          <span class="count" id="scoreX">0</span>
        </div>
        <div class="score" id="scoreOCard" aria-live="polite">
          <span class="label" aria-hidden="true">O</span>
          <span class="count" id="scoreO">0</span>
        </div>
        <div class="score" id="scoreDrawCard" aria-live="polite">
          <span class="label" aria-hidden="true">Draw</span>
          <span class="count" id="scoreDraw">0</span>
        </div>
      </div>
    </div>

    <div id="victoryBanner" role="status" aria-live="polite"></div>

    <div id="statusBar" aria-label="Status bar">
      <div id="turnIndicator" role="status" aria-live="polite">Turn: —</div>
      <div id="boardLockStatus">Board: unlocked</div>
      <div id="aiStatus">AI: idle</div>
      <div id="keyboardHint">Keys: Arrow keys to move, Enter/Space to place</div>
      <div id="newRoundStatus">Round: idle</div>
      <div id="resultStatus">Result: none</div>
    </div>

    <main>
      <div id="inlineControls" aria-label="Inline Controls">
        <button class="btn" id="btnNewRoundInline" type="button" title="Start a new round (inline)">New Round</button>
        <button class="btn" id="btnCustomizeInline" type="button" title="Customize appearance and rules (inline)">Customize</button>
        <button class="btn" id="btnResetScoresInline" type="button" title="Reset the scoreboard (inline)">Reset Scores</button>
        <div id="gameStatus" role="status" aria-live="polite">Ready.</div>
      </div>

      <div id="themeGlyphSummary" aria-label="Selections summary">
        <div class="badge">Theme: <span id="themeLabel">day</span></div>
        <div class="badge">Glyphs: <span id="glyphsLabel">standard</span></div>
        <div class="badge">Mode: <span id="modeLabel">two</span></div>
        <div class="badge">First: <span id="firstLabel">X</span></div>
        <div class="badge">AI Discipline: <span id="aiDisciplineLabel">perfect</span></div>
        <div class="badge">AI Side: <span id="aiSideLabel">auto</span></div>
      </div>

      <div id="board"
           role="grid"
           aria-label="Tic Tac Toe board"
           aria-rowcount="3"
           aria-colcount="3">
      </div>
      <div id="statusLive" class="sr-only" aria-live="polite"></div>
      <div id="statusLiveAssertive" class="sr-only" aria-live="assertive"></div>
    </main>

    <div id="proxyBar" aria-label="Proxies for automation visibility">
      <div id="applyStatus" class="badge">Customize: idle</div>
      <div id="confettiStatus" class="badge">Confetti: idle</div>
      <div id="scoreUpdateStatus" class="badge">Scores: synced</div>
      <div id="activeSection" class="badge">Active: main</div>
    </div>

    <dialog id="dialogCustomize" aria-labelledby="dialogTitle">
      <div class="modal" role="document">
        <header>
          <h2 id="dialogTitle">Customize</h2>
          <div style="display:flex; gap:8px; align-items:center;">
            <button class="btn" id="btnSaveCustomizeTop" type="button" title="Save settings (top)">Save</button>
            <button class="btn" id="closeCustomize" type="button" title="Close">Close</button>
          </div>
        </header>
        <div class="content">
          <fieldset>
            <legend>Theme</legend>
            <label class="option">
              <input id="themeDay" name="theme" type="radio" value="day" checked>
              <span>Marble Day (light)</span>
            </label>
            <label class="option">
              <input id="themeNight" name="theme" type="radio" value="night">
              <span>Night Legion (dark)</span>
            </label>
            <div class="badge" id="themeApplyNote">Current: <span id="themeCurrentBadge">day</span></div>
          </fieldset>

          <fieldset>
            <legend>Glyphs</legend>
            <label class="option">
              <input id="glyphStandard" name="glyphs" type="radio" value="standard" checked>
              <span>Standard X / O</span>
            </label>
            <label class="option">
              <input id="glyphLegion" name="glyphs" type="radio" value="legion">
              <span>Gladius / Laurel</span>
            </label>
            <div class="badge" id="glyphsApplyNote">Current: <span id="glyphsCurrentBadge">standard</span></div>
          </fieldset>

          <fieldset>
            <legend>Mode</legend>
            <label class="option">
              <input id="modeTwo" name="mode" type="radio" value="two" checked>
              <span>2-Player</span>
            </label>
            <label class="option">
              <input id="modeAI" name="mode" type="radio" value="ai">
              <span>vs AI</span>
            </label>
            <div class="badge" id="modeApplyNote">Current: <span id="modeCurrentBadge">two</span></div>
          </fieldset>

          <fieldset>
            <legend>First move</legend>
            <label class="option">
              <input id="firstMoveX" name="first" type="radio" value="X" checked>
              <span>X</span>
            </label>
            <label class="option">
              <input id="firstMoveO" name="first" type="radio" value="O">
              <span>O</span>
            </label>
            <div class="badge">Note: You can choose the AI side below. If AI side equals First, AI opens.</div>
            <div class="badge" id="firstApplyNote">Current: <span id="firstCurrentBadge">X</span></div>
          </fieldset>

          <fieldset>
            <legend>AI discipline</legend>
            <label class="option">
              <input id="aiDisciplinePerfect" name="aiDiscipline" type="radio" value="perfect" checked>
              <span>Perfect</span>
            </label>
            <label class="option">
              <input id="aiDisciplinePragmatic" name="aiDiscipline" type="radio" value="pragmatic">
              <span>Pragmatic</span>
            </label>
            <label class="option">
              <input id="aiDisciplineReckless" name="aiDiscipline" type="radio" value="reckless">
              <span>Reckless</span>
            </label>
            <div class="badge" id="aiDisciplineApplyNote">Current: <span id="aiDisciplineCurrentBadge">perfect</span></div>
          </fieldset>

          <fieldset>
            <legend>AI side</legend>
            <label class="option">
              <input id="aiSideAuto" name="aiSide" type="radio" value="auto" checked>
              <span>Auto (opponent of First)</span>
            </label>
            <label class="option">
              <input id="aiSideX" name="aiSide" type="radio" value="X">
              <span>AI plays X</span>
            </label>
            <label class="option">
              <input id="aiSideO" name="aiSide" type="radio" value="O">
              <span>AI plays O</span>
            </label>
            <div class="badge" id="aiSideApplyNote">Current: <span id="aiSideCurrentBadge">auto</span></div>
          </fieldset>

          <fieldset>
            <legend>Apply</legend>
            <div class="badge">Settings persist across rounds. Saving does not reset the current round.</div>
            <div class="badge">Keyboard: Use Arrow keys + Enter/Space to play.</div>
          </fieldset>
        </div>
        <div class="actions">
          <button class="btn" id="saveCustomize" type="button">Save</button>
        </div>
      </div>
    </dialog>
  </div>

  <canvas id="confettiCanvas" style="position:fixed; inset:0; pointer-events:none;"></canvas>

  <script>
    (function(){
      // Viewport height CSS var for mobile
      function setVh(){
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', vh + 'px');
      }
      setVh();
      window.addEventListener('resize', setVh);

      // State
      const state = {
        board: Array(9).fill(null),
        current: 'X',
        gameOver: false,
        aiThinking: false,
        aiSymbol: null,
        scores: { X:0, O:0, D:0 },
        config: {
          theme: 'day', // 'night'
          glyphs: 'standard', // 'legion'
          mode: 'two', // 'ai'
          first: 'X',
          aiDiscipline: 'perfect',
          aiSide: 'auto' // 'X' | 'O' | 'auto'
        }
      };

      // DOM references
      const elBoard = document.getElementById('board');
      const elBanner = document.getElementById('victoryBanner');
      const elScoreX = document.getElementById('scoreX');
      const elScoreO = document.getElementById('scoreO');
      const elScoreD = document.getElementById('scoreDraw');
      const statusLive = document.getElementById('statusLive');
      const statusLiveAssertive = document.getElementById('statusLiveAssertive');
      const btnNewRound = document.getElementById('btnNewRound');
      const btnCustomize = document.getElementById('btnCustomize');
      const btnResetScores = document.getElementById('btnResetScores');
      const btnNewRoundInline = document.getElementById('btnNewRoundInline');
      const btnCustomizeInline = document.getElementById('btnCustomizeInline');
      const btnResetScoresInline = document.getElementById('btnResetScoresInline');
      const dialog = document.getElementById('dialogCustomize');
      const btnCloseCustomize = document.getElementById('closeCustomize');
      const btnSaveCustomize = document.getElementById('saveCustomize');
      const btnSaveCustomizeTop = document.getElementById('btnSaveCustomizeTop');
      const confettiCanvas = document.getElementById('confettiCanvas');
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Status proxies
      const turnIndicator = document.getElementById('turnIndicator');
      const boardLockStatus = document.getElementById('boardLockStatus');
      const aiStatus = document.getElementById('aiStatus');
      const keyboardHint = document.getElementById('keyboardHint');
      const newRoundStatus = document.getElementById('newRoundStatus');
      const resultStatus = document.getElementById('resultStatus');
      const gameStatus = document.getElementById('gameStatus');
      const applyStatus = document.getElementById('applyStatus');
      const confettiStatus = document.getElementById('confettiStatus');
      const scoreUpdateStatus = document.getElementById('scoreUpdateStatus');
      const themeLabel = document.getElementById('themeLabel');
      const glyphsLabel = document.getElementById('glyphsLabel');
      const modeLabel = document.getElementById('modeLabel');
      const firstLabel = document.getElementById('firstLabel');
      const aiDisciplineLabel = document.getElementById('aiDisciplineLabel');
      const aiSideLabel = document.getElementById('aiSideLabel');

      // Modal current badges
      const themeCurrentBadge = document.getElementById('themeCurrentBadge');
      const glyphsCurrentBadge = document.getElementById('glyphsCurrentBadge');
      const modeCurrentBadge = document.getElementById('modeCurrentBadge');
      const firstCurrentBadge = document.getElementById('firstCurrentBadge');
      const aiDisciplineCurrentBadge = document.getElementById('aiDisciplineCurrentBadge');
      const aiSideCurrentBadge = document.getElementById('aiSideCurrentBadge');

      // Controls: radios
      const getEl = (id)=> document.getElementById(id);
      const radio = {
        theme: [getEl('themeDay'), getEl('themeNight')],
        glyphs: [getEl('glyphStandard'), getEl('glyphLegion')],
        mode: [getEl('modeTwo'), getEl('modeAI')],
        first: [getEl('firstMoveX'), getEl('firstMoveO')],
        aiDiscipline: [getEl('aiDisciplinePerfect'), getEl('aiDisciplinePragmatic'), getEl('aiDisciplineReckless')],
        aiSide: [getEl('aiSideAuto'), getEl('aiSideX'), getEl('aiSideO')]
      };

      // Create cells with fixed IDs for automation
      for (let i=0;i<9;i++){
        const btn = document.createElement('button');
        btn.className = 'cell';
        btn.id = `cell-${i}`;
        btn.setAttribute('role','gridcell');
        const row = Math.floor(i/3)+1;
        const col = i%3 + 1;
        btn.setAttribute('aria-rowindex', String(row));
        btn.setAttribute('aria-colindex', String(col));
        btn.setAttribute('aria-label', `Empty. Row ${row} column ${col}`);
        btn.addEventListener('click', ()=> tryMove(i));
        btn.addEventListener('keydown', (e)=> handleCellKeyNav(e,i));
        elBoard.appendChild(btn);
      }

      function handleCellKeyNav(e,i){
        const key = e.key;
        let row = Math.floor(i/3), col = i%3;
        if (key === 'ArrowUp'){ e.preventDefault(); row = Math.max(0,row-1); focusCell(row*3+col); }
        else if (key === 'ArrowDown'){ e.preventDefault(); row = Math.min(2,row+1); focusCell(row*3+col); }
        else if (key === 'ArrowLeft'){ e.preventDefault(); col = Math.max(0,col-1); focusCell(row*3+col); }
        else if (key === 'ArrowRight'){ e.preventDefault(); col = Math.min(2,col+1); focusCell(row*3+col); }
        else if (key === 'Enter' || key === ' '){
          e.preventDefault(); tryMove(i);
        }
      }
      function focusCell(i){
        const cell = document.getElementById(`cell-${i}`);
        if (cell) cell.focus();
      }

      // Glyph rendering
      const GLADIUS_SVG = `
        <svg class="icon" viewBox="0 0 100 100" aria-hidden="true" focusable="false">
          <g transform="translate(50,50) rotate(45) translate(-50,-50)">
            <rect x="44" y="12" width="12" height="46" rx="0" fill="#a9b5bf" stroke="#000000" stroke-width="2"/>
            <polygon points="44,12 56,12 50,4" fill="#b7c5cf" stroke="#000000" stroke-width="2"/>
            <rect x="38" y="58" width="24" height="6" rx="0" fill="#000000" stroke="#000000" stroke-width="2"/>
            <rect x="45" y="64" width="10" height="18" rx="0" fill="#000000" stroke="#000000" stroke-width="2"/>
            <rect x="47" y="82" width="6" height="6" rx="0" fill="#000000" stroke="#000000" stroke-width="2"/>
          </g>
        </svg>`;
      const LAUREL_SVG = `
        <svg class="icon" viewBox="0 0 100 100" aria-hidden="true" focusable="false">
          <g fill="none" stroke="#2f8a57" stroke-width="4" stroke-linecap="square" stroke-linejoin="miter">
            <path d="M30,65 C20,50 20,40 28,28" />
            <path d="M70,65 C80,50 80,40 72,28" />
            <path d="M28,28 c-6,2 -8,8 -9,12" />
            <path d="M31,33 c-7,3 -8,9 -9,13" />
            <path d="M34,38 c-6,4 -7,9 -7,13" />
            <path d="M37,43 c-6,4 -6,9 -6,12" />
            <path d="M40,48 c-6,4 -6,9 -6,12" />
            <path d="M72,28 c6,2 8,8 9,12" />
            <path d="M69,33 c7,3 8,9 9,13" />
            <path d="M66,38 c6,4 7,9 7,13" />
            <path d="M63,43 c6,4 6,9 6,12" />
            <path d="M60,48 c6,4 6,9 6,12" />
          </g>
        </svg>`;

      function renderMark(symbol){
        if (state.config.glyphs === 'standard'){
          const span = document.createElement('span');
          span.className = `mark ${symbol.toLowerCase()}`;
          span.textContent = symbol;
          return span;
        } else {
          const wrapper = document.createElement('div');
          wrapper.innerHTML = symbol === 'X' ? GLADIUS_SVG : LAUREL_SVG;
          return wrapper.firstElementChild;
        }
      }

      function announce(msg){
        statusLive.textContent = msg;
      }
      function announceAssertive(msg){
        statusLiveAssertive.textContent = msg;
      }

      function updateBoardUI(){
        for (let i=0;i<9;i++){
          const btn = document.getElementById(`cell-${i}`);
          btn.classList.remove('win');
          btn.innerHTML = '';
          const val = state.board[i];
          const row = Math.floor(i/3)+1, col = i%3+1;
          if (val){
            btn.appendChild(renderMark(val));
            btn.setAttribute('aria-label', `${val}. Row ${row} column ${col}`);
            btn.disabled = true;
          } else {
            btn.setAttribute('aria-label', `Empty. Row ${row} column ${col}. ${state.current}'s turn`);
            btn.disabled = state.gameOver || state.aiThinking;
          }
        }
        updateStatusBar();
      }

      function updateStatusBar(){
        turnIndicator.textContent = `Turn: ${state.gameOver ? '—' : state.current}`;
        boardLockStatus.textContent = `Board: ${elBoard.dataset.locked === 'true' ? 'locked' : 'unlocked'}`;
        aiStatus.textContent = `AI: ${state.aiThinking ? 'thinking' : 'idle'}`;
        themeLabel.textContent = state.config.theme;
        glyphsLabel.textContent = state.config.glyphs;
        modeLabel.textContent = state.config.mode;
        firstLabel.textContent = state.config.first;
        aiDisciplineLabel.textContent = state.config.aiDiscipline;
        aiSideLabel.textContent = state.config.aiSide;
        themeCurrentBadge.textContent = state.config.theme;
        glyphsCurrentBadge.textContent = state.config.glyphs;
        modeCurrentBadge.textContent = state.config.mode;
        firstCurrentBadge.textContent = state.config.first;
        aiDisciplineCurrentBadge.textContent = state.config.aiDiscipline;
        aiSideCurrentBadge.textContent = state.config.aiSide;
      }

      function setTheme(theme){
        document.body.dataset.theme = theme;
        updateStatusBar();
      }

      function computeAISymbol(){
        if (state.config.mode !== 'ai') return null;
        if (state.config.aiSide === 'auto'){
          return state.config.first === 'X' ? 'O' : 'X';
        }
        return state.config.aiSide;
      }

      function setBoardLocked(locked, reason){
        elBoard.dataset.locked = locked ? 'true' : 'false';
        boardLockStatus.textContent = `Board: ${locked ? 'locked' : 'unlocked'}`;
        if (locked){
          gameStatus.textContent = reason ? `Board locked (${reason}).` : 'Board locked.';
        } else {
          gameStatus.textContent = 'Board unlocked.';
        }
        // reflect disabled state on empty cells
        for (let i=0;i<9;i++){
          const btn = document.getElementById(`cell-${i}`);
          if (!state.board[i]){
            btn.disabled = locked || state.gameOver;
          }
        }
      }

      function newRound(){
        state.board = Array(9).fill(null);
        state.gameOver = false;
        state.aiThinking = false;
        state.current = state.config.first;
        state.aiSymbol = computeAISymbol();
        elBanner.classList.remove('show');
        elBanner.textContent = '';
        resultStatus.textContent = 'Result: none';
        newRoundStatus.textContent = 'Round: started';
        confettiStatus.textContent = 'Confetti: idle';
        setBoardLocked(false);
        updateBoardUI();
        announce(`${state.current} to play.`);
        gameStatus.textContent = `${state.current} to play.`;
        // AI opens if it is first
        if (state.config.mode === 'ai' && state.current === state.aiSymbol){
          maybeQueueAITurn();
        }
      }

      function endRound(winner, line){
        state.gameOver = true;
        // Highlight
        if (line){
          line.forEach(i=>{
            document.getElementById(`cell-${i}`).classList.add('win');
          });
        }
        // Score and banner
        if (winner === 'X' || winner === 'O'){
          state.scores[winner]++;
          elBanner.textContent = `${winner} triumphs!`;
          resultStatus.textContent = `Result: win ${winner}`;
          announce(`${winner} wins.`);
          announceAssertive(`${winner} wins.`);
          fireConfetti();
        } else {
          state.scores.D++;
          elBanner.textContent = `Stalemate: Pax Romana.`;
          resultStatus.textContent = 'Result: draw';
          announce(`Draw.`);
          announceAssertive(`Draw.`);
        }
        elBanner.classList.add('show');
        updateScoresUI();
        // Lock board after completion
        setBoardLocked(true, 'round complete');
        aiStatus.textContent = 'AI: idle';
      }

      function updateScoresUI(){
        elScoreX.textContent = state.scores.X;
        elScoreO.textContent = state.scores.O;
        elScoreD.textContent = state.scores.D;
        scoreUpdateStatus.textContent = 'Scores: updated';
        try{
          localStorage.setItem('spqr_scores', JSON.stringify(state.scores));
        }catch(e){}
      }

      function currentIsAI(){
        return (state.config.mode === 'ai' && state.current === state.aiSymbol);
      }

      function tryMove(i){
        // Prevent human moves while AI is thinking or when it's AI's turn
        if (state.gameOver) return;
        if (elBoard.dataset.locked === 'true' && !currentIsAI()){ announce('Board is locked.'); return; }
        if (state.config.mode === 'ai' && state.aiThinking && !currentIsAI()){ announce('AI is thinking. Please wait.'); return; }
        if (state.config.mode === 'ai' && currentIsAI() && !state.aiThinking){
          // This path occurs only if AI flag wasn't set yet; guard against human spamming.
          setBoardLocked(true, 'ai');
          state.aiThinking = true;
          aiStatus.textContent = 'AI: thinking';
          return;
        }
        if (state.board[i]) return;

        const current = state.current; // mark whose move is being placed
        state.board[i] = current;
        const row = Math.floor(i/3)+1, col = i%3+1;
        announce(`${current} places at row ${row}, column ${col}.`);
        const result = checkWinner(state.board);
        updateBoardUI();
        if (result.winner){
          endRound(result.winner, result.line);
          return;
        }
        if (result.draw){
          endRound(null, null);
          return;
        }
        // Switch turn
        state.current = current === 'X' ? 'O' : 'X';
        announce(`${state.current} to play.`);
        gameStatus.textContent = `${state.current} to play.`;

        // If the move just placed was by AI, unlock for human
        if (state.config.mode === 'ai'){
          if (current === state.aiSymbol){
            state.aiThinking = false;
            setBoardLocked(false);
            aiStatus.textContent = 'AI: idle';
          }
        }

        // AI turn if applicable
        maybeQueueAITurn();
      }

      function maybeQueueAITurn(){
        if (state.gameOver) return;
        if (state.config.mode !== 'ai') return;
        if (state.current !== state.aiSymbol) return;
        if (state.aiThinking) return;
        // lock board during AI think
        state.aiThinking = true;
        setBoardLocked(true, 'ai');
        aiStatus.textContent = 'AI: thinking';
        // small delay to feel human
        setTimeout(()=>{
          const move = chooseAIMove(state.board, state.aiSymbol, aiOpponent(state.aiSymbol), state.config.aiDiscipline);
          if (move != null){
            tryMove(move);
          } else {
            // Fallback: unlock just in case
            state.aiThinking = false;
            setBoardLocked(false);
            aiStatus.textContent = 'AI: idle';
          }
        }, 360);
      }
      function aiOpponent(aiSymbol){ return aiSymbol === 'X' ? 'O' : 'X'; }

      function checkWinner(b){
        const wins = [
          [0,1,2],[3,4,5],[6,7,8],
          [0,3,6],[1,4,7],[2,5,8],
          [0,4,8],[2,4,6]
        ];
        for (const line of wins){
          const [a,b2,c]=line;
          if (b[a] && b[a]===b[b2] && b[a]===b[c]){
            return { winner: b[a], line, draw:false };
          }
        }
        if (b.every(Boolean)) return { winner:null, line:null, draw:true };
        return { winner:null, line:null, draw:false };
      }

      function emptyIndices(b){
        const arr = [];
        for (let i=0;i<9;i++) if (!b[i]) arr.push(i);
        return arr;
      }

      function chooseAIMove(board, ai, human, discipline){
        // If first move and center empty, prefer center for all but reckless
        if (discipline !== 'reckless' && board.every(v=>v===null)){ return 4; }
        if (discipline === 'perfect'){
          const {index} = minimax(board.slice(), ai, ai, human);
          return index;
        } else if (discipline === 'pragmatic'){
          const avail = emptyIndices(board);
          // Take immediate win
          for (const idx of avail){
            const tmp = board.slice();
            tmp[idx]=ai;
            if (checkWinner(tmp).winner===ai) return idx;
          }
          // Block immediate loss
          for (const idx of avail){
            const tmp = board.slice();
            tmp[idx]=human;
            if (checkWinner(tmp).winner===human) return idx;
          }
          // 70% choose best, 30% choose random among remaining
          const r = Math.random();
          if (r < 0.7){
            const {index} = minimax(board.slice(), ai, ai, human);
            return index;
          } else {
            return avail[Math.floor(Math.random()*avail.length)];
          }
        } else {
          // Reckless: if can win now, do; else random move
          const avail = emptyIndices(board);
          for (const idx of avail){
            const tmp = board.slice();
            tmp[idx]=ai;
            if (checkWinner(tmp).winner===ai) return idx;
          }
          return avail[Math.floor(Math.random()*avail.length)];
        }
      }

      function minimax(board, player, ai, human){
        const res = checkWinner(board);
        if (res.winner === ai) return { score: 10, index: null };
        if (res.winner === human) return { score: -10, index: null };
        if (res.draw) return { score: 0, index: null };

        const avail = emptyIndices(board);
        let bestMove = null;
        if (player === ai){
          let bestScore = -Infinity;
          for (const idx of avail){
            board[idx] = player;
            const move = minimax(board, human, ai, human);
            board[idx] = null;
            const score = move.score - 1; // prefer fast wins
            if (score > bestScore){
              bestScore = score;
              bestMove = { index: idx, score: bestScore };
            }
          }
          return bestMove;
        } else {
          let bestScore = Infinity;
          for (const idx of avail){
            board[idx] = player;
            const move = minimax(board, ai, ai, human);
            board[idx] = null;
            const score = move.score + 1; // delay opponent win
            if (score < bestScore){
              bestScore = score;
              bestMove = { index: idx, score: bestScore };
            }
          }
          return bestMove;
        }
      }

      // Confetti
      const ctx = confettiCanvas.getContext('2d');
      let confettiParticles = [];
      let confettiRunning = false;
      function resizeCanvas(){
        confettiCanvas.width = window.innerWidth;
        confettiCanvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      function fireConfetti(){
        if (prefersReducedMotion) return;
        confettiParticles = [];
        const colors = ['#000000','#666666','#999999','#222222','#444444'];
        const count = Math.min(220, Math.floor((window.innerWidth*window.innerHeight)/12000));
        for (let i=0;i<count;i++){
          confettiParticles.push({
            x: Math.random()*confettiCanvas.width,
            y: -10 - Math.random()*confettiCanvas.height*0.3,
            r: 3 + Math.random()*3,
            d: 2 + Math.random()*2.5,
            tilt: Math.random()*10,
            tiltAngle: Math.random()*Math.PI,
            tiltAngleInc: 0.02 + Math.random()*0.08,
            color: colors[Math.floor(Math.random()*colors.length)]
          });
        }
        confettiStatus.textContent = 'Confetti: enabled';
        if (!confettiRunning){
          confettiRunning = true;
          requestAnimationFrame(confettiLoop);
        }
        setTimeout(()=>{ confettiParticles = []; }, 1600);
      }
      function confettiLoop(){
        if (!confettiRunning) return;
        ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
        if (confettiParticles.length === 0){ confettiRunning = false; return; }
        for (const p of confettiParticles){
          ctx.beginPath();
          ctx.fillStyle = p.color;
          ctx.arc(p.x + p.tilt, p.y, p.r, 0, Math.PI*2);
          ctx.fill();
        }
        // update
        for (const p of confettiParticles){
          p.tiltAngle += p.tiltAngleInc;
          p.y += p.d;
          p.x += Math.sin(p.tiltAngle) * 1.4;
          p.tilt = Math.sin(p.tiltAngle) * 8;
        }
        // recycle
        for (let i=confettiParticles.length-1;i>=0;i--){
          const p = confettiParticles[i];
          if (p.y > confettiCanvas.height + 20){
            confettiParticles.splice(i,1);
          }
        }
        requestAnimationFrame(confettiLoop);
      }

      // Top/inlined actions share the same handlers
      function handleNewRoundClick(){
        if (dialog.open) closeCustomize();
        newRound();
      }
      function handleResetScoresClick(){
        state.scores = {X:0,O:0,D:0};
        updateScoresUI();
        gameStatus.textContent = 'Scores reset.';
        announce('Scores reset.');
      }
      function handleCustomizeClick(){
        openCustomize();
      }

      btnNewRound.addEventListener('click', handleNewRoundClick);
      btnNewRoundInline.addEventListener('click', handleNewRoundClick);
      btnResetScores.addEventListener('click', handleResetScoresClick);
      btnResetScoresInline.addEventListener('click', handleResetScoresClick);
      btnCustomize.addEventListener('click', handleCustomizeClick);
      btnCustomizeInline.addEventListener('click', handleCustomizeClick);

      // Customize dialog behavior
      function openCustomize(){
        // set radios from state
        radio.theme.forEach(r=> r.checked = (r.value === state.config.theme));
        radio.glyphs.forEach(r=> r.checked = (r.value === state.config.glyphs));
        radio.mode.forEach(r=> r.checked = (r.value === state.config.mode));
        radio.first.forEach(r=> r.checked = (r.value === state.config.first));
        radio.aiDiscipline.forEach(r=> r.checked = (r.value === state.config.aiDiscipline));
        radio.aiSide.forEach(r=> r.checked = (r.value === state.config.aiSide));
        if (typeof dialog.showModal === 'function'){ dialog.showModal(); }
        else { dialog.setAttribute('open',''); }
        getEl('themeDay').focus();
        applyStatus.textContent = 'Customize: pending';
      }
      function closeCustomize(){
        if (dialog.open) dialog.close();
      }
      function saveCustomize(){
        const sel = (list)=> list.find(r=>r.checked).value;
        const prev = JSON.parse(JSON.stringify(state.config));
        state.config.theme = sel(radio.theme);
        state.config.glyphs = sel(radio.glyphs);
        state.config.mode = sel(radio.mode);
        state.config.first = sel(radio.first);
        state.config.aiDiscipline = sel(radio.aiDiscipline);
        state.config.aiSide = sel(radio.aiSide);
        setTheme(state.config.theme);
        // Do not reset the round. Keep positions; just refresh UI
        updateBoardUI();
        announce('Settings updated.');
        gameStatus.textContent = 'Settings applied.';
        applyStatus.textContent = 'Customize: done';
        // Persist
        try{ localStorage.setItem('spqr_config', JSON.stringify(state.config)); }catch(e){}

        // Enable/disable AI radios based on mode visibly (no disabled attribute to keep them accessible, but we keep semantics)
        // If it becomes AI mode and it's AI's turn now, queue AI immediately
        state.aiSymbol = computeAISymbol();
        if (state.config.mode === 'ai' && state.current === state.aiSymbol && !state.gameOver){
          maybeQueueAITurn();
        } else {
          // Ensure board lock reflects current thinking state
          setBoardLocked(state.aiThinking, state.aiThinking ? 'ai' : undefined);
        }
        closeCustomize();
      }

      btnSaveCustomize.addEventListener('click', saveCustomize);
      btnSaveCustomizeTop.addEventListener('click', saveCustomize);
      btnCloseCustomize.addEventListener('click', closeCustomize);
      dialog.addEventListener('cancel', (e)=>{ e.preventDefault(); closeCustomize(); });

      // Load persisted config/scores
      (function initFromStorage(){
        try{
          const cfg = localStorage.getItem('spqr_config');
          if (cfg){
            const parsed = JSON.parse(cfg);
            Object.assign(state.config, parsed||{});
          }
          const sc = localStorage.getItem('spqr_scores');
          if (sc){
            const parsedS = JSON.parse(sc);
            if (parsedS && typeof parsedS.X === 'number' && typeof parsedS.O === 'number' && typeof parsedS.D === 'number'){
              state.scores = parsedS;
            }
          }
        }catch(e){}
      })();

      // Init
      setTheme(state.config.theme);
      updateScoresUI();
      newRound();

      // Ensure board cells are focusable initially
      focusCell(4);

      // Expose required functions by name for non-regression references (already defined)
      window.setVh = setVh;
      window.handleCellKeyNav = handleCellKeyNav;
      window.focusCell = focusCell;
      window.renderMark = renderMark;
      window.announce = announce;
      window.updateBoardUI = updateBoardUI;
      window.setTheme = setTheme;
      window.newRound = newRound;
      window.endRound = endRound;
      window.updateScoresUI = updateScoresUI;
      window.tryMove = tryMove;
      window.maybeQueueAITurn = maybeQueueAITurn;
      window.aiOpponent = aiOpponent;
      window.checkWinner = checkWinner;
      window.emptyIndices = emptyIndices;
      window.chooseAIMove = chooseAIMove;
      window.minimax = minimax;
      window.resizeCanvas = resizeCanvas;
      window.fireConfetti = fireConfetti;
      window.confettiLoop = confettiLoop;
      window.openCustomize = openCustomize;
      window.closeCustomize = closeCustomize;
      window.saveCustomize = saveCustomize;
      window.setAIDisciplineDisabled = function(){ /* kept for non-regression; behavior handled by saveCustomize */ };

      // Keep required event names present (already in use)
      window.addEventListener('change', function(){ /* presence only */ });

    })();
  </script>
</body>
</html>
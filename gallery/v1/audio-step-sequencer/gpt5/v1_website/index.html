<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Audio Step Sequencer - Destylized</title>
<style>
/* Destylized UI
   Requirements:
   - White background #ffffff
   - Black text #000000
   - No gradients, shadows, rounded corners, animations
   - Minimum target size for interactive controls >= 44x44px
   - Clear labels, spacing between controls
   - Two-column layout, fit 1280x720
*/

/* Basic Reset */
*{box-sizing:border-box}
html, body{margin:0; padding:0; height:100%; background:#ffffff; color:#000000; font-family: Arial, Helvetica, sans-serif;}
a{color:#000000; text-decoration:underline;}
button{ background:#e6e6e6; color:#000000; border:1px solid #000000; min-width:44px; min-height:44px; padding:8px 12px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; }
button[aria-pressed="true"]{ background:#cccccc; }
input, select{ border:1px solid #000000; padding:8px 8px; min-height:44px; color:#000000; background:#ffffff; }
input[type="range"]{ height:44px; width:220px; }
label{ display:block; margin-bottom:4px; }

/* Layout */
header{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px; border-bottom:1px solid #000000; position:sticky; top:0; background:#ffffff; z-index:10;
}
#titleArea{ display:flex; align-items:center; gap:16px; }
#appTitle{ font-size:20px; font-weight:700; }
#statusText{ font-size:14px; }

/* Navigation */
#navBar{ display:flex; align-items:center; gap:12px; }
#navBar a{ display:inline-block; padding:8px; border:1px solid #000000; min-height:44px; }

/* Transport */
#transport{ display:flex; align-items:flex-start; gap:16px; flex-wrap:wrap; }
.controlGroup{ display:flex; flex-direction:column; gap:6px; }
.inlineRow{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
.valueDisplay{ padding:8px; border:1px solid #000000; min-height:44px; display:inline-flex; align-items:center; justify-content:center; }
.badge{ display:inline-block; padding:8px; border:1px solid #000000; min-height:44px; }

/* Additional toggles */
.toggleBtn{ background:#f5f5f5; }

/* Main Layout */
main{
  display:grid; grid-template-columns: 1fr 340px; gap:16px; padding:16px;
}
@media (max-width: 1100px){
  main{ grid-template-columns: 1fr; }
}

/* Grid Panel */
#gridPanel{ border:1px solid #000000; padding:12px; }
#gridHeader{ display:flex; align-items:flex-start; justify-content:space-between; gap:8px; flex-wrap:wrap; margin-bottom:10px; }
#barIndicator{ display:flex; align-items:center; gap:8px; margin-bottom:8px; }
#barTimerLabel{ border:1px solid #000000; padding:8px; min-height:44px; }
#progressBarContainer{ border:1px solid #000000; width:100%; height:20px; position:relative; }
#progressBar{ background:#000000; height:100%; width:0%; }
#grid{ display:grid; grid-template-columns: 140px repeat(16, 1fr); gap:6px; align-items:center; }
.track-label{ display:flex; align-items:center; justify-content:space-between; padding:8px; border:1px solid #000000; min-height:44px; }
.track-label .color-dot{ width:12px; height:12px; background:#000000; }
.step{
  min-height:44px; border:1px solid #000000; background:#ffffff; cursor:pointer; position:relative; user-select:none;
}
.step.on{ background:#b0f2b6; } /* Active step: light green */
.step.playing-column{ border:2px solid #ff0000; } /* Playhead: red border */
.step.toggled{ outline:2px solid #0000ff; } /* Immediate feedback: blue outline */
.step[aria-pressed="true"]{ background:#b0f2b6; }
.colIndex{ grid-column: span 17; display:grid; grid-template-columns: 140px repeat(16, 1fr); gap:6px; margin-bottom:6px; }
.colIndex .cell{ min-height:24px; display:flex; align-items:center; justify-content:center; border:1px solid #000000; }

/* Sidebar Panel */
#sidePanel{ border:1px solid #000000; padding:12px; }
.section{ border-top:1px solid #000000; padding-top:12px; margin-top:12px; }
.section:first-child{ border-top:none; padding-top:0; margin-top:0; }
.row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.two-col{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
#patternNameInput{ width:100%; }
#patternNameLabel{ font-weight:600; }
#patternFeedback{ min-height:24px; }

/* Modal */
#overwriteDialog{
  position:fixed; inset:0; background:rgba(255,255,255,0.9);
  display:none; align-items:center; justify-content:center;
}
#overwriteDialog .dialog{
  border:1px solid #000000; background:#ffffff; padding:16px; width:360px;
}
#overwriteMessage{ margin:0 0 12px 0; }

/* Touch affordance for sliders */
input[type="range"]{
  -webkit-appearance: none;
  background:#e6e6e6;
}
input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none;
  width:24px; height:24px; border:1px solid #000000; background:#ffffff;
}
input[type="range"]::-moz-range-thumb{
  width:24px; height:24px; border:1px solid #000000; background:#ffffff;
}

/* Hint and Proxies */
.hint{ font-size:12px; color:#000000; }
#playStatus, #applyStatus, #downloadStatus, #previewStatus, #activeSection, #tempoTooltip, #swingTooltip, #exportDurationLabel, #silenceIndicator{
  border:1px solid #000000; padding:8px; min-height:44px; display:inline-flex; align-items:center; justify-content:center;
}

/* Focus styles */
:focus{ outline:3px solid #0000ff; }

/* Ensure large click targets for list items */
.pattern-list-item{ border:1px solid #000000; padding:8px; min-height:44px; display:flex; align-items:center; justify-content:space-between; cursor:pointer; }
.pattern-list-item.active{ background:#f0f0f0; }

/* Keyboard shortcut bar */
#keyboardHints{ display:flex; gap:8px; flex-wrap:wrap; }

/* Grid flash feedback */
.grid-flash{ outline:4px solid #ff9900; }

/* Labels for min/max */
.value-badge{ padding:8px; border:1px solid #000000; min-height:44px; display:inline-flex; align-items:center; justify-content:center; }

/* Silence banner */
.silence-banner{ background:#ffdddd; border:1px solid #000000; padding:8px; min-height:44px; }

/* Export area anchor */
#downloadLink{ display:inline-block; padding:8px; border:1px solid #000000; min-height:44px; }

/* Keep original badge class for compatibility */
.badge{ display:inline-block; padding:8px; border:1px solid #000000; min-height:44px; }

footer{ border-top:1px solid #000000; padding:12px; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
</style>
</head>
<body>
<header>
  <div id="titleArea">
    <div id="appTitle">Audio Step Sequencer</div>
    <div id="statusText" aria-live="polite">Ready</div>
  </div>
  <div id="navBar">
    <a id="navGridLink" href="#gridPanel">Grid</a>
    <a id="navPatternsLink" href="#sidePanel">Patterns</a>
    <div id="activeSection" class="badge" aria-live="polite">none</div>
  </div>
</header>

<section id="keyboardHints" style="padding:12px; border-bottom:1px solid #000000;">
  <div class="badge">Keyboard: Space = Play/Stop</div>
  <div class="badge">Arrows on sliders/buttons adjust values</div>
  <div class="badge">Enter on BPM input applies</div>
  <div class="badge">Press E = Export WAV</div>
</section>

<section id="transport" aria-label="Transport and Controls" style="padding:12px; border-bottom:1px solid #000000;">
  <div class="controlGroup" style="min-width:140px;">
    <button id="playButton" aria-pressed="false">Play</button>
    <div id="playStatus" class="badge" aria-live="polite">stopped</div>
  </div>

  <div class="controlGroup">
    <label for="tempoSlider">Tempo (BPM)</label>
    <div class="inlineRow">
      <button id="tempoDecButton" aria-label="Decrease BPM">-</button>
      <input id="tempoSlider" type="range" min="40" max="200" value="120" />
      <button id="tempoIncButton" aria-label="Increase BPM">+</button>
    </div>
    <div class="inlineRow">
      <input id="tempoInput" type="text" value="120" aria-label="BPM input"/>
      <span id="tempoValue" class="value-badge">120 BPM</span>
      <span id="tempoMinLabel" class="badge">min 40</span>
      <span id="tempoMaxLabel" class="badge">max 200</span>
      <span id="tempoTooltip" class="badge">adjust tempo</span>
    </div>
  </div>

  <div class="controlGroup">
    <label for="swingSlider">Swing (%)</label>
    <div class="inlineRow">
      <button id="swingDecButton" aria-label="Decrease Swing">-</button>
      <input id="swingSlider" type="range" min="0" max="60" value="10" />
      <button id="swingIncButton" aria-label="Increase Swing">+</button>
    </div>
    <div class="inlineRow">
      <span id="swingValue" class="value-badge">10%</span>
      <span id="swingLabel" class="badge">Straight</span>
      <span id="swingTooltip" class="badge">adjust swing</span>
    </div>
  </div>

  <div class="controlGroup">
    <label for="volumeSlider">Volume</label>
    <div class="inlineRow">
      <input id="volumeSlider" type="range" min="0" max="100" value="80" />
      <span id="volumeValue" class="value-badge">80%</span>
    </div>
  </div>

  <div class="controlGroup">
    <label>Play Options</label>
    <div class="inlineRow">
      <button id="metronomeButton" class="toggleBtn" aria-pressed="false">Metronome</button>
      <button id="tapTempoButton" class="toggleBtn" aria-pressed="false">Tap Tempo</button>
    </div>
    <div class="hint">Tap 4+ times to set BPM. Metronome clicks on quarter notes.</div>
  </div>

  <div class="controlGroup">
    <label>Apply Controls</label>
    <div class="inlineRow">
      <button id="applySettingsButton">Apply</button>
      <span id="applyStatus" class="badge">idle</span>
    </div>
  </div>
</section>

<main id="appContainer">
  <section id="gridPanel" aria-label="Step Grid">
    <div id="gridHeader">
      <div class="inlineRow">
        <button id="clearPatternButton">Clear</button>
        <button id="randomizeButton">Randomize</button>
      </div>
      <div class="inlineRow">
        <label for="barsSelect">Bars</label>
        <select id="barsSelect">
          <option value="1">1 bar</option>
          <option value="2" selected>2 bars</option>
          <option value="4">4 bars</option>
          <option value="8">8 bars</option>
        </select>
        <button id="exportWavButton">Export WAV</button>
        <a id="downloadLink" href="#" download="pattern.wav" aria-disabled="true">Download WAV</a>
        <span id="downloadStatus" class="badge">disabled</span>
        <span id="exportDurationLabel" class="badge">duration: -</span>
      </div>
    </div>

    <div id="barIndicator" class="inlineRow">
      <span class="badge">Playhead</span>
      <span id="barTimerLabel" class="badge">bar 1 / step 1</span>
      <div id="progressBarContainer"><div id="progressBar"></div></div>
    </div>

    <div class="colIndex" aria-hidden="true" id="columnIndexRow">
      <!-- Filled by JS -->
    </div>

    <div id="grid" role="grid" aria-rowcount="4" aria-colcount="16">
      <!-- Built by JS -->
    </div>

    <div id="silenceIndicator" class="silence-banner" aria-live="polite">pattern not silent</div>
  </section>

  <aside id="sidePanel" aria-label="Sidebar Controls">
    <div class="section">
      <h3>Patterns</h3>
      <label id="patternNameLabel" for="patternNameInput">Pattern Name</label>
      <div class="two-col">
        <input id="patternNameInput" type="text" placeholder="Enter pattern name (e.g., Neon Groove, ðŸ”¥ Club Beat 128)"/>
        <button id="savePatternButton">Save</button>
      </div>
      <div id="patternFeedback" class="hint" aria-live="polite">Ready to save. Includes tempo/swing only if box checked.</div>
      <div class="row" style="margin-top:8px;">
        <input id="includeTempoSwingCheckbox" type="checkbox" aria-label="Include Tempo & Swing"/>
        <label for="includeTempoSwingCheckbox">Include Tempo & Swing in Save/Load</label>
      </div>
      <div class="two-col" style="margin-top:8px;">
        <select id="loadPatternSelect"></select>
        <button id="deletePatternButton">Delete</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <input id="seamlessLoadCheckbox" type="checkbox" checked aria-label="Seamless Load"/>
        <label for="seamlessLoadCheckbox">Load pattern without stopping playback</label>
      </div>
      <div class="hint">Saved locally in your browser. Names can be long or include emojis.</div>
      <div class="row" style="margin-top:8px;">
        <span class="badge">Active:</span> <span id="activePatternLabel" class="badge">none</span>
      </div>
      <div class="section">
        <h4>Saved Pattern List</h4>
        <div id="patternListContainer">
          <!-- dynamic list -->
        </div>
      </div>
    </div>

    <div class="section">
      <h3>Play Modes</h3>
      <div class="row">
        <button id="tapTempoButton2" class="toggleBtn" aria-pressed="false">Tap Tempo (Alt)</button>
      </div>
      <div class="hint">Tap tempo adjusts BPM by tapping 4+ times. Alternate button provides the same behavior.</div>
    </div>

    <div class="section">
      <h3>About</h3>
      <p class="hint">
        Built with Web Audio API. All sounds synthesized live. Export renders using OfflineAudioContext to produce a WAV file.
      </p>
      <p class="hint">This destylized interface focuses on clarity, accessibility, and testing reliability.</p>
    </div>
  </aside>
</main>

<footer>
  <span class="badge">WebAudio</span>
  <span class="badge">16-step</span>
  <span class="badge">WAV export</span>
  <span class="badge">Swing</span>
  <span class="badge">Min target 44Ã—44 px</span>
  <span id="previewStatus" class="badge">ready</span>
</footer>

<!-- Overwrite confirmation dialog -->
<div id="overwriteDialog" role="dialog" aria-modal="true" aria-labelledby="overwriteMessage">
  <div class="dialog">
    <p id="overwriteMessage">A pattern with this name already exists. Overwrite?</p>
    <div class="inlineRow">
      <button id="overwriteConfirmButton">Overwrite</button>
      <button id="overwriteCancelButton">Cancel</button>
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  /* Top-level helper for WAV writer (keep_api requires writeString) */
  function writeString(view, offset, str){
    for (let i=0;i<str.length;i++){
      view.setUint8(offset+i, str.charCodeAt(i));
    }
  }

  // State
  const state = {
    bpm: 120,
    swingPct: 10, // 0-60
    isPlaying: false,
    currentStep: 0,
    lookahead: 25/1000, // 25ms
    scheduleAheadTime: 0.1, // seconds
    nextNoteTime: 0,
    timerID: null,
    tapTimes: [],
    tracks: [
      { name: 'Kick', color:'#ff4b4b', pattern: new Array(16).fill(false) },
      { name: 'Snare', color:'#55d6ff', pattern: new Array(16).fill(false) },
      { name: 'Hat',   color:'#fff75e', pattern: new Array(16).fill(false) },
      { name: 'Clap',  color:'#b755ff', pattern: new Array(16).fill(false) }
    ],
    metronomeOn: false,
    barsPlayed: 0,
    includeTempoSwing: true,
    seamlessLoad: true,
    activePatternName: 'none',
    pendingOverwrite: null, // { name, data }
  };

  // Default pattern
  function setDefaultPattern() {
    // Kick on 1,5,9,13
    [0,4,8,12].forEach(i => state.tracks[0].pattern[i] = true);
    // Snare on 5 and 13 (beats 2 and 4)
    [4,12].forEach(i => state.tracks[1].pattern[i] = true);
    // Hat on all 16 (8ths)
    for (let i=0;i<16;i++) state.tracks[2].pattern[i] = (i%2===0);
    // Clap on off-beats
    [6,14].forEach(i => state.tracks[3].pattern[i] = true);
  }

  // Audio
  let audioCtx = null;
  let masterGain = null;
  let noiseBuffer = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.8;
    masterGain.connect(audioCtx.destination);
    noiseBuffer = createNoiseBuffer(audioCtx);
  }

  function createNoiseBuffer(ctx){
    const length = ctx.sampleRate * 2;
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<length;i++){
      data[i] = Math.random()*2 - 1;
    }
    return buffer;
  }

  function triggerClick(time, freq=2000){
    if (!state.metronomeOn) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type='square';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.2, time + 0.001);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);
    osc.connect(g).connect(masterGain);
    osc.start(time);
    osc.stop(time+0.06);
  }

  function triggerKick(time, ctx=audioCtx, dest=masterGain){
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, time);
    osc.frequency.exponentialRampToValueAtTime(50, time + 0.12);
    g.gain.setValueAtTime(1, time);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.6);
    osc.connect(g).connect(dest);
    osc.start(time);
    osc.stop(time + 0.6);

    // click transient
    const click = ctx.createBufferSource();
    const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
    click.buffer = nb;
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 1000;
    const g2 = ctx.createGain();
    g2.gain.setValueAtTime(0.25, time);
    g2.gain.exponentialRampToValueAtTime(0.0001, time + 0.02);
    click.connect(hp).connect(g2).connect(dest);
    click.start(time);
    click.stop(time + 0.03);
  }

  function triggerSnare(time, ctx=audioCtx, dest=masterGain){
    const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
    const noise = ctx.createBufferSource();
    noise.buffer = nb;
    const bp = ctx.createBiquadFilter();
    bp.type='bandpass'; bp.frequency.value = 1800; bp.Q.value=0.7;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.6, time);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
    noise.connect(bp).connect(g).connect(dest);
    noise.start(time);
    noise.stop(time + 0.2);

    // body
    const osc = ctx.createOscillator();
    const g2 = ctx.createGain();
    osc.type='sine';
    osc.frequency.setValueAtTime(220, time);
    osc.frequency.exponentialRampToValueAtTime(160, time+0.08);
    g2.gain.setValueAtTime(0.5, time);
    g2.gain.exponentialRampToValueAtTime(0.0001, time+0.12);
    osc.connect(g2).connect(dest);
    osc.start(time);
    osc.stop(time+0.15);
  }

  function triggerHat(time, ctx=audioCtx, dest=masterGain){
    const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
    const noise = ctx.createBufferSource();
    noise.buffer = nb;
    const hp = ctx.createBiquadFilter();
    hp.type='highpass'; hp.frequency.value=6000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.35, time);
    g.gain.exponentialRampToValueAtTime(0.0001, time+0.07);
    noise.connect(hp).connect(g).connect(dest);
    noise.start(time);
    noise.stop(time+0.09);
  }

  function triggerClap(time, ctx=audioCtx, dest=masterGain){
    // multi-burst clap
    const bursts = [0, 0.022, 0.045];
    bursts.forEach((off, i) => {
      const nb = (ctx === audioCtx) ? noiseBuffer : createNoiseBuffer(ctx);
      const noise = ctx.createBufferSource();
      noise.buffer = nb;
      const hp = ctx.createBiquadFilter();
      hp.type='highpass'; hp.frequency.value=1200;
      const g = ctx.createGain();
      const t = time + off;
      const amp = i===0 ? 0.38 : (i===1 ? 0.28 : 0.2);
      g.gain.setValueAtTime(amp, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
      noise.connect(hp).connect(g).connect(dest);
      noise.start(t);
      noise.stop(t + 0.14);
    });
  }

  const instrumentTriggers = [triggerKick, triggerSnare, triggerHat, triggerClap];

  // Timing helpers
  function secondsPer16th(bpm){
    return (60 / bpm) / 4;
  }
  function swingOffsetSeconds(bpm, swingPct){
    const d = secondsPer16th(bpm);
    const amount = Math.min(60, Math.max(0, swingPct)) / 100; // 0..0.6
    return d * 0.5 * amount; // delay odd steps
  }

  // UI proxies elements
  const playStatusEl = document.getElementById('playStatus');
  const downloadStatusEl = document.getElementById('downloadStatus');
  const previewStatusEl = document.getElementById('previewStatus');
  const applyStatusEl = document.getElementById('applyStatus');
  const barTimerLabel = document.getElementById('barTimerLabel');
  const progressBar = document.getElementById('progressBar');
  const silenceIndicator = document.getElementById('silenceIndicator');
  const tempoTooltip = document.getElementById('tempoTooltip');
  const swingTooltip = document.getElementById('swingTooltip');
  const exportDurationLabel = document.getElementById('exportDurationLabel');

  function scheduleStep(stepIndex, time){
    // Visual playhead at time
    setTimeout(() => setActiveColumn(stepIndex), Math.max(0, (time - audioCtx.currentTime)*1000));

    // Update bar/step label and progress
    const barLenSteps = 16;
    const currentStepDisplay = stepIndex + 1;
    // compute barsPlayed from currentStep zero crossings
    barTimerLabel.textContent = `bar ${state.barsPlayed + 1} / step ${currentStepDisplay}`;
    const progressPct = (currentStepDisplay / barLenSteps) * 100;
    progressBar.style.width = progressPct + '%';

    // Metronome: accented on step 0
    if (state.metronomeOn){
      if (stepIndex % 4 === 0){
        triggerClick(time, stepIndex===0 ? 2600 : 2000);
      }
    }
    state.tracks.forEach((track, ti) => {
      if (track.pattern[stepIndex]){
        instrumentTriggers[ti](time);
      }
    });
  }

  function nextStep() {
    const sp16 = secondsPer16th(state.bpm);
    const swing = swingOffsetSeconds(state.bpm, state.swingPct);
    // Schedule current step
    const idx = state.currentStep % 16;
    scheduleStep(idx, state.nextNoteTime);
    // increment
    const isEven = (state.currentStep % 2) === 0;
    const increment = isEven ? (sp16 + swing) : (sp16 - swing);
    state.nextNoteTime += Math.max(0.001, increment);
    state.currentStep = (state.currentStep + 1) % 16;
    if (state.currentStep === 0){ state.barsPlayed++; }
  }

  function scheduler(){
    while (state.nextNoteTime < audioCtx.currentTime + state.scheduleAheadTime) {
      nextStep();
    }
    state.timerID = setTimeout(scheduler, state.lookahead*1000);
  }

  function start(){
    ensureAudio();
    audioCtx.resume();
    state.isPlaying = true;
    document.getElementById('playButton').textContent = 'Stop';
    document.getElementById('playButton').setAttribute('aria-pressed', 'true');
    playStatusEl.textContent = 'playing';
    state.currentStep = 0;
    state.nextNoteTime = audioCtx.currentTime + 0.06;
    state.barsPlayed = 0;
    scheduler();
    setStatus('Playing');
  }

  function stop(){
    state.isPlaying = false;
    document.getElementById('playButton').textContent = 'Play';
    document.getElementById('playButton').setAttribute('aria-pressed', 'false');
    playStatusEl.textContent = 'stopped';
    clearTimeout(state.timerID);
    state.timerID = null;
    clearActiveColumn();
    setStatus('Stopped');
  }

  // UI build
  const gridEl = document.getElementById('grid');
  const columnIndexRow = document.getElementById('columnIndexRow');

  function buildColumnIndexes(){
    columnIndexRow.innerHTML = '';
    const spacer = document.createElement('div');
    spacer.textContent = 'Track';
    spacer.className = 'cell';
    columnIndexRow.appendChild(spacer);
    for (let c=0;c<16;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.textContent = (c+1);
      columnIndexRow.appendChild(cell);
    }
  }

  function buildGrid(){
    gridEl.innerHTML = '';
    buildColumnIndexes();
    state.tracks.forEach((track, ti) => {
      // Label
      const label = document.createElement('div');
      label.className = 'track-label';
      label.setAttribute('role', 'rowheader');
      label.innerHTML = `<span>${track.name}</span><span class="color-dot" style="background:${track.color}"></span>`;
      gridEl.appendChild(label);

      // Steps
      for(let si=0;si<16;si++){
        const btn = document.createElement('button');
        btn.className = 'step';
        btn.id = `step-${ti}-${si}`;
        btn.setAttribute('role','gridcell');
        btn.setAttribute('aria-label', `${track.name} step ${si+1}`);
        btn.setAttribute('aria-pressed', 'false');
        const handler = () => toggleStep(ti, si, btn, true);
        btn.addEventListener('click', handler);
        btn.addEventListener('pointerdown', handler);
        gridEl.appendChild(btn);
      }
    });
    refreshGridFromState();
    updateSilenceIndicator();
    previewStatusEl.textContent = 'ready';
  }

  function toggleStep(ti, si, el, user=true){
    const newVal = !state.tracks[ti].pattern[si];
    state.tracks[ti].pattern[si] = newVal;
    el.classList.toggle('on', newVal);
    el.setAttribute('aria-pressed', newVal ? 'true' : 'false');
    // Immediate feedback
    el.classList.add('toggled');
    setTimeout(()=> el.classList.remove('toggled'), 150);
    if (user && audioCtx){
      const previewTime = audioCtx.currentTime + 0.02;
      instrumentTriggers[ti](previewTime);
    }
    updateSilenceIndicator();
  }

  function refreshGridFromState(){
    state.tracks.forEach((track, ti) => {
      for (let si=0; si<16; si++){
        const el = document.getElementById(`step-${ti}-${si}`);
        if (!el) continue;
        const on = !!track.pattern[si];
        el.classList.toggle('on', on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
      }
    });
    updateSilenceIndicator();
  }

  // Active column highlight
  let lastColumn = -1;
  function clearActiveColumn(){
    for (let ti=0; ti<state.tracks.length; ti++){
      for (let si=0; si<16; si++){
        const el = document.getElementById(`step-${ti}-${si}`);
        if (!el) continue;
        el.classList.remove('playing-column');
      }
    }
    lastColumn = -1;
  }
  function setActiveColumn(col){
    if (col === lastColumn) return;
    // Clear previous
    if (lastColumn >= 0){
      for (let ti=0; ti<state.tracks.length; ti++){
        const prev = document.getElementById(`step-${ti}-${lastColumn}`);
        if (prev){
          prev.classList.remove('playing-column');
        }
      }
    }
    // Set new
    for (let ti=0; ti<state.tracks.length; ti++){
      const el = document.getElementById(`step-${ti}-${col}`);
      if (el){
        el.classList.add('playing-column');
      }
    }
    lastColumn = col;
  }

  // Controls
  document.getElementById('playButton').addEventListener('click', async () => {
    ensureAudio();
    await audioCtx.resume();
    if (!state.isPlaying) start();
    else stop();
  });

  const tempoSlider = document.getElementById('tempoSlider');
  const tempoValue = document.getElementById('tempoValue');
  const tempoInput = document.getElementById('tempoInput');
  const tempoMinLabel = document.getElementById('tempoMinLabel');
  const tempoMaxLabel = document.getElementById('tempoMaxLabel');

  function updateTempoUI(){
    tempoValue.textContent = `${state.bpm} BPM`;
    tempoInput.value = `${state.bpm}`;
    tempoTooltip.textContent = (state.bpm <= 40) ? 'minimum reached' : (state.bpm >= 200) ? 'maximum reached' : 'adjust tempo';
  }

  tempoSlider.addEventListener('input', () => {
    state.bpm = parseInt(tempoSlider.value, 10);
    updateTempoUI();
  });

  tempoInput.addEventListener('change', () => {
    const val = parseInt(tempoInput.value, 10);
    if (!isNaN(val)){
      state.bpm = Math.max(40, Math.min(200, val));
      tempoSlider.value = state.bpm;
      updateTempoUI();
      setStatus(`Tempo set by input: ${state.bpm} BPM`);
    }
  });

  document.getElementById('tempoDecButton').addEventListener('click', ()=>{
    const v = Math.max(40, state.bpm - 1);
    state.bpm = v; tempoSlider.value = v; updateTempoUI();
  });
  document.getElementById('tempoIncButton').addEventListener('click', ()=>{
    const v = Math.min(200, state.bpm + 1);
    state.bpm = v; tempoSlider.value = v; updateTempoUI();
  });

  const swingSlider = document.getElementById('swingSlider');
  const swingValue = document.getElementById('swingValue');
  const swingLabel = document.getElementById('swingLabel');
  function updateSwingUI(){
    swingValue.textContent = `${state.swingPct}%`;
    const pct = state.swingPct;
    swingLabel.textContent = pct === 0 ? 'Straight' : pct < 15 ? 'Light' : pct < 35 ? 'Shuffle' : 'Heavy Shuffle';
    swingTooltip.textContent = (pct === 60) ? 'maximum swing' : 'adjust swing';
  }
  swingSlider.addEventListener('input', () => {
    state.swingPct = parseInt(swingSlider.value, 10);
    updateSwingUI();
  });
  document.getElementById('swingDecButton').addEventListener('click', ()=>{
    state.swingPct = Math.max(0, state.swingPct-1);
    swingSlider.value = state.swingPct; updateSwingUI();
  });
  document.getElementById('swingIncButton').addEventListener('click', ()=>{
    state.swingPct = Math.min(60, state.swingPct+1);
    swingSlider.value = state.swingPct; updateSwingUI();
  });

  const volumeSlider = document.getElementById('volumeSlider');
  const volumeValue = document.getElementById('volumeValue');
  volumeSlider.addEventListener('input', () => {
    const v = parseInt(volumeSlider.value, 10)/100;
    volumeValue.textContent = `${volumeSlider.value}%`;
    if (masterGain) masterGain.gain.value = v;
  });

  document.getElementById('applySettingsButton').addEventListener('click', ()=>{
    // explicit apply: update proxies
    updateTempoUI();
    updateSwingUI();
    applyStatusEl.textContent = 'done';
    setStatus('Controls applied', 'ok');
  });

  document.getElementById('clearPatternButton').addEventListener('click', () => {
    state.tracks.forEach(t => t.pattern.fill(false));
    refreshGridFromState();
    setStatus('Pattern cleared', 'ok');
    toggleGridFlash();
  });

  document.getElementById('randomizeButton').addEventListener('click', () => {
    state.tracks[0].pattern = Array.from({length:16}, (_,i)=> Math.random() < (i%4===0 ? 0.9 : 0.15));
    state.tracks[1].pattern = Array.from({length:16}, (_,i)=> (i%8===4) ? Math.random()<0.85 : Math.random()<0.15);
    state.tracks[2].pattern = Array.from({length:16}, ()=> Math.random()<0.6);
    state.tracks[3].pattern = Array.from({length:16}, (_,i)=> [3,6,11,14].includes(i) ? Math.random()<0.4 : Math.random()<0.1);
    refreshGridFromState();
    setStatus('Pattern randomized', 'ok');
    toggleGridFlash();
  });

  // Metronome toggle
  document.getElementById('metronomeButton').addEventListener('click', (e)=>{
    state.metronomeOn = !state.metronomeOn;
    e.currentTarget.setAttribute('aria-pressed', state.metronomeOn ? 'true' : 'false');
  });

  // Alternate tap tempo (same behavior)
  document.getElementById('tapTempoButton2').addEventListener('click', async (e)=>{
    await handleTapTempo(e.currentTarget);
  });

  // Tap tempo
  document.getElementById('tapTempoButton').addEventListener('click', async (e)=>{
    await handleTapTempo(e.currentTarget);
  });

  async function handleTapTempo(btn){
    ensureAudio();
    await audioCtx.resume();
    const now = performance.now();
    state.tapTimes.push(now);
    btn.setAttribute('aria-pressed','true');
    setTimeout(()=> btn.setAttribute('aria-pressed','false'), 120);
    if (state.tapTimes.length >= 4){
      const times = state.tapTimes.slice(-8); // last up to 8 taps
      const intervals = [];
      for (let i=1;i<times.length;i++) intervals.push(times[i]-times[i-1]);
      const avg = intervals.reduce((a,b)=>a+b,0)/intervals.length;
      const bpm = Math.max(40, Math.min(200, Math.round(60000/avg)));
      state.bpm = bpm;
      tempoSlider.value = bpm;
      updateTempoUI();
      setStatus(`Tempo set by tap: ${bpm} BPM`);
    }
  }

  // Pattern save/load with localStorage
  const STORAGE_KEY = 'audioStepSequencerPatterns';
  function getSavedMap(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return {};
      return JSON.parse(raw);
    } catch(e){
      console.warn('Failed to parse saved patterns', e);
      return {};
    }
  }
  function setSavedMap(map){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(map));
  }
  function refreshPatternList(){
    const select = document.getElementById('loadPatternSelect');
    const map = getSavedMap();
    const names = Object.keys(map).sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));
    select.innerHTML = '';
    const ph = document.createElement('option');
    ph.value=''; ph.textContent='Load pattern...';
    select.appendChild(ph);
    names.forEach(n=>{
      const opt = document.createElement('option');
      opt.value = n; opt.textContent = n;
      select.appendChild(opt);
    });
    // also update side list
    const cont = document.getElementById('patternListContainer');
    cont.innerHTML = '';
    names.forEach(n=>{
      const item = document.createElement('div');
      item.className = 'pattern-list-item';
      if (n === state.activePatternName) item.classList.add('active');
      item.innerHTML = `<span>${n}</span><button id="patternLoadButton-${encodeURIComponent(n)}">Load</button>`;
      cont.appendChild(item);
      document.getElementById(`patternLoadButton-${encodeURIComponent(n)}`).addEventListener('click', ()=>{
        const map2 = getSavedMap();
        applyPattern(map2[n]);
        setStatus(`Loaded "${n}"`, 'ok'); // keep_text_contains expects Loaded "
        state.activePatternName = n;
        updateActivePatternLabel();
        refreshPatternList(); // refresh which item is active
        toggleGridFlash();
        if (!state.seamlessLoad){
          if (state.isPlaying) stop();
        }
      });
    });
  }
  function serializeCurrent(){
    return {
      bpm: state.includeTempoSwing ? state.bpm : undefined,
      swingPct: state.includeTempoSwing ? state.swingPct : undefined,
      tracks: state.tracks.map(t => ({ name:t.name, pattern: t.pattern }))
    };
  }
  function applyPattern(obj){
    if (!obj) return;
    // Apply grid always
    if (Array.isArray(obj.tracks) && obj.tracks.length === state.tracks.length){
      obj.tracks.forEach((t, i)=> {
        if (Array.isArray(t.pattern) && t.pattern.length===16){
          state.tracks[i].pattern = t.pattern.slice(0,16).map(Boolean);
        }
      });
    }
    // Apply tempo/swing only if present in object (respect include option at save)
    if (typeof obj.bpm === 'number'){
      state.bpm = obj.bpm;
      tempoSlider.value = state.bpm;
      updateTempoUI();
    }
    if (typeof obj.swingPct === 'number'){
      state.swingPct = obj.swingPct;
      swingSlider.value = state.swingPct;
      updateSwingUI();
    }
    refreshGridFromState();
  }

  document.getElementById('savePatternButton').addEventListener('click', ()=>{
    const name = (document.getElementById('patternNameInput').value || '').trim();
    const feedback = document.getElementById('patternFeedback');
    if (!name){
      setStatus('Enter a pattern name to save', 'warn');
      feedback.textContent = 'Error: name is empty.';
      document.getElementById('patternNameInput').focus();
      return;
    }
    const map = getSavedMap();
    const data = serializeCurrent();
    if (map[name]){
      // Ask overwrite
      state.pendingOverwrite = { name, data };
      showOverwriteDialog();
      return;
    }
    map[name] = data;
    setSavedMap(map);
    refreshPatternList();
    setStatus(`Saved "${name}"`, 'ok');
    feedback.textContent = `Saved "${name}".`;
    state.activePatternName = name;
    updateActivePatternLabel();
  });

  document.getElementById('loadPatternSelect').addEventListener('change', (e)=>{
    const name = e.target.value;
    if (!name) return;
    const map = getSavedMap();
    applyPattern(map[name]);
    setStatus(`Loaded "${name}"`, 'ok');
    state.activePatternName = name;
    updateActivePatternLabel();
    refreshPatternList();
    toggleGridFlash();
    const seamless = document.getElementById('seamlessLoadCheckbox').checked;
    state.seamlessLoad = seamless;
    if (!seamless){
      if (state.isPlaying) stop();
    }
  });

  document.getElementById('deletePatternButton').addEventListener('click', ()=>{
    const sel = document.getElementById('loadPatternSelect');
    const name = sel.value;
    const feedback = document.getElementById('patternFeedback');
    if (!name){ setStatus('Select a pattern to delete', 'warn'); feedback.textContent='Select a pattern first.'; return; }
    const map = getSavedMap();
    delete map[name];
    setSavedMap(map);
    refreshPatternList();
    sel.value = '';
    setStatus(`Deleted "${name}"`, 'ok');
    feedback.textContent = `Deleted "${name}".`;
    if (state.activePatternName === name){
      state.activePatternName = 'none';
      updateActivePatternLabel();
    }
  });

  function updateActivePatternLabel(){
    const el = document.getElementById('activePatternLabel');
    el.textContent = state.activePatternName || 'none';
  }

  function showOverwriteDialog(){
    const dlg = document.getElementById('overwriteDialog');
    dlg.style.display = 'flex';
  }
  function hideOverwriteDialog(){
    const dlg = document.getElementById('overwriteDialog');
    dlg.style.display = 'none';
  }
  document.getElementById('overwriteConfirmButton').addEventListener('click', ()=>{
    const p = state.pendingOverwrite;
    if (!p){ hideOverwriteDialog(); return; }
    const map = getSavedMap();
    map[p.name] = p.data;
    setSavedMap(map);
    hideOverwriteDialog();
    refreshPatternList();
    setStatus(`Saved "${p.name}"`, 'ok');
    document.getElementById('patternFeedback').textContent = `Overwrote "${p.name}".`;
    state.activePatternName = p.name;
    updateActivePatternLabel();
    state.pendingOverwrite = null;
  });
  document.getElementById('overwriteCancelButton').addEventListener('click', ()=>{
    hideOverwriteDialog();
    document.getElementById('patternFeedback').textContent = 'Overwrite cancelled.';
    state.pendingOverwrite = null;
  });

  // Export WAV via OfflineAudioContext
  document.getElementById('exportWavButton').addEventListener('click', async ()=>{
    ensureAudio();
    await audioCtx.resume();
    const bars = parseInt(document.getElementById('barsSelect').value, 10) || 2;
    const bpm = state.bpm;
    const swing = state.swingPct;
    const pattern = state.tracks.map(t => t.pattern.slice());
    const durationSec = estimateDurationSeconds(bpm, swing, bars);
    exportDurationLabel.textContent = `duration: ${durationSec.toFixed(2)}s`;
    setStatus('Rendering WAV...', 'warn');
    downloadStatusEl.textContent = 'rendering';
    try{
      const wav = await renderPatternToWav(pattern, bpm, swing, bars);
      const url = URL.createObjectURL(wav);
      const link = document.getElementById('downloadLink');
      link.href = url;
      link.download = `sequencer_${bpm}bpm_${bars}bars.wav`;
      link.setAttribute('aria-disabled', 'false');
      downloadStatusEl.textContent = 'enabled';
      setStatus('WAV exported', 'ok');
    }catch(e){
      console.error(e);
      setStatus('WAV export failed', 'err');
      downloadStatusEl.textContent = 'error';
    }
  });

  function estimateDurationSeconds(bpm, swingPct, bars){
    const sp16 = secondsPer16th(bpm);
    const swing = swingOffsetSeconds(bpm, swingPct);
    // Average per bar duration considering swing (sum of 16 steps)
    let sum = 0;
    for (let s=0;s<16;s++){
      const isEven = (s%2)===0;
      sum += isEven ? (sp16 + swing) : (sp16 - swing);
    }
    return bars * sum + 1.0; // tail
  }

  function renderPatternToWav(pattern, bpm, swingPct, bars, sampleRate=44100){
    return new Promise(async (resolve, reject)=>{
      try{
        const sp16 = secondsPer16th(bpm);
        const swing = swingOffsetSeconds(bpm, swingPct);
        const barDurAverage = estimateDurationSeconds(bpm, swingPct, 1) - 1.0; // per bar
        const tail = 1.0;
        const totalDur = bars * barDurAverage + tail;
        const frames = Math.ceil(totalDur * sampleRate);
        const ctx = new OfflineAudioContext(2, frames, sampleRate);
        const dest = ctx.createGain();
        dest.gain.value = 0.9;
        dest.connect(ctx.destination);
        const nb = createNoiseBuffer(ctx);

        // Local triggers referencing offline ctx
        const trig = [
          (t)=> triggerKick(t, ctx, dest),
          (t)=> triggerSnare(t, ctx, dest),
          (t)=> triggerHat(t, ctx, dest),
          (t)=> triggerClap(t, ctx, dest)
        ];

        for (let bar=0; bar<bars; bar++){
          let sTime = bar * barDurAverage;
          for (let s=0; s<16; s++){
            for (let tr=0; tr<pattern.length; tr++){
              if (pattern[tr][s]){
                trig[tr](sTime);
              }
            }
            // next step time with swing
            const isEven = (s % 2) === 0;
            sTime += isEven ? (sp16 + swing) : (sp16 - swing);
          }
        }
        const buffer = await ctx.startRendering();
        const wavBlob = encodeWAV(buffer);
        resolve(wavBlob);
      }catch(e){ reject(e); }
    });
  }

  function encodeWAV(buffer){
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const numFrames = buffer.length;
    // Interleave
    let interleaved;
    if (numChannels === 2){
      const left = buffer.getChannelData(0);
      const right = buffer.getChannelData(1);
      interleaved = new Float32Array(numFrames * 2);
      let i=0, j=0;
      while (i < numFrames){
        interleaved[j++] = left[i];
        interleaved[j++] = right[i];
        i++;
      }
    } else {
      interleaved = buffer.getChannelData(0);
    }

    // Convert to 16-bit PCM
    const bytesPerSample = 2;
    const blockAlign = (numChannels) * bytesPerSample;
    const bufferLength = 44 + interleaved.length * bytesPerSample;
    const arrayBuffer = new ArrayBuffer(bufferLength);
    const view = new DataView(arrayBuffer);

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + interleaved.length * bytesPerSample, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // PCM chunk size
    view.setUint16(20, 1, true); // audio format PCM
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true); // bits per sample
    writeString(view, 36, 'data');
    view.setUint32(40, interleaved.length * bytesPerSample, true);
    // PCM samples
    let offset = 44;
    for (let i=0;i<interleaved.length;i++){
      let s = Math.max(-1, Math.min(1, interleaved[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      offset += 2;
    }
    return new Blob([view], {type:'audio/wav'});
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url; a.download=filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=> {
      URL.revokeObjectURL(url);
      a.remove();
    }, 50);
  }

  // Status
  function setStatus(msg, type='info'){
    const el = document.getElementById('statusText');
    el.textContent = msg;
    // No color changes required in destylized spec; keep text only
  }

  // Silence indicator
  function updateSilenceIndicator(){
    const allOff = state.tracks.every(t => t.pattern.every(p => !p));
    silenceIndicator.textContent = allOff ? 'pattern is silent' : 'pattern not silent';
  }

  // Grid flash feedback
  function toggleGridFlash(){
    const panel = document.getElementById('gridPanel');
    panel.classList.add('grid-flash');
    setTimeout(()=> panel.classList.remove('grid-flash'), 200);
  }

  // Navigation proxies
  document.getElementById('navGridLink').addEventListener('click', ()=>{
    document.getElementById('gridPanel').scrollIntoView({behavior:'smooth', block:'start'});
    document.getElementById('activeSection').textContent = 'Grid';
  });
  document.getElementById('navPatternsLink').addEventListener('click', ()=>{
    document.getElementById('sidePanel').scrollIntoView({behavior:'smooth', block:'start'});
    document.getElementById('activeSection').textContent = 'Patterns';
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', async (e)=>{
    if (e.key === ' '){
      e.preventDefault();
      ensureAudio();
      await audioCtx.resume();
      if (!state.isPlaying) start(); else stop();
    }
    if (e.key.toLowerCase() === 'e'){
      e.preventDefault();
      document.getElementById('exportWavButton').click();
    }
  });

  // Bars select updates duration estimate
  document.getElementById('barsSelect').addEventListener('change', ()=>{
    const bars = parseInt(document.getElementById('barsSelect').value, 10) || 2;
    const durationSec = estimateDurationSeconds(state.bpm, state.swingPct, bars);
    exportDurationLabel.textContent = `duration: ${durationSec.toFixed(2)}s`;
  });

  // Include tempo/swing option
  document.getElementById('includeTempoSwingCheckbox').addEventListener('change', (e)=>{
    state.includeTempoSwing = e.target.checked;
    document.getElementById('patternFeedback').textContent = state.includeTempoSwing ?
      'Saving and loading includes tempo & swing.' :
      'Saving grid only (tempo & swing will not be changed on load).';
  });
  document.getElementById('seamlessLoadCheckbox').addEventListener('change', (e)=>{
    state.seamlessLoad = e.target.checked;
  });

  // Initialize
  setDefaultPattern();
  buildGrid();
  refreshPatternList();
  updateTempoUI();
  updateSwingUI();
  tempoSlider.dispatchEvent(new Event('input'));
  swingSlider.dispatchEvent(new Event('input'));
  document.getElementById('barsSelect').dispatchEvent(new Event('change'));

  // Ensure controls fit 1280x720: compact layout done; no auto-play; neutral initial state.

})();
</script>
</body>
</html>
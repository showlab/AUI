<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fun Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Fun Game - Jump over obstacles to survive as long as possible. Simple, high-contrast layout with clear controls, persistent score and high score, accessible keyboard and touch input.">
  <style>
    /* Destylized high-contrast baseline */
    :root{
      --bg:#ffffff;
      --text:#000000;
      --muted:#666666;
      --accent:#000000;
      --ok:#006400;
      --warn:#b22222;
      --panel:#ffffff;
      --line:#000000;
      --focus:#000000;
      --btn:#000000;
      --btn-bg:#ffffff;
      --btn-muted:#cccccc;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }
    a{ color:var(--text); }
    a:focus, button:focus{ outline: 2px solid var(--focus); outline-offset: 2px; }
    header{
      position:fixed;
      top:0; left:0; right:0;
      background:var(--bg);
      border-bottom:1px solid var(--line);
      z-index:5;
    }
    .topbar{
      max-width: 1280px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:8px 10px;
    }
    .brand{
      display:flex; align-items:center; gap:8px;
      font-weight:900; letter-spacing:0.5px; font-size:18px;
      color:var(--text);
    }
    .brand .logo{
      width:24px; height:24px;
      background:var(--bg);
      border:1px solid var(--line);
    }
    .hud{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
    }
    .badge{
      background:var(--panel);
      padding:6px 8px;
      border:1px solid var(--line);
      font-weight:700; color:var(--text);
      min-width: 110px;
      text-align:center;
    }
    .badge strong{ font-weight:900; }
    .controls{
      display:flex; align-items:center; gap:8px;
    }
    button{
      appearance:none; border:1px solid var(--line); cursor:pointer;
      padding:10px 14px; min-width: 44px; min-height: 44px;
      font-weight:800; color:var(--btn); background:var(--btn-bg);
    }
    button[disabled]{ cursor:not-allowed; color:var(--muted); border-color:var(--btn-muted); }
    button.alt{ }
    button.ghost{ }
    main{
      height:100%;
      width:100%;
      display:grid;
      grid-template-rows: auto 1fr;
      place-items:center;
      padding-top:50px; /* space for header */
    }
    .game-wrap{
      position:relative;
      width:min(96vw, 1280px);
      aspect-ratio:16/9;
      max-height: calc(100vh - 78px);
      overflow:hidden;
      background: var(--bg);
      border:1px solid var(--line);
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action: manipulation;
      will-change: transform;
    }
    .overlay{
      position:absolute; inset:0; display:flex;
      align-items:center; justify-content:center;
      z-index:3; pointer-events:auto;
    }
    .panel{
      background:var(--panel);
      padding:16px;
      border:1px solid var(--line);
      text-align:left;
      max-width:min(90%, 720px);
      display:flex; flex-direction:column; gap:10px;
    }
    .panel h1{ margin:0; font-size:20px; font-weight:900; }
    .panel p{ margin:0; line-height:1.4; }
    .panel .hint{ font-size:14px; color:var(--muted); }
    .hidden{ display:none !important; }
    .floating-btn{
      position:absolute;
      right:16px; bottom:32px;
      z-index:2;
      min-width:120px; min-height:60px;
      display:grid; place-items:center;
      background:var(--panel);
      color:var(--text);
      font-weight:900;
      border:1px solid var(--line);
      user-select:none;
      touch-action: manipulation;
    }
    .floating-btn span{ }
    .legend{
      position:absolute;
      left:16px; bottom:16px;
      z-index:2;
      background:var(--panel);
      padding:8px 10px;
      border:1px solid var(--line);
      font-size:14px;
    }
    .sr{
      position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden;
    }
    footer{
      position:fixed; bottom:4px; left:0; right:0; width:100%; display:flex; justify-content:center;
      font-size:12px; color:var(--muted);
      pointer-events:none;
    }

    /* In-canvas HUD for score and high score (top-left corner, always visible) */
    .hud-overlay{
      position:absolute; left:8px; top:8px; z-index:2;
      background:var(--panel);
      border:1px solid var(--line);
      display:flex; gap:8px; padding:6px 8px; align-items:center;
      font-size:14px;
    }
    #score, #high-score{
      font-weight:900;
    }
    #high-score[data-new-high="true"]{
      color:var(--ok);
    }

    /* Compact control dock inside game area (top-right) */
    .controls-dock{
      position:absolute; right:8px; top:8px; z-index:2;
      display:flex; gap:8px; align-items:center;
      background:var(--panel);
      border:1px solid var(--line);
      padding:6px 8px;
    }
    .controls-dock button{
      min-width:44px; min-height:44px;
    }

    /* Status console (non-obtrusive, bottom-left corner) */
    .status-console{
      position:absolute; left:8px; bottom:8px; z-index:2;
      display:flex; flex-direction:column; gap:4px;
      background:var(--panel);
      border:1px solid var(--line);
      padding:6px 8px;
      max-width: 60%;
      max-height: 35%;
      overflow:auto;
    }
    .status-grid{
      display:grid; grid-template-columns: 180px 1fr; gap:2px 8px; align-items:center;
    }
    .status-label{ color:var(--muted); }
    .status-value{ font-weight:700; }

    /* Help drawer (collapsed by default) */
    details#helpDrawer{
      position:relative;
      margin: 8px auto;
      max-width: 1280px;
      padding: 8px 10px;
      border-top:1px solid var(--line);
      border-bottom:1px solid var(--line);
    }
    details#helpDrawer > summary{
      font-weight:900;
      cursor:pointer;
      padding:8px 0;
    }
    details#helpDrawer[open]{
      overflow:auto;
      max-height: 32vh;
    }
    #jumpHint{
      position:absolute; right:8px; bottom:96px;
      z-index:2;
      background:var(--panel);
      border:1px solid var(--line);
      padding:6px 8px;
      font-size:14px;
    }

    /* Keyboard focus visibility */
    :focus-visible{
      outline: 2px solid var(--focus);
      outline-offset:2px;
    }

    @media (max-width: 640px){
      .badge{ min-width: auto; }
      .topbar{ gap:8px; }
      .panel h1{ font-size:18px; }
      .controls-dock{ top:auto; bottom:8px; }
      .legend{ font-size:12px; }
      .floating-btn{ right:8px; bottom:8px; min-width:100px; min-height:52px; }
      .hud-overlay{ left:8px; top:8px; font-size:12px; }
    }
  </style>
</head>
<body>
  <a class="sr" href="#gameCanvas">Skip to game</a>
  <header>
    <div class="topbar" role="banner">
      <div class="brand" aria-label="Game title">
        <div class="logo" aria-hidden="true"></div>
        Fun Game
      </div>
      <div class="hud" role="status" aria-live="polite">
        <div class="badge">Score: <strong id="scoreValue">0</strong></div>
        <div class="badge">High: <strong id="highScoreValue">0</strong></div>
        <div class="controls">
          <button id="startButton" class="alt" title="Start the game" aria-disabled="false">Start</button>
          <button id="muteButton" class="ghost" title="Toggle sound" aria-pressed="true">Sound On</button>
        </div>
      </div>
    </div>
  </header>

  <main role="main">
    <section class="game-wrap" id="gameContainer" aria-label="Game area" data-running="false" data-new-high="false">
      <!-- In-canvas HUD for score and high score -->
      <div class="hud-overlay" id="hudOverlay">
        <div>Score: <span id="score">0</span></div>
        <div>High: <span id="high-score" data-new-high="false">0</span></div>
      </div>

      <!-- Compact control dock inside canvas (keeps critical controls in view) -->
      <div class="controls-dock" id="controlsDock" aria-label="Inline controls">
        <button id="startButtonDock" title="Start game (same as Start)" aria-disabled="false">Start</button>
        <button id="muteButtonDock" title="Toggle sound (same as Sound)">Sound On</button>
        <button id="jumpButtonDock" title="Jump (same as Jump)" aria-disabled="true">Jump</button>
      </div>

      <canvas id="gameCanvas" width="1280" height="720" role="img" aria-label="Endless runner with cartoon character jumping over obstacles" data-ready="false"></canvas>

      <div class="overlay" id="startOverlay" aria-hidden="false">
        <div class="panel" role="dialog" aria-modal="true" aria-labelledby="startTitle">
          <h1 id="startTitle">Welcome to Fun Game</h1>
          <p>Goal: jump over obstacles to survive as long as possible.</p>
          <p class="hint">Keyboard: Space / Up Arrow / W to jump. Press Enter to start. Touch: use the Jump button.</p>
          <p class="hint">Controls are always visible above and inside the game area.</p>
          <div style="display:flex; gap:10px; align-items:center; margin-top:6px;">
            <button id="startButtonOverlay" class="alt" aria-disabled="false">Start</button>
            <button id="muteButtonOverlay" class="ghost" aria-pressed="true">Sound On</button>
          </div>
        </div>
      </div>

      <div class="overlay hidden" id="gameOverOverlay" aria-hidden="true">
        <div class="panel" role="dialog" aria-modal="true" aria-labelledby="gameOverTitle">
          <h1 id="gameOverTitle">Game Over</h1>
          <p>Final Score: <strong id="finalScore">0</strong></p>
          <p>High Score: <strong id="finalHighScore">0</strong></p>
          <p class="hint">Tip: press Retry or Start to play again. Space/Up/W to jump.</p>
          <div style="display:flex; gap:10px; align-items:center; margin-top:6px;">
            <button id="retryButton" class="alt" aria-disabled="false">Retry</button>
            <button id="shareButton" class="ghost" title="Copy score to clipboard">Share</button>
          </div>
        </div>
      </div>

      <button id="jumpButton" class="floating-btn" aria-label="Jump" aria-disabled="true"><span>Jump</span></button>
      <div class="legend">Hold jump slightly for higher leap. Speed increases over time.</div>

      <!-- Jump feedback near jump button -->
      <div id="jumpHint" class="hidden" aria-live="polite">Jump registered</div>

      <!-- Status console (MANDATORY DOM COMPLETION PROXIES) -->
      <div class="status-console" id="statusConsole" aria-live="polite">
        <div class="status-grid">
          <div class="status-label">Game Status:</div><div class="status-value" id="gameStatus">stopped</div>
          <div class="status-label">Start Button:</div><div class="status-value" id="startStatus">idle</div>
          <div class="status-label">Sound:</div><div class="status-value" id="soundStatus">on</div>
          <div class="status-label">Overlay:</div><div class="status-value" id="overlayStatus">start</div>
          <div class="status-label">Active Section:</div><div class="status-value" id="activeSection">start</div>
          <div class="status-label">Preview:</div><div class="status-value" id="previewStatus">idle</div>
          <div class="status-label">Score Status:</div><div class="status-value" id="scoreStatus">idle</div>
          <div class="status-label">High Score Status:</div><div class="status-value" id="highScoreStatus">idle</div>
          <div class="status-label">Jump Button:</div><div class="status-value" id="jumpBtnStatus">disabled</div>
          <div class="status-label">Game Over:</div><div class="status-value" id="gameOverStatus">hidden</div>
          <div class="status-label">Last Event:</div><div class="status-value" id="lastEvent">none</div>
        </div>
        <div id="eventLog" style="margin-top:6px; border-top:1px solid var(--line); padding-top:6px;">
          Events:
          <div id="eventItems" aria-live="polite"></div>
        </div>
      </div>
    </section>

    <!-- Non-obtrusive help drawer -->
    <details id="helpDrawer">
      <summary>Help, Keyboard Shortcuts, and Testable Proxies</summary>
      <div id="helpContent">
        - Start the game using any Start button or press Enter when the game is not running.
        - Jump using Space, Up Arrow, W, or any Jump button. Keep pressed for a slightly higher jump.
        - Score and High Score are visible at the top bar and inside the game area. They remain visible during overlays.
        - Sound can be toggled with any Sound button or keyboard M. The sound status updates immediately.
        - Game Over overlay appears immediately upon collision, showing final score and high score. Retry starts a new round.
        - Resize the window: the canvas scales, collision bounds recalculate, controls remain visible.
        - Status proxies update synchronously:
          * #gameStatus: "running" or "stopped"
          * #startStatus: "idle" / "starting" / "running"
          * #soundStatus: "on" / "off"
          * #overlayStatus: "start" / "gameplay" / "gameover" / "hidden"
          * #activeSection: "start" / "gameplay" / "gameover"
          * #previewStatus: "ready" when the canvas is drawn (canvas[data-ready='true'])
          * #scoreStatus: "live" while updating; "final" at game over
          * #highScoreStatus: "new-high" when a personal best is reached
          * #jumpBtnStatus: "enabled" / "disabled"
          * #gameOverStatus: "shown" / "hidden"
        - Attribute signals:
          * #gameContainer[data-running='true'] is set during gameplay
          * #gameCanvas[data-ready='true'] is set after render
          * #high-score[data-new-high='true'] is set when a new high score occurs
          * #startButton[aria-disabled='true'] and #retryButton[aria-disabled='true'] reflect disabled states
          * #jumpButton[aria-disabled='true'] reflects availability
        - This app maintains a neutral initial state. No gameplay auto-start occurs on load.
        - Controls are sized to at least 44×44 px and remain within a 1280×720 viewport.
        - For automation: every primary element has a unique id and updates its proxy immediately.
      </div>
    </details>
  </main>

  <footer>
    Made with HTML5 Canvas and simple JavaScript. High-contrast UI with clear controls and status proxies.
  </footer>

  <script>
  (function(){
    'use strict';

    // DOM references
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('scoreValue');
    const highScoreEl = document.getElementById('highScoreValue');
    const startBtn = document.getElementById('startButton');
    const muteBtn = document.getElementById('muteButton');
    const jumpBtn = document.getElementById('jumpButton');

    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const retryBtn = document.getElementById('retryButton');
    const shareBtn = document.getElementById('shareButton');
    const finalScoreEl = document.getElementById('finalScore');
    const finalHighScoreEl = document.getElementById('finalHighScore');
    const startBtnOverlay = document.getElementById('startButtonOverlay');
    const muteBtnOverlay = document.getElementById('muteButtonOverlay');
    const container = document.getElementById('gameContainer');

    // Inline controls inside canvas area
    const startBtnDock = document.getElementById('startButtonDock');
    const muteBtnDock = document.getElementById('muteButtonDock');
    const jumpBtnDock = document.getElementById('jumpButtonDock');

    // HUD overlay inside canvas
    const scoreHUD = document.getElementById('score');
    const highHUD = document.getElementById('high-score');

    // Status proxies (MANDATORY DOM COMPLETION PROXIES)
    const gameStatusEl = document.getElementById('gameStatus');
    const startStatusEl = document.getElementById('startStatus');
    const soundStatusEl = document.getElementById('soundStatus');
    const overlayStatusEl = document.getElementById('overlayStatus');
    const activeSectionEl = document.getElementById('activeSection');
    const previewStatusEl = document.getElementById('previewStatus');
    const scoreStatusEl = document.getElementById('scoreStatus');
    const highScoreStatusEl = document.getElementById('highScoreStatus');
    const jumpBtnStatusEl = document.getElementById('jumpBtnStatus');
    const gameOverStatusEl = document.getElementById('gameOverStatus');
    const lastEventEl = document.getElementById('lastEvent');
    const eventItemsEl = document.getElementById('eventItems');
    const jumpHintEl = document.getElementById('jumpHint');

    // DPI scaling for crisp canvas
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // clamp for performance
    function resizeCanvas(){
      const rect = container.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing to CSS pixels
      // Update unit scaling relative to base 720 height
      U = height / 720;
      logEvent('resize', `canvas ${width}x${height}, DPR ${DPR.toFixed(2)}, U ${U.toFixed(3)}`);
      // Recalculate ground placement dependent UI (hint position doesn't need recalculation due to CSS, but physics uses groundY())
    }
    let U = 1; // unit scaling based on height
    window.addEventListener('resize', resizeCanvas);

    // Game state
    const state = {
      running: false,
      gameOver: false,
      score: 0,
      highScore: Number(localStorage.getItem('funGameHighScore') || 0),
      speed: 8,          // base horizontal speed in px per frame at 60fps (scaled with dt)
      maxSpeed: 30,
      accel: 0.004,      // per ms
      spawnTimer: 0,
      nextSpawn: 1400,   // ms
      time: 0,
      initializing: false // prevents duplicate start clicks
    };

    // Background layers
    let clouds = [];
    let hills = [];
    let groundDeco = [];

    // Player
    const player = {
      x: 110,
      y: 0,
      w: 58, h: 64,
      vy: 0,
      onGround: false,
      jumpHold: 0,
      maxJumpHold: 180, // ms for variable jump height
      jumping: false,
      runTime: 0,
      color: '#2dd4bf',
      _squash: 0
    };

    // Obstacles
    let obstacles = [];

    // Floor
    function groundY(){
      return canvas.clientHeight * 0.80; // use CSS pixel coordinates
    }

    // Input
    let keys = { Space:false, ArrowUp:false, KeyW:false };
    window.addEventListener('keydown', (e)=>{
      if (['Space','ArrowUp','KeyW'].includes(e.code)){
        e.preventDefault();
        keys[e.code] = true;
        tryJump();
      }else if(e.code === 'KeyM'){
        e.preventDefault();
        toggleMute();
      }else if(e.code === 'Enter' && !state.running){
        startGame();
      }
    }, {passive:false});
    window.addEventListener('keyup', (e)=>{
      if (['Space','ArrowUp','KeyW'].includes(e.code)){
        keys[e.code] = false;
        player.jumping = false;
        player.jumpHold = 0;
        setJumpFeedback(false, 'released');
      }
    });

    // Pointer on main jump
    jumpBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); tryJump(true); });
    jumpBtn.addEventListener('pointerup', (e)=>{ e.preventDefault(); player.jumping = false; player.jumpHold = 0; setJumpFeedback(false, 'released'); });
    jumpBtn.addEventListener('pointercancel', ()=>{ player.jumping = false; player.jumpHold = 0; setJumpFeedback(false, 'cancel'); });

    // Pointer on dock jump
    jumpBtnDock.addEventListener('pointerdown', (e)=>{ e.preventDefault(); tryJump(true); });
    jumpBtnDock.addEventListener('pointerup', (e)=>{ e.preventDefault(); player.jumping = false; player.jumpHold = 0; setJumpFeedback(false, 'released'); });
    jumpBtnDock.addEventListener('pointercancel', ()=>{ player.jumping = false; player.jumpHold = 0; setJumpFeedback(false, 'cancel'); });

    // Status helpers
    function setGameStatus(text){
      gameStatusEl.textContent = text;
      container.setAttribute('data-running', String(text === 'running'));
    }
    function setStartStatus(text){
      startStatusEl.textContent = text;
      startBtn.setAttribute('aria-disabled', String(text !== 'idle'));
      startBtnDock.setAttribute('aria-disabled', String(text !== 'idle'));
      startBtnOverlay.setAttribute('aria-disabled', String(text !== 'idle'));
      // Disabled property to match aria (prevent double start)
      startBtn.disabled = text !== 'idle';
      startBtnDock.disabled = text !== 'idle';
      startBtnOverlay.disabled = text !== 'idle';
    }
    function setOverlayStatus(text){
      overlayStatusEl.textContent = text;
      activeSectionEl.textContent = text === 'hidden' ? 'gameplay' : (text === 'start' ? 'start' : text === 'gameover' ? 'gameover' : 'gameplay');
      // also update gameOverStatus
      gameOverStatusEl.textContent = text === 'gameover' ? 'shown' : 'hidden';
    }
    function setSoundStatus(on){
      soundStatusEl.textContent = on ? 'on' : 'off';
    }
    function setPreviewReady(){
      canvas.setAttribute('data-ready','true');
      previewStatusEl.textContent = 'ready';
    }
    function setScoreStatus(text){
      scoreStatusEl.textContent = text;
    }
    function setHighScoreStatus(text){
      highScoreStatusEl.textContent = text;
    }
    function setJumpEnabled(enabled){
      const val = enabled ? 'enabled' : 'disabled';
      jumpBtnStatusEl.textContent = val;
      jumpBtn.setAttribute('aria-disabled', String(!enabled));
      jumpBtn.disabled = !enabled;
      jumpBtnDock.setAttribute('aria-disabled', String(!enabled));
      jumpBtnDock.disabled = !enabled;
    }
    function setJumpFeedback(show, type){
      if (show){
        jumpHintEl.textContent = type === 'ignored' ? 'Jump ignored' : 'Jump';
        jumpHintEl.classList.remove('hidden');
      }else{
        jumpHintEl.classList.add('hidden');
      }
    }
    function logEvent(type, message){
      lastEventEl.textContent = `${type}: ${message}`;
      const row = document.createElement('div');
      row.textContent = `${Date.now()} — ${type}: ${message}`;
      eventItemsEl.prepend(row);
      // cap logs
      if (eventItemsEl.children.length > 64){
        eventItemsEl.removeChild(eventItemsEl.lastChild);
      }
    }

    // Buttons
    function showStart(){
      startOverlay.classList.remove('hidden');
      startOverlay.setAttribute('aria-hidden','false');
      gameOverOverlay.classList.add('hidden');
      gameOverOverlay.setAttribute('aria-hidden','true');
      state.running = false;
      state.gameOver = false;
      setOverlayStatus('start');
      setGameStatus('stopped');
      setStartStatus('idle');
      setJumpEnabled(false);
      logEvent('overlay', 'start shown');
    }
    function showGameOver(){
      gameOverOverlay.classList.remove('hidden');
      gameOverOverlay.setAttribute('aria-hidden','false');
      startOverlay.classList.add('hidden');
      startOverlay.setAttribute('aria-hidden','true');
      setOverlayStatus('gameover');
      setGameStatus('stopped');
      setStartStatus('idle'); // allow starting again
      setJumpEnabled(false);
      logEvent('overlay', 'game over shown');
    }
    function hideOverlays(){
      startOverlay.classList.add('hidden');
      startOverlay.setAttribute('aria-hidden','true');
      gameOverOverlay.classList.add('hidden');
      gameOverOverlay.setAttribute('aria-hidden','true');
      setOverlayStatus('hidden');
      activeSectionEl.textContent = 'gameplay';
      logEvent('overlay', 'overlays hidden');
    }

    // Attach actions to buttons (multiple sources)
    startBtn.addEventListener('click', startGame);
    startBtnOverlay.addEventListener('click', startGame);
    startBtnDock.addEventListener('click', startGame);

    retryBtn.addEventListener('click', startGame); // uses same start handler safely
    shareBtn.addEventListener('click', async()=>{
      const text = `I scored ${Math.floor(state.score)} in Fun Game! Can you beat me?`;
      try{
        await navigator.clipboard.writeText(text);
        shareBtn.textContent = 'Copied';
        logEvent('share', 'score copied to clipboard');
        setTimeout(()=> shareBtn.textContent = 'Share', 800);
      }catch{
        alert(text);
        logEvent('share', 'fallback alert used');
      }
    });

    // Sound
    let audioCtx = null;
    let muted = false;

    function ensureAudio(){
      if (!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended'){
        audioCtx.resume();
      }
    }
    function toggleMute(){
      ensureAudio();
      muted = !muted;
      updateMuteButtons();
      setSoundStatus(!muted);
      logEvent('sound', muted ? 'muted' : 'unmuted');
    }
    function updateMuteButtons(){
      const label = muted ? 'Sound Off' : 'Sound On';
      muteBtn.textContent = label;
      muteBtnOverlay.textContent = label;
      muteBtnDock.textContent = label;
      muteBtn.setAttribute('aria-pressed', String(!muted));
      muteBtnOverlay.setAttribute('aria-pressed', String(!muted));
    }
    muteBtn.addEventListener('click', ()=>{ toggleMute(); });
    muteBtnOverlay.addEventListener('click', ()=>{ toggleMute(); });
    muteBtnDock.addEventListener('click', ()=>{ toggleMute(); });

    function beep({type='sine', freq=440, duration=0.15, gain=0.12, attack=0.005, release=0.1, sweep=0}){
      if (!audioCtx || muted) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      if (sweep !== 0){
        osc.frequency.setValueAtTime(freq, now);
        osc.frequency.exponentialRampToValueAtTime(Math.max(50, freq * sweep), now + duration);
      }
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(gain, now + attack);
      g.gain.linearRampToValueAtTime(0.0001, now + Math.max(duration - release, attack));
      g.connect(audioCtx.destination);
      osc.connect(g);
      osc.start(now);
      osc.stop(now + duration + 0.02);
    }
    function soundJump(){
      beep({type:'sine', freq:320, duration:0.18, gain:0.15, sweep:1.8, attack:0.005, release:0.12});
      setTimeout(()=>beep({type:'triangle', freq:520, duration:0.08, gain:0.08, sweep:1.2}), 50);
    }
    function soundCrash(){
      beep({type:'sawtooth', freq:220, duration:0.35, gain:0.2, sweep:0.5, attack:0.005, release:0.2});
      setTimeout(()=>beep({type:'square', freq:120, duration:0.25, gain:0.15, sweep:0.6}), 60);
    }
    function soundPoint(){
      beep({type:'triangle', freq:880, duration:0.1, gain:0.12});
      setTimeout(()=>beep({type:'triangle', freq:1320, duration:0.08, gain:0.1}), 80);
    }
    function soundStart(){
      beep({type:'square', freq:440, duration:0.08, gain:0.1});
      setTimeout(()=>beep({type:'square', freq:660, duration:0.08, gain:0.1}), 90);
      setTimeout(()=>beep({type:'square', freq:880, duration:0.1, gain:0.12}), 180);
    }

    // Start/reset game
    function initWorld(){
      state.score = 0;
      state.speed = 10;
      state.accel = 0.0009; // accelerate gently
      state.spawnTimer = 0;
      state.nextSpawn = 900;
      state.time = 0;
      obstacles = [];
      clouds = [];
      hills = [];
      groundDeco = [];

      // Player position
      player.w = 58 * U;
      player.h = 64 * U;
      player.x = 110 * U;
      player.y = groundY() - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumpHold = 0;
      player.jumping = false;
      player.runTime = 0;
      player._squash = 0;

      // Create background elements
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      // Clouds
      for (let i=0; i<8; i++){
        clouds.push({
          x: Math.random()*W,
          y: 60 + Math.random()*H*0.35,
          s: 0.3 + Math.random()*0.7, // scale
          v: 0.15 + Math.random()*0.25 // speed factor
        });
      }
      // Hills
      for (let i=0; i<6; i++){
        hills.push({
          x: Math.random()*W,
          y: H*0.72 + Math.random()*40*U,
          r: 80*U + Math.random()*180*U,
          v: 0.35 + Math.random()*0.35,
          hue: 130 + Math.random()*40
        });
      }
      // Ground decor (grass tufts)
      for (let i=0; i<14; i++){
        groundDeco.push({
          x: Math.random()*W, y: groundY()-6*U,
          v: 1,
          c: Math.random()<0.5 ? '#17c964' : '#10b981',
          s: 0.6 + Math.random()*1.2
        });
      }
      logEvent('world', 'initialized');
    }

    function startGame(){
      // Prevent duplicate starts
      if (state.running || state.initializing){
        logEvent('start', 'ignored (already running/initializing)');
        return;
      }
      ensureAudio();
      soundStart();
      state.initializing = true;
      hideOverlays();
      setOverlayStatus('hidden');
      setStartStatus('starting');
      setGameStatus('stopped');
      setJumpEnabled(false);

      initWorld();

      state.running = true;
      state.gameOver = false;
      state.initializing = false;

      setStartStatus('running');
      setGameStatus('running');
      setJumpEnabled(true);

      lastTime = performance.now();
      nextPointMilestone = 100;
      logEvent('start', 'gameplay started');
      loop(lastTime);
    }

    // Jump logic with variable jump height
    function tryJump(fromPointer=false){
      if (!state.running){
        setJumpFeedback(true, 'ignored');
        logEvent('jump', 'ignored (not running)');
        return;
      }
      ensureAudio();

      const canJump = player.onGround; // single jump
      if (canJump){
        player.vy = - (15 * U); // base jump impulse
        player.onGround = false;
        player.jumping = true;
        player.jumpHold = 0;
        soundJump();
        setJumpFeedback(true, 'registered');
        logEvent('jump', 'registered');
        player._squash = 1;
      }else{
        setJumpFeedback(true, 'ignored');
        logEvent('jump', 'ignored (airborne)');
      }
    }

    // Spawn obstacles
    function spawnObstacle(){
      const H = canvas.clientHeight;
      const height = (30 + Math.random()*40) * U; // obstacle height
      const width = (24 + Math.random()*20) * U;
      const type = Math.random() < 0.5 ? 'box' : 'cactus';
      const color = type === 'box' ? '#000000' : '#000000';
      const face = Math.random()<0.7;

      obstacles.push({
        x: canvas.clientWidth + Math.random()*80,
        y: H*0.80 - height,
        w: width,
        h: height,
        type, color, face
      });
    }

    // Drawing helpers
    function drawSky(){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      // Destylized sky: simple white background handled by CSS; draw a minimal sun to provide contrast
      const sunX = W*0.85, sunY = H*0.18, sunR = 24*U;
      ctx.save();
      ctx.fillStyle = '#00000011';
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR*2.2, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#00000022';
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    function drawCloud(x,y,s){
      ctx.save();
      ctx.translate(x,y);
      ctx.scale(s,s);
      ctx.fillStyle = '#00000018';
      ctx.beginPath();
      ctx.arc(0, 0, 26, 0, Math.PI*2);
      ctx.arc(24, -6, 22, 0, Math.PI*2);
      ctx.arc(-24, -6, 18, 0, Math.PI*2);
      ctx.arc(10, 10, 18, 0, Math.PI*2);
      ctx.arc(-12, 10, 20, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    function drawHill(x,y,r,hue){
      ctx.save();
      ctx.fillStyle = '#00000015';
      ctx.beginPath();
      ctx.arc(x, y, r, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    function drawGround(){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      const gy = groundY();
      // ground base
      ctx.fillStyle = '#00000007';
      ctx.fillRect(0, gy, W, H-gy);
      // ground line
      ctx.fillStyle = '#000000cc';
      ctx.fillRect(0, gy-2*U, W, 2*U);
    }
    function drawGrassTuft(x,y,s,color){
      ctx.save();
      ctx.translate(x,y);
      ctx.scale(s,s);
      ctx.fillStyle = '#00000066';
      for(let i=0;i<5;i++){
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.quadraticCurveTo(-3+i*1.5, -10 - i*2, -1+i, -16 - i*1.4);
        ctx.quadraticCurveTo(2+i*0.5, -6 - i, 1.5+i, 0);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawPlayer(){
      const bob = Math.sin(player.runTime*10) * 1.5 * U;
      const x = player.x;
      const y = player.y + bob;
      const w = player.w;
      const h = player.h;

      ctx.save();
      ctx.translate(x,y);
      const bodyColor = '#000000';
      ctx.fillStyle = bodyColor;
      roundRect(-w*0.5, 0, w, h, 0); // destylized: no rounding
      ctx.fill();

      // belly (lighter rectangle)
      ctx.fillStyle = '#00000022';
      roundRect(-w*0.35, h*0.15, w*0.7, h*0.55, 0);
      ctx.fill();

      // eyes
      ctx.fillStyle = '#000000';
      const eyeY = h*0.22;
      ctx.beginPath();
      ctx.arc(-w*0.14, eyeY, 5*U, 0, Math.PI*2);
      ctx.arc(w*0.14, eyeY, 5*U, 0, Math.PI*2);
      ctx.fill();

      // mouth (simple line)
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2*U;
      ctx.beginPath();
      ctx.moveTo(-10*U, h*0.38);
      ctx.lineTo(10*U, h*0.38);
      ctx.stroke();

      // legs animation (swinging)
      const swing = Math.sin(player.runTime*20)*6*U;
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 6*U;
      ctx.lineCap = 'butt';
      // left leg
      ctx.beginPath();
      ctx.moveTo(-w*0.18, h*0.9);
      ctx.lineTo(-w*0.18 + swing*0.3, h + 10*U);
      ctx.stroke();
      // right leg
      ctx.beginPath();
      ctx.moveTo(w*0.18, h*0.9);
      ctx.lineTo(w*0.18 - swing*0.3, h + 10*U);
      ctx.stroke();

      ctx.restore();
    }

    function roundRect(x,y,w,h,r){
      // destylized: simple rect path without rounded corners
      ctx.beginPath();
      ctx.rect(x,y,w,h);
      ctx.closePath();
    }

    function drawObstacle(o){
      ctx.save();
      ctx.translate(o.x, o.y);
      // base box
      ctx.fillStyle = o.color;
      roundRect(0, 0, o.w, o.h, 0);
      ctx.fill();
      // simple face (if any)
      if (o.face){
        ctx.fillStyle = '#000000';
        const cx = o.w*0.5;
        const cy = o.h*0.35;
        ctx.beginPath(); ctx.arc(cx - o.w*0.18, cy, 3.2*U, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + o.w*0.18, cy, 3.2*U, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#000000'; ctx.lineWidth = 2*U;
        ctx.beginPath();
        ctx.moveTo(cx - 7*U, cy + 6*U);
        ctx.lineTo(cx + 7*U, cy + 6*U);
        ctx.stroke();
      }
      // cactus arms as rectangles
      if (o.type === 'cactus'){
        ctx.fillStyle = '#000000';
        roundRect(o.w*0.1, o.h*0.2, o.w*0.2, o.h*0.4, 0);
        ctx.fillRect(o.w*0.7, o.h*0.3, o.w*0.2, o.h*0.35);
      }
      ctx.restore();
    }

    // Collision detection (AABB with padding)
    function isColliding(){
      const shrink = 0.75; // forgiving factor
      const px = player.x - (player.w*0.5)*shrink;
      const py = player.y + player.h*(1-shrink);
      const pw = player.w*shrink;
      const ph = player.h*shrink;

      for (const o of obstacles){
        const ox = o.x, oy = o.y, ow = o.w, oh = o.h;
        if (px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
          return true;
        }
      }
      return false;
    }

    // Game loop
    let lastTime = performance.now();
    let nextPointMilestone = 100;

    function loop(now){
      if (!state.running) return;
      const dt = Math.min(32, now - lastTime); // clamp
      lastTime = now;
      state.time += dt;

      update(dt);
      render();

      if (state.running){
        requestAnimationFrame(loop);
      }
    }

    function update(dt){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      // Speed up over time, capped
      state.speed = Math.min(state.maxSpeed, state.speed + state.accel * dt * 60);

      // Player physics
      const g = 0.65 * U; // gravity
      const jumpBoost = 0.25 * U;
      if (player.jumping && player.jumpHold < player.maxJumpHold){
        player.vy -= jumpBoost * (dt/16.67);
        player.jumpHold += dt;
      }
      player.vy += g * (dt/16.67) * 10;
      player.y += player.vy;

      const gy = groundY() - player.h;
      if (player.y >= gy){
        player.y = gy;
        player.vy = 0;
        player.onGround = true;
      }else{
        player.onGround = false;
      }

      // Run animation time advances with speed when on ground
      if (player.onGround) player.runTime += (dt/1000) * (0.7 + state.speed*0.05);
      else player.runTime += (dt/1000)*0.4;

      // Spawn obstacles
      state.spawnTimer += dt;
      const minSpawn = Math.max(320, 1100 - state.speed*25);
      if (state.spawnTimer > state.nextSpawn){
        spawnObstacle();
        state.spawnTimer = 0;
        state.nextSpawn = minSpawn + Math.random()*minSpawn;
      }

      // Move obstacles
      for (let i=0; i<obstacles.length; i++){
        obstacles[i].x -= state.speed * (dt/16.67) * 8 * U;
      }
      // Remove offscreen
      obstacles = obstacles.filter(o => o.x + o.w > -20);

      // Score
      state.score += (dt/16.67) * (0.5 + state.speed*0.5);
      if (state.score >= nextPointMilestone){
        soundPoint();
        nextPointMilestone += 100;
      }

      // Background parallax updates
      for (const c of clouds){
        c.x -= (state.speed * 0.6 + 0.2) * c.v * (dt/16.67) * U;
        if (c.x < -80) c.x = W + 80;
      }
      for (const h of hills){
        h.x -= (state.speed * 0.45) * h.v * (dt/16.67) * U;
        if (h.x + h.r < -60) { h.x = W + h.r + Math.random()*80; h.r = 80*U + Math.random()*180*U; }
      }
      for (const gtuft of groundDeco){
        gtuft.x -= (state.speed * 1.2) * gtuft.v * (dt/16.67) * U;
        if (gtuft.x < -30) gtuft.x = W + Math.random()*200;
      }

      // Collisions
      if (isColliding()){
        gameOver();
      }

      // UI updates (synchronous)
      const scoreInt = Math.floor(state.score);
      scoreEl.textContent = scoreInt;
      scoreHUD.textContent = scoreInt;
      setScoreStatus(state.running ? 'live' : 'final');

      highScoreEl.textContent = Math.floor(state.highScore);
      highHUD.textContent = Math.floor(state.highScore);

      // Preview status available after first render
      if (canvas.getAttribute('data-ready') !== 'true'){
        setPreviewReady();
      }
    }

    function render(){
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      // Clear (transparent; background from container)
      ctx.clearRect(0,0,W,H);

      // Background layers (parallax)
      drawSky();

      // Far hills
      for (const h of hills){
        drawHill(h.x, h.y, h.r, h.hue);
      }

      // Clouds on top of hills
      for (const c of clouds){
        drawCloud(c.x, c.y, c.s*U);
      }

      // Ground
      drawGround();

      // Ground decor
      for (const gtuft of groundDeco){
        drawGrassTuft(gtuft.x, gtuft.y, gtuft.s*U, gtuft.c);
      }

      // Obstacles
      for (const o of obstacles){
        drawObstacle(o);
      }

      // Player
      drawPlayer();

      // Simple speed indicator (top center)
      const barW = Math.min(1, (state.speed/state.maxSpeed)) * (W*0.25);
      ctx.fillStyle = '#00000033';
      ctx.fillRect(W*0.5 - barW/2, 6*U, barW, 6*U);
    }

    function gameOver(){
      if (state.gameOver) return;
      state.gameOver = true;
      state.running = false;
      setGameStatus('stopped');
      setStartStatus('idle');
      setJumpEnabled(false);
      ensureAudio();
      soundCrash();

      // Update high score
      const prevHigh = state.highScore;
      const newScore = Math.floor(state.score);
      if (newScore > prevHigh){
        state.highScore = newScore;
        localStorage.setItem('funGameHighScore', String(state.highScore));
        container.setAttribute('data-new-high', 'true');
        highHUD.setAttribute('data-new-high', 'true');
        setHighScoreStatus('new-high');
        logEvent('highscore', `new personal best: ${state.highScore}`);
      }else{
        container.setAttribute('data-new-high', 'false');
        highHUD.setAttribute('data-new-high', 'false');
        setHighScoreStatus('idle');
      }

      finalScoreEl.textContent = Math.floor(state.score);
      finalHighScoreEl.textContent = Math.floor(state.highScore);
      showGameOver();
      logEvent('gameover', `score ${newScore}, high ${state.highScore}`);
    }

    // Initialize
    function boot(){
      resizeCanvas();
      updateMuteButtons();
      highScoreEl.textContent = Math.floor(state.highScore);
      scoreEl.textContent = 0;
      scoreHUD.textContent = 0;
      highHUD.textContent = Math.floor(state.highScore);
      setSoundStatus(!muted);
      setOverlayStatus('start');
      setGameStatus('stopped');
      setStartStatus('idle');
      setJumpEnabled(false);
      showStart();
      render();
      setPreviewReady();
      logEvent('boot', 'initialized');
    }
    boot();

    // Accessibility: clicking canvas also jumps
    canvas.addEventListener('pointerdown', ()=>{
      tryJump(true);
    });

    // Ensure Retry button disabled while running, enabled on game over
    function updateRetryButton(){
      const isEnabled = !state.running && state.gameOver;
      retryBtn.disabled = !isEnabled;
      retryBtn.setAttribute('aria-disabled', String(!isEnabled));
    }
    // Keep retry button state in sync with overlay transitions
    const observer = new MutationObserver(()=>{
      updateRetryButton();
    });
    observer.observe(gameOverOverlay, {attributes:true, attributeFilter:['class','aria-hidden']});

    // Periodically sync controls (safe without timers; will only run when called in events)
    function syncControls(){
      // Keep header and dock buttons consistent labels
      const soundLabel = muted ? 'Sound Off' : 'Sound On';
      muteBtn.textContent = soundLabel;
      muteBtnOverlay.textContent = soundLabel;
      muteBtnDock.textContent = soundLabel;

      // Jump buttons enabled only when running
      setJumpEnabled(state.running);

      // Retry button availability
      updateRetryButton();
    }

    // Immediately sync after key state changes
    document.addEventListener('visibilitychange', syncControls);
    window.addEventListener('resize', syncControls);

  })();
  </script>
</body>
</html>
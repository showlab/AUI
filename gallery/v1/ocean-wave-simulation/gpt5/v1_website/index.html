<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ocean Wave Simulation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="A clear, accessible ocean wave simulation with adjustable wind, wave height, and lighting. Built with HTML5, CSS3, and vanilla JavaScript (WebGL). Fine-grained controls, keyboard and touch support, instant feedback, status proxies, and presets." />
  <style>
    /* Destylized, high-contrast, operator-friendly UI
       - White background, black text
       - No shadows, no rounded corners, no decorative gradients
       - Clear layout: controls on the left, canvas covers background
       - Touch targets ≥ 44px
    */

    :root {
      --bg: #ffffff;
      --text: #000000;
      --muted: #333333;
      --accent: #005fcc;
      --accent-weak: #e6f0ff;
      --track: #cccccc;
      --track-fill: #000000;
      --border: #000000;
      --warn: #cc0000;
      --ok: #006600;
      --focus: 2px solid #000000; /* obvious focus */
      --min-touch: 44px;
      --panel-width: 400px;
      --panel-max-width: 520px; /* for wide screens */
      --gap: 12px;
      --gap-lg: 16px;
      --line: 1px solid var(--border);
      --thumb-size: 28px; /* touch target >= 44x but thumb is 28; row height ensures 44 */
      --row-min-height: 44px; /* ensures min target size */
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      line-height: 1.4;
    }

    /* Basic page frame */
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--bg);
      border-bottom: var(--line);
      z-index: 50;
      padding: 8px 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
    }

    #titleBlock {
      display: flex;
      align-items: baseline;
      gap: 12px;
    }

    header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
    }

    header p {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
    }

    nav#topNav {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    nav#topNav a {
      color: var(--text);
      text-decoration: underline;
      border: var(--line);
      padding: 8px 10px;
      min-height: var(--min-touch);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    nav#topNav a:focus-visible {
      outline: var(--focus);
      outline-offset: 2px;
    }

    main {
      position: relative;
      width: 100%;
      height: 100%;
      padding-top: 56px; /* header height reserve */
    }

    /* Canvas covers the entire viewport behind UI */
    #oceanCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      outline: none;
      background: transparent;
      z-index: 1;
    }

    /* Overlay to maintain visibility at very low sun intensity */
    #visibilityOverlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: rgba(255,255,255,0); /* dynamically adjusted when needed */
      z-index: 2;
    }

    /* Left control panel */
    #leftColumn {
      position: fixed;
      top: 56px;
      left: 0;
      bottom: 0;
      width: min(var(--panel-max-width), calc(100vw - 24px));
      max-width: var(--panel-max-width);
      padding: 12px;
      overflow: auto;
      border-right: var(--line);
      background: rgba(255,255,255,0.92);
      z-index: 3;
    }

    #controlPanel {
      width: 100%;
    }

    #controlPanel h2 {
      font-size: 18px;
      margin: 0 0 8px 0;
      padding: 8px 0;
      border-bottom: var(--line);
    }

    .group {
      margin: 0 0 16px 0;
      padding: 8px 0 8px 0;
    }

    .group h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
      font-weight: 700;
    }

    .control {
      display: grid;
      grid-template-columns: 1fr auto;
      grid-template-rows: auto auto auto;
      column-gap: 8px;
      row-gap: 6px;
      padding: 8px 0;
      align-items: center;
      min-height: var(--row-min-height);
      border-bottom: 1px dotted #000; /* subtle grouping edge */
    }

    .control:last-child {
      border-bottom: none;
    }

    .control label {
      grid-column: 1 / span 1;
      font-size: 13px;
    }

    /* Numeric output (live) */
    .control output {
      grid-column: 2 / span 1;
      justify-self: end;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
    }

    /* User hints and min/max row */
    .miniRow {
      grid-column: 1 / span 2;
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--muted);
    }

    /* Slider row */
    .sliderRow {
      grid-column: 1 / span 2;
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      align-items: center;
      min-height: var(--row-min-height);
    }

    .stepBtn {
      min-width: 44px;
      min-height: var(--min-touch);
      border: var(--line);
      background: #fff;
      color: var(--text);
      font-size: 16px;
      cursor: pointer;
      user-select: none;
    }
    .stepBtn:focus-visible,
    .primaryBtn:focus-visible,
    .secondaryBtn:focus-visible {
      outline: var(--focus);
      outline-offset: 2px;
    }

    /* Range slider */
    .control input[type="range"] {
      appearance: none;
      width: 100%;
      height: 8px;
      background: var(--track);
      border: var(--line);
      cursor: pointer;
      position: relative;
    }

    .control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: var(--thumb-size);
      height: var(--thumb-size);
      background: var(--track-fill);
      border: var(--line);
      cursor: pointer;
      margin-top: calc((8px - var(--thumb-size))/2);
    }

    .control input[type="range"]::-moz-range-thumb {
      width: var(--thumb-size);
      height: var(--thumb-size);
      background: var(--track-fill);
      border: var(--line);
      cursor: pointer;
    }

    .control input[type="range"]:focus-visible {
      outline: var(--focus);
      outline-offset: 2px;
    }

    .control input[type="range"].active {
      border: 2px solid var(--accent);
    }

    /* Value bubble above slider while dragging */
    .valueBubble {
      position: absolute;
      transform: translate(-50%, -120%);
      padding: 4px 6px;
      background: #fff;
      border: var(--line);
      color: #000;
      font-size: 12px;
      white-space: nowrap;
      display: none;
      z-index: 10;
      pointer-events: none;
    }

    /* At max value hint */
    .atMaxLabel {
      display: none;
      color: var(--warn);
      font-size: 12px;
    }

    .control[data-at-max="true"] .atMaxLabel {
      display: inline;
    }

    /* Action rows */
    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 8px;
    }

    .primaryBtn, .secondaryBtn {
      min-height: var(--min-touch);
      border: var(--line);
      background: #fff;
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
      padding: 8px 12px;
      text-align: center;
    }

    .primaryBtn[aria-pressed="true"] {
      background: var(--accent-weak);
    }

    /* Presets */
    #presetRow {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    .presetBtn {
      min-height: var(--min-touch);
      border: var(--line);
      background: #fff;
      font-size: 14px;
      cursor: pointer;
      padding: 8px 12px;
      text-align: center;
    }

    #savePresetRow {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      margin-top: 8px;
    }
    #presetName {
      min-height: var(--min-touch);
      border: var(--line);
      padding: 8px 10px;
      font-size: 14px;
      width: 100%;
    }
    #btnSavePreset {
      min-height: var(--min-touch);
      border: var(--line);
      padding: 8px 12px;
      background: #fff;
      font-size: 14px;
      cursor: pointer;
    }

    /* Status + proxies panel */
    #statusPanel {
      margin-top: 12px;
      border-top: var(--line);
      padding-top: 12px;
    }

    #statusGrid {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 6px 12px;
      align-items: start;
      font-size: 13px;
    }

    .statusLabel {
      color: var(--muted);
    }

    .statusValue {
      color: var(--text);
      font-weight: 600;
    }

    #keyboardHints {
      margin-top: 12px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px dotted #000;
      padding-top: 8px;
    }

    /* Right column: about + help text (scrollable) */
    #rightColumn {
      position: fixed;
      top: 56px;
      right: 0;
      bottom: 0;
      width: min(520px, calc(100vw - var(--panel-width)));
      max-width: 520px;
      padding: 12px;
      overflow: auto;
      border-left: var(--line);
      background: rgba(255,255,255,0.92);
      z-index: 3;
    }

    #about, #help {
      margin-bottom: 24px;
    }

    #about h2, #help h2 {
      font-size: 18px;
      margin: 0 0 8px 0;
      padding: 8px 0;
      border-bottom: var(--line);
    }

    #about p, #help p, #about ul, #help ul, #about li, #help li {
      font-size: 14px;
      margin: 8px 0;
    }

    /* Footer */
    footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      border-top: var(--line);
      padding: 6px 12px;
      background: #fff;
      font-size: 12px;
      color: var(--muted);
      z-index: 50;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    /* Compact at smaller heights */
    @media (max-height: 740px) {
      #leftColumn { padding: 8px; }
      #rightColumn { padding: 8px; }
      .control { padding: 6px 0; }
      .stepBtn, .primaryBtn, .secondaryBtn, #btnSavePreset, .presetBtn { min-height: 44px; }
    }

    /* Ensure both columns not too wide for 1280x720 - we allow main canvas to remain visible */
    @media (max-width: 1200px) {
      #rightColumn { display: none; }
    }

    /* Toast/simple message box for immediate feedback (no auto timers; we update content directly) */
    #liveMessage {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: #fff;
      border: var(--line);
      padding: 6px 10px;
      font-size: 13px;
      z-index: 60;
      pointer-events: none;
      max-width: 80vw;
      text-align: center;
    }

    /* Download anchor visibility state demo */
    #downloadLink[download] {
      border-bottom: 1px dotted #000;
    }
  </style>
</head>
<body>
  <header>
    <div id="titleBlock">
      <h1>Ocean Wave Simulation</h1>
      <p>Wind, wave height, and lighting. WebGL. Accessible controls.</p>
    </div>
    <nav id="topNav" aria-label="In-page navigation">
      <a id="navControls" href="#sectionControls" data-target="sectionControls">Controls</a>
      <a id="navAbout" href="#sectionAbout" data-target="sectionAbout">About</a>
      <a id="navHelp" href="#sectionHelp" data-target="sectionHelp">Help</a>
      <a id="navExternal" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" target="_blank" rel="noopener">WebGL Docs</a>
    </nav>
  </header>

  <main>
    <canvas id="oceanCanvas" role="img" aria-label="Animated ocean waves rendered in WebGL"></canvas>
    <div id="visibilityOverlay" aria-hidden="true"></div>

    <div id="leftColumn">
      <section id="controlPanel" aria-label="Wave controls">
        <h2>Controls</h2>

        <div class="group" aria-labelledby="lightingHeader">
          <h3 id="lightingHeader">Lighting</h3>

          <div class="control" id="controlSunElevation">
            <label for="sunElevationSlider">Sun elevation (°)</label>
            <output id="sunElevationValue" for="sunElevationSlider" aria-live="polite">35</output>
            <div class="miniRow">
              <span>Min: <span id="sunElevationMinLabel">5</span></span>
              <span>Max: <span id="sunElevationMaxLabel">85</span> <span class="atMaxLabel" id="sunElevationAtMax">MAX</span></span>
            </div>
            <div class="sliderRow">
              <button class="stepBtn" id="sunElevationMinus" aria-label="Decrease sun elevation">−</button>
              <div style="position:relative;">
                <input id="sunElevationSlider" type="range" min="5" max="85" step="0.01" value="35" aria-label="Sun elevation" list="tickElevation">
                <div class="valueBubble" id="bubbleSunElevation">35°</div>
              </div>
              <button class="stepBtn" id="sunElevationPlus" aria-label="Increase sun elevation">+</button>
            </div>
            <datalist id="tickElevation">
              <option value="5" label="Low"></option>
              <option value="45" label="Medium"></option>
              <option value="85" label="High"></option>
            </datalist>
          </div>

          <div class="control" id="controlSunIntensity">
            <label for="sunIntensitySlider">Sun intensity</label>
            <output id="sunIntensityValue" for="sunIntensitySlider" aria-live="polite">0.80</output>
            <div class="miniRow">
              <span>Min: <span id="sunIntensityMinLabel">0</span></span>
              <span>Max: <span id="sunIntensityMaxLabel">1</span> <span class="atMaxLabel" id="sunIntensityAtMax">MAX</span></span>
            </div>
            <div class="sliderRow">
              <button class="stepBtn" id="sunIntensityMinus" aria-label="Decrease sun intensity">−</button>
              <div style="position:relative;">
                <input id="sunIntensitySlider" type="range" min="0" max="1" step="0.01" value="0.8" aria-label="Sun intensity" list="tickSunIntensity">
                <div class="valueBubble" id="bubbleSunIntensity">0.80</div>
              </div>
              <button class="stepBtn" id="sunIntensityPlus" aria-label="Increase sun intensity">+</button>
            </div>
            <datalist id="tickSunIntensity">
              <option value="0" label="Low"></option>
              <option value="0.5" label="Medium"></option>
              <option value="1" label="High"></option>
            </datalist>
            <div class="miniRow">
              <span>Tip: Lower intensity simulates dusk/night. An overlay preserves visibility.</span>
            </div>
          </div>
        </div>

        <div class="group" aria-labelledby="oceanHeader">
          <h3 id="oceanHeader">Ocean</h3>

          <div class="control" id="controlWaveHeight">
            <label for="waveHeightSlider">Wave height (m)</label>
            <output id="waveHeightValue" for="waveHeightSlider" aria-live="polite">1.00</output>
            <div class="miniRow">
              <span>Min: <span id="waveHeightMinLabel">0</span></span>
              <span>Max: <span id="waveHeightMaxLabel">3</span> <span class="atMaxLabel" id="waveHeightAtMax">MAX</span></span>
            </div>
            <div class="sliderRow">
              <button class="stepBtn" id="waveHeightMinus" aria-label="Decrease wave height">−</button>
              <div style="position:relative;">
                <input id="waveHeightSlider" type="range" min="0" max="3" step="0.01" value="1.0" aria-label="Wave height" list="tickWave">
                <div class="valueBubble" id="bubbleWaveHeight">1.00 m</div>
              </div>
              <button class="stepBtn" id="waveHeightPlus" aria-label="Increase wave height">+</button>
            </div>
            <datalist id="tickWave">
              <option value="0" label="Low"></option>
              <option value="1.5" label="Medium"></option>
              <option value="3" label="High"></option>
            </datalist>
            <div class="miniRow">
              <span>Describes crest amplitude.</span>
            </div>
          </div>

          <div class="control" id="controlWindSpeed">
            <label for="windSpeedSlider">Wind speed (m/s)</label>
            <output id="windSpeedValue" for="windSpeedSlider" aria-live="polite">8.0</output>
            <div class="miniRow">
              <span>Min: <span id="windSpeedMinLabel">0</span></span>
              <span>Max: <span id="windSpeedMaxLabel">20</span> <span class="atMaxLabel" id="windSpeedAtMax">MAX</span></span>
            </div>
            <div class="sliderRow">
              <button class="stepBtn" id="windSpeedMinus" aria-label="Decrease wind speed">−</button>
              <div style="position:relative;">
                <input id="windSpeedSlider" type="range" min="0" max="20" step="0.1" value="8.0" aria-label="Wind speed" list="tickWind">
                <div class="valueBubble" id="bubbleWindSpeed">8.0 m/s</div>
              </div>
              <button class="stepBtn" id="windSpeedPlus" aria-label="Increase wind speed">+</button>
            </div>
            <datalist id="tickWind">
              <option value="0" label="Low"></option>
              <option value="10" label="Medium"></option>
              <option value="20" label="High"></option>
            </datalist>
            <div class="miniRow">
              <span>Strong wind increases choppiness and mist.</span>
            </div>
          </div>
        </div>

        <div class="group" aria-labelledby="actionsHeader">
          <h3 id="actionsHeader">Actions</h3>
          <div class="actions">
            <button id="resetButton" type="button" class="secondaryBtn" aria-label="Reset all settings">Reset</button>
            <button id="pauseButton" type="button" class="primaryBtn" aria-label="Pause or resume animation" aria-pressed="false">Pause</button>
          </div>
          <div class="actions" style="margin-top: 8px;">
            <button id="applyButton" type="button" class="primaryBtn" aria-label="Apply current settings">Apply All</button>
            <button id="btnScreenshot" type="button" class="secondaryBtn" aria-label="Create screenshot">Screenshot</button>
          </div>
          <div id="presetRow" role="group" aria-label="Built-in presets">
            <button id="presetCalm" class="presetBtn" type="button">Calm Morning</button>
            <button id="presetMoon" class="presetBtn" type="button">Moonlit Night</button>
            <button id="presetStorm" class="presetBtn" type="button">Storm</button>
          </div>
          <div id="savePresetRow">
            <input id="presetName" type="text" placeholder="Preset name (optional)" aria-label="Preset name">
            <button id="btnSavePreset" type="button" aria-label="Save current preset">Save Preset</button>
          </div>
        </div>

        <div id="statusPanel" aria-live="polite">
          <div id="statusGrid">
            <div class="statusLabel">Simulation:</div>
            <div class="statusValue" id="simulationStatus">running</div>

            <div class="statusLabel">Apply status:</div>
            <div class="statusValue" id="applyStatus">idle</div>

            <div class="statusLabel">Download status:</div>
            <div class="statusValue" id="downloadStatus">disabled</div>

            <div class="statusLabel">Render status:</div>
            <div class="statusValue" id="renderStatus">ok</div>

            <div class="statusLabel">FPS:</div>
            <div class="statusValue" id="fpsValue">-</div>

            <div class="statusLabel">Current preset:</div>
            <div class="statusValue" id="currentPresetLabel">Custom</div>

            <div class="statusLabel">Last change:</div>
            <div class="statusValue" id="lastChangeText">—</div>

            <div class="statusLabel">Active Section:</div>
            <div class="statusValue" id="activeSection">sectionControls</div>

            <div class="statusLabel">Last link:</div>
            <div class="statusValue" id="lastLinkClicked">none</div>

            <div class="statusLabel">Preview:</div>
            <div class="statusValue" id="previewStatus">not-ready</div>

            <div class="statusLabel">Download:</div>
            <div class="statusValue"><a id="downloadLink" href="#" aria-disabled="true">none</a></div>
          </div>

          <div id="keyboardHints">
            - Press Space to Pause/Resume. | Enter to Apply All when focused on Apply. | Use arrow keys on sliders for precise changes. | Plus/Minus buttons step values. <br>
            - Sliders accept touch, mouse, and keyboard.
          </div>
        </div>
      </section>
    </div>

    <div id="rightColumn" aria-label="Reference">
      <section id="about" aria-labelledby="aboutHeader">
        <h2 id="aboutHeader">About</h2>
        <p>
          This ocean wave simulation renders a dynamic water surface using a classic Gerstner wave model,
          implemented fully in WebGL with a fragment and vertex shader pair. The scene features multiple
          interfering wave sets, a physically-inspired specular highlight, Fresnel-based reflection blending, and
          a simple distance-based fog. You can manipulate the wind speed, wave height, sun elevation, and sun intensity
          to explore a variety of moods, from tranquil mornings to moonlit nights and stormy seas.
        </p>
        <p>
          Design goals for this version prioritize clarity, accessibility, and predictability. We focus on:
        </p>
        <ul>
          <li>Immediate, synchronous feedback for all changes.</li>
          <li>Keyboard and touch input parity, with large touch targets.</li>
          <li>High-contrast, no-frills visual design to keep the controls legible in all conditions.</li>
          <li>Operator-friendly instrumentation (status indicators, FPS, and rendering state).</li>
          <li>Stable identifiers and predictable behaviors for automated testing.</li>
        </ul>
        <p>
          The simulation runs continuously and responds instantly to user input. When sun intensity is extremely low,
          a subtle visibility overlay is applied over the canvas to ensure the scene remains perceivable, while leaving
          the physical lighting math intact. Controls never reduce what's allowed by the original model; ranges are permissive.
        </p>
        <p>
          Technical overview of the wave model:
        </p>
        <ul>
          <li>Four directional wave trains with different wavelengths and amplitudes.</li>
          <li>Wind speed influences choppiness and fog density.</li>
          <li>Surface normals computed from analytic partial derivatives of the superposed Gerstner waves.</li>
          <li>Lighting uses Blinn-Phong with fixed exponent and Schlick Fresnel approximation.</li>
          <li>Sky reflection is a simple gradient dependent on the view vector upness.</li>
        </ul>
        <p>
          The rendering pipeline uses a grid mesh, transformed in the vertex shader. The scene is cleared to sky color,
          and the camera gently bobbles when not paused. If the tab visibility changes, the simulation retains state and
          the pause button remains consistent.
        </p>
        <p>
          To keep the UI informative without distractions, we surface compact status text, including "Apply" status,
          render state, and FPS. A screenshot button enables you to capture the current frame and download it.
        </p>
      </section>

      <section id="help" aria-labelledby="helpHeader">
        <h2 id="helpHeader">Help</h2>
        <p><strong>Basic usage:</strong></p>
        <ul>
          <li>Move sliders or use the +/- buttons to adjust values.</li>
          <li>Use arrow keys with sliders for precise control.</li>
          <li>Press Space to pause/resume the animation.</li>
          <li>Click Apply All to mark the current settings as applied (updates the Apply status indicator).</li>
        </ul>
        <p><strong>Presets:</strong></p>
        <ul>
          <li>Calm Morning: Gentle waves, moderate elevation and light.</li>
          <li>Moonlit Night: Low sun intensity, lower elevation; visibility overlay ensures legibility.</li>
          <li>Storm: High wind and taller waves, stronger fog.</li>
          <li>You can save your own preset by typing a name and clicking Save Preset.</li>
        </ul>
        <p><strong>Keyboard shortcuts:</strong></p>
        <ul>
          <li>Space: Toggle Pause/Resume.</li>
          <li>Enter: While Apply All is focused, performs Apply.</li>
          <li>Arrow keys on sliders: Adjust values according to the slider step.</li>
        </ul>
        <p><strong>Touch support:</strong> Sliders support touch drag. If your browser scrolls during a drag,
          ensure the finger is within the slider track. We also prevent scrolling during direct slider interaction in this panel.
        </p>
        <p>
          <strong>Export:</strong> Use the Screenshot button to generate a PNG from the current frame.
          The download link becomes enabled and the "Download status" changes to "enabled" as soon as the image is ready.
        </p>
        <p>
          <strong>Troubleshooting:</strong> If WebGL is unavailable in your environment, a clear message will appear.
          The "Render status" indicator will show errors if shader compilation fails.
          If frames per second drops significantly, the FPS indicator helps identify performance constraints.
        </p>
        <p>
          <strong>Notes for automation:</strong> All interactive elements have stable IDs. Changes update live outputs and status proxies synchronously.
          We avoid auto-triggered workflows at load; the simulation initializes in a neutral, running state without external side effects.
        </p>
      </section>
    </div>

    <div id="liveMessage" aria-live="polite">Ready.</div>
  </main>

  <footer>
    <div>Built with HTML5, CSS3, and WebGL (no external libraries)</div>
    <div>Download: <a id="footDownloadLink" href="#" aria-disabled="true">none</a></div>
  </footer>

  <script>
    (function() {
      // Navigation proxies and link tracking
      const activeSectionLabel = document.getElementById('activeSection');
      const lastLinkClicked = document.getElementById('lastLinkClicked');
      const navControls = document.getElementById('navControls');
      const navAbout = document.getElementById('navAbout');
      const navHelp = document.getElementById('navHelp');
      const navExternal = document.getElementById('navExternal');

      function navHandler(e) {
        const target = e.currentTarget.getAttribute('data-target');
        if (target) {
          e.preventDefault();
          const el = document.getElementById(target.replace('section','').toLowerCase()) || document.getElementById(target);
          const dest = target === 'sectionControls' ? document.getElementById('leftColumn') : (target === 'sectionAbout' ? document.getElementById('about') : document.getElementById('help'));
          if (dest && dest.scrollIntoView) dest.scrollIntoView({ behavior: 'instant', block: 'start', inline: 'nearest' });
          activeSectionLabel.textContent = target;
        }
      }

      navControls.addEventListener('click', navHandler);
      navControls.addEventListener('keydown', (e)=>{ if(e.key==='Enter') navControls.click(); });

      navAbout.addEventListener('click', navHandler);
      navAbout.addEventListener('keydown', (e)=>{ if(e.key==='Enter') navAbout.click(); });

      navHelp.addEventListener('click', navHandler);
      navHelp.addEventListener('keydown', (e)=>{ if(e.key==='Enter') navHelp.click(); });

      navExternal.addEventListener('click', ()=> {
        lastLinkClicked.textContent = 'WebGL Docs';
      });

      // Live message helper (sync updates, no timers auto-hide)
      const liveMessage = document.getElementById('liveMessage');
      function setLiveMessage(msg) {
        liveMessage.textContent = msg;
      }

      // Prevent scrolling while sliding in the left control panel on touch
      const leftColumn = document.getElementById('leftColumn');
      leftColumn.addEventListener('touchmove', (e) => {
        const isRange = e.target && e.target.tagName === 'INPUT' && e.target.type === 'range';
        if (isRange) {
          e.preventDefault();
        }
      }, { passive: false });

      // Canvas / WebGL initialization
      const canvas = document.getElementById('oceanCanvas');
      const gl = canvas.getContext('webgl', { antialias: true, alpha: true });

      // Status proxies
      const simulationStatus = document.getElementById('simulationStatus');
      const applyStatus = document.getElementById('applyStatus');
      const renderStatus = document.getElementById('renderStatus');
      const downloadStatus = document.getElementById('downloadStatus');
      const fpsValue = document.getElementById('fpsValue');
      const lastChangeText = document.getElementById('lastChangeText');
      const currentPresetLabel = document.getElementById('currentPresetLabel');
      const previewStatus = document.getElementById('previewStatus');
      const downloadLink = document.getElementById('downloadLink');
      const footDownloadLink = document.getElementById('footDownloadLink');

      if (!gl) {
        const msg = document.createElement('div');
        msg.textContent = 'WebGL not supported: this simulation requires a modern browser.';
        msg.style.position = 'fixed';
        msg.style.inset = '0';
        msg.style.display = 'grid';
        msg.style.placeItems = 'center';
        msg.style.background = 'rgba(255,255,255,0.9)';
        msg.style.color = '#000';
        msg.style.fontSize = '18px';
        msg.style.zIndex = '100';
        document.body.appendChild(msg);
        renderStatus.textContent = 'error: WebGL not supported';
        setLiveMessage('WebGL not supported.');
        return;
      }

      // Shaders
      const vertexSrc = `
attribute vec2 a_position;

uniform mat4 u_viewProj;
uniform vec3 u_cameraPos;
uniform float u_time;
uniform float u_ampScale;
uniform float u_steepness;
uniform float u_windSpeed;
uniform float u_gridScale;

const int WAVE_COUNT = 4;
uniform vec2 u_dir[WAVE_COUNT];
uniform float u_lambda[WAVE_COUNT];
uniform float u_ampMult[WAVE_COUNT];

varying vec3 v_worldPos;
varying vec3 v_normal;
varying float v_dist;

const float PI = 3.14159265359;
const float TAU = 6.28318530718;
const float G = 9.81;

void main() {
  vec2 xz0 = a_position * u_gridScale;

  vec3 pos = vec3(xz0.x, 0.0, xz0.y);

  float dXdx = 1.0; float dXdz = 0.0;
  float dYdx = 0.0; float dYdz = 0.0;
  float dZdx = 0.0; float dZdz = 1.0;

  for (int i = 0; i < WAVE_COUNT; i++) {
    vec2 D = normalize(u_dir[i]);
    float lambda = u_lambda[i];
    float k = TAU / lambda;             // wave number
    float A = u_ampScale * u_ampMult[i];
    float w = sqrt(G * k) * (0.35 + u_windSpeed * 0.05); // angular speed scaled by wind
    float phi = k * dot(D, xz0) - w * u_time;

    float s = sin(phi);
    float c = cos(phi);

    // safe steepness to avoid self-intersection
    float maxQ = 1.0 / max(k * A * float(WAVE_COUNT), 1e-3);
    float Q = min(u_steepness, maxQ);

    // Gerstner displacement
    pos.x += D.x * (Q * A) * c;
    pos.z += D.y * (Q * A) * c;
    pos.y += A * s;

    // Partials for normal
    float kA = k * A;
    float dx = D.x;
    float dz = D.y;

    dXdx += -Q * kA * dx * dx * s;
    dXdz += -Q * kA * dx * dz * s;

    dYdx += kA * dx * c;
    dYdz += kA * dz * c;

    dZdx += -Q * kA * dz * dx * s;
    dZdz += -Q * kA * dz * dz * s;
  }

  vec3 tangentX = vec3(dXdx, dYdx, dZdx);
  vec3 tangentZ = vec3(dXdz, dYdz, dZdz);
  vec3 normal = normalize(cross(tangentZ, tangentX));

  v_worldPos = pos;
  v_normal = normal;
  v_dist = length(pos - u_cameraPos);

  gl_Position = u_viewProj * vec4(pos, 1.0);
}
      `;

      const fragmentSrc = `
precision mediump float;

varying vec3 v_worldPos;
varying vec3 v_normal;
varying float v_dist;

uniform vec3 u_cameraPos;

uniform vec3 u_sunDir;
uniform vec3 u_sunColor;
uniform vec3 u_skyColorTop;
uniform vec3 u_skyColorHorizon;
uniform vec3 u_deepColor;
uniform float u_sunIntensity;
uniform float u_fogDensity;

void main() {
  vec3 N = normalize(v_normal);
  vec3 V = normalize(u_cameraPos - v_worldPos);
  vec3 L = normalize(u_sunDir);

  float NdotL = max(dot(N, L), 0.0);
  float diffuse = 0.12 * NdotL;

  // Specular highlight (Blinn-Phong)
  vec3 H = normalize(L + V);
  float spec = pow(max(dot(N, H), 0.0), 120.0) * u_sunIntensity;

  // Fresnel term (Schlick approximation)
  float cosTheta = max(dot(N, V), 0.0);
  float Fresnel = pow(1.0 - cosTheta, 3.0);

  // Sky gradient color based on view upness
  float skyT = clamp(V.y * 0.5 + 0.5, 0.0, 1.0);
  vec3 skyColor = mix(u_skyColorHorizon, u_skyColorTop, skyT);

  // Base water color + subtle diffuse + specular
  vec3 color = u_deepColor * (0.55 + diffuse) + u_sunColor * spec;

  // Reflection blend (Fresnel)
  color = mix(color, skyColor, 0.08 + 0.92 * Fresnel);

  // Distance fog toward horizon
  float fog = 1.0 - exp(-v_dist * u_fogDensity);
  vec3 fogColor = u_skyColorHorizon;
  color = mix(color, fogColor, fog);

  gl_FragColor = vec4(color, 1.0);
}
      `;

      // Compile shaders and link program
      function compileShader(src, type) {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(sh));
          gl.deleteShader(sh);
          return null;
        }
        return sh;
      }

      function createProgram(vsSrc, fsSrc) {
        const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
        const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
        if (!vs || !fs) {
          renderStatus.textContent = 'error: shader compile';
          setLiveMessage('Shader compilation failed.');
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(prog));
          renderStatus.textContent = 'error: program link';
          setLiveMessage('Program linking failed.');
          return null;
        }
        return prog;
      }

      const program = createProgram(vertexSrc, fragmentSrc);
      if (!program) {
        renderStatus.textContent = 'error: program null';
        return;
      }
      gl.useProgram(program);

      // Look up attribute/uniform locations
      const attribs = {
        position: gl.getAttribLocation(program, 'a_position'),
      };

      const uniforms = {
        viewProj: gl.getUniformLocation(program, 'u_viewProj'),
        cameraPos: gl.getUniformLocation(program, 'u_cameraPos'),
        time: gl.getUniformLocation(program, 'u_time'),
        ampScale: gl.getUniformLocation(program, 'u_ampScale'),
        steepness: gl.getUniformLocation(program, 'u_steepness'),
        windSpeed: gl.getUniformLocation(program, 'u_windSpeed'),
        gridScale: gl.getUniformLocation(program, 'u_gridScale'),
        dir: gl.getUniformLocation(program, 'u_dir[0]'),
        lambda: gl.getUniformLocation(program, 'u_lambda[0]'),
        ampMult: gl.getUniformLocation(program, 'u_ampMult[0]'),
        sunDir: gl.getUniformLocation(program, 'u_sunDir'),
        sunColor: gl.getUniformLocation(program, 'u_sunColor'),
        skyTop: gl.getUniformLocation(program, 'u_skyColorTop'),
        skyHorizon: gl.getUniformLocation(program, 'u_skyColorHorizon'),
        deepColor: gl.getUniformLocation(program, 'u_deepColor'),
        sunIntensity: gl.getUniformLocation(program, 'u_sunIntensity'),
        fogDensity: gl.getUniformLocation(program, 'u_fogDensity'),
      };

      // Create ocean grid
      function createGrid(resolution) {
        const N = resolution;
        const verts = new Float32Array(N * N * 2); // x,z
        const idxCount = (N - 1) * (N - 1) * 6;
        const indices = new Uint16Array(idxCount);

        let v = 0;
        for (let i = 0; i < N; i++) {
          const t = i / (N - 1);
          const z = (t - 0.5) * 2.0;
          for (let j = 0; j < N; j++) {
            const s = j / (N - 1);
            const x = (s - 0.5) * 2.0;
            verts[v++] = x;
            verts[v++] = z;
          }
        }

        let k = 0;
        for (let i = 0; i < N - 1; i++) {
          for (let j = 0; j < N - 1; j++) {
            const a = i * N + j;
            const b = a + 1;
            const c = a + N;
            const d = c + 1;
            indices[k++] = a; indices[k++] = c; indices[k++] = b;
            indices[k++] = b; indices[k++] = c; indices[k++] = d;
          }
        }
        return { verts, indices, count: idxCount };
      }

      // Keep function name degToRad as requested
      function degToRad(d) { return d * Math.PI / 180; }

      const GRID_RES = 150;
      const GRID_SCALE = 60.0; // world units extent
      const ocean = createGrid(GRID_RES);

      // Buffers
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, ocean.verts, gl.STATIC_DRAW);

      const ebo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, ocean.indices, gl.STATIC_DRAW);

      gl.enableVertexAttribArray(attribs.position);
      gl.vertexAttribPointer(attribs.position, 2, gl.FLOAT, false, 2 * 4, 0);

      // Wave parameters
      const WAVE_COUNT = 4;
      // Base directions around an azimuth (-45 degrees) with slight offsets
      const baseAzimuthDeg = -45;
      const dirs = new Float32Array(WAVE_COUNT * 2);
      const dirAzimuths = [
        baseAzimuthDeg - 15,
        baseAzimuthDeg + 8,
        baseAzimuthDeg + 24,
        baseAzimuthDeg - 32
      ];
      for (let i = 0; i < WAVE_COUNT; i++) {
        const a = degToRad(dirAzimuths[i]);
        dirs[i * 2 + 0] = Math.cos(a);
        dirs[i * 2 + 1] = Math.sin(a);
      }
      const lambdas = new Float32Array([25.0, 15.0, 9.0, 5.0]); // wavelengths (world units)
      const ampMult = new Float32Array([0.60, 0.40, 0.25, 0.15]); // relative amplitudes

      // Colors
      const sunColor = new Float32Array([1.0, 0.98, 0.92]);
      const skyTop = new Float32Array([0.73, 0.87, 0.98]);
      const skyHorizon = new Float32Array([0.70, 0.84, 0.95]);
      const deepColor = new Float32Array([0.02, 0.28, 0.48]);

      // Camera
      const camera = {
        eye: new Float32Array([0, 2.2, -6.0]),
        target: new Float32Array([0, 0.4, 3.0]),
        up: new Float32Array([0, 1, 0]),
        fov: 60 * Math.PI / 180,
        near: 0.1,
        far: 300.0
      };

      // Minimal mat4 utilities
      function mat4Multiply(out, a, b) {
        const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
        const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
        const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
        const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

        out[0]  = a00*b00 + a01*b10 + a02*b20 + a03*b30;
        out[1]  = a00*b01 + a01*b11 + a02*b21 + a03*b31;
        out[2]  = a00*b02 + a01*b12 + a02*b22 + a03*b32;
        out[3]  = a00*b03 + a01*b13 + a02*b23 + a03*b33;
        out[4]  = a10*b00 + a11*b10 + a12*b20 + a13*b30;
        out[5]  = a10*b01 + a11*b11 + a12*b21 + a13*b31;
        out[6]  = a10*b02 + a11*b12 + a12*b22 + a13*b32;
        out[7]  = a10*b03 + a11*b13 + a12*b23 + a13*b33;
        out[8]  = a20*b00 + a21*b10 + a22*b20 + a23*b30;
        out[9]  = a20*b01 + a21*b11 + a22*b21 + a23*b31;
        out[10] = a20*b02 + a21*b12 + a22*b22 + a23*b32;
        out[11] = a20*b03 + a21*b13 + a22*b23 + a23*b33;
        out[12] = a30*b00 + a31*b10 + a32*b20 + a33*b30;
        out[13] = a30*b01 + a31*b11 + a32*b21 + a33*b31;
        out[14] = a30*b02 + a31*b12 + a32*b22 + a33*b32;
        out[15] = a30*b03 + a31*b13 + a32*b23 + a33*b33;
        return out;
      }

      function mat4Perspective(out, fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy / 2);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;

        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;

        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) / (near - far);
        out[11] = -1;

        out[12] = 0;
        out[13] = 0;
        out[14] = (2 * far * near) / (near - far);
        out[15] = 0;
        return out;
      }

      function mat4LookAt(out, eye, target, up) {
        const ex = eye[0], ey = eye[1], ez = eye[2];
        const tx = target[0], ty = target[1], tz = target[2];
        const upx = up[0], upy = up[1], upz = up[2];

        let zx = ex - tx, zy = ey - ty, zz = ez - tz;
        let len = Math.hypot(zx, zy, zz);
        if (len === 0) { zx = 0; zy = 0; zz = 1; } else { zx /= len; zy /= len; zz /= len; }

        let xx = upy * zz - upz * zy;
        let xy = upz * zx - upx * zz;
        let xz = upx * zy - upy * zx;
        len = Math.hypot(xx, xy, xz);
        if (len === 0) { xx = 1; xy = 0; xz = 0; } else { xx /= len; xy /= len; xz /= len; }

        let yx = zy * xz - zz * xy;
        let yy = zz * xx - zx * xz;
        let yz = zx * xy - zy * xx;

        out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
        out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
        out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
        out[12] = -(xx * ex + xy * ey + xz * ez);
        out[13] = -(yx * ex + yy * ey + yz * ez);
        out[14] = -(zx * ex + zy * ey + zz * ez);
        out[15] = 1;
        return out;
      }

      function computeViewProj() {
        const aspect = gl.drawingBufferWidth / gl.drawingBufferHeight;
        const proj = new Float32Array(16);
        const view = new Float32Array(16);
        const viewProj = new Float32Array(16);
        mat4Perspective(proj, camera.fov, aspect, camera.near, camera.far);
        mat4LookAt(view, camera.eye, camera.target, camera.up);
        mat4Multiply(viewProj, proj, view);
        return viewProj;
      }

      // Set static uniforms
      gl.uniform1f(uniforms.gridScale, GRID_SCALE);
      gl.uniform2fv(uniforms.dir, dirs);
      gl.uniform1fv(uniforms.lambda, lambdas);
      gl.uniform1fv(uniforms.ampMult, ampMult);
      gl.uniform3fv(uniforms.sunColor, sunColor);
      gl.uniform3fv(uniforms.skyTop, skyTop);
      gl.uniform3fv(uniforms.skyHorizon, skyHorizon);
      gl.uniform3fv(uniforms.deepColor, deepColor);

      // State
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.disable(gl.CULL_FACE);

      // Clear to sky top color (shows above horizon)
      gl.clearColor(skyTop[0], skyTop[1], skyTop[2], 1.0);

      // Controls and elements
      const windSpeedSlider = document.getElementById('windSpeedSlider');
      const waveHeightSlider = document.getElementById('waveHeightSlider');
      const sunElevationSlider = document.getElementById('sunElevationSlider');
      const sunIntensitySlider = document.getElementById('sunIntensitySlider');

      const windSpeedValue = document.getElementById('windSpeedValue');
      const waveHeightValue = document.getElementById('waveHeightValue');
      const sunElevationValue = document.getElementById('sunElevationValue');
      const sunIntensityValue = document.getElementById('sunIntensityValue');

      const resetButton = document.getElementById('resetButton');
      const pauseButton = document.getElementById('pauseButton');

      const applyButton = document.getElementById('applyButton');
      const btnScreenshot = document.getElementById('btnScreenshot');

      const windSpeedMinus = document.getElementById('windSpeedMinus');
      const windSpeedPlus = document.getElementById('windSpeedPlus');
      const waveHeightMinus = document.getElementById('waveHeightMinus');
      const waveHeightPlus = document.getElementById('waveHeightPlus');
      const sunElevationMinus = document.getElementById('sunElevationMinus');
      const sunElevationPlus = document.getElementById('sunElevationPlus');
      const sunIntensityMinus = document.getElementById('sunIntensityMinus');
      const sunIntensityPlus = document.getElementById('sunIntensityPlus');

      const presetCalm = document.getElementById('presetCalm');
      const presetMoon = document.getElementById('presetMoon');
      const presetStorm = document.getElementById('presetStorm');
      const presetName = document.getElementById('presetName');
      const btnSavePreset = document.getElementById('btnSavePreset');

      const bubbleWindSpeed = document.getElementById('bubbleWindSpeed');
      const bubbleWaveHeight = document.getElementById('bubbleWaveHeight');
      const bubbleSunElevation = document.getElementById('bubbleSunElevation');
      const bubbleSunIntensity = document.getElementById('bubbleSunIntensity');

      const controlWind = document.getElementById('controlWindSpeed');
      const controlWave = document.getElementById('controlWaveHeight');
      const controlSunEl = document.getElementById('controlSunElevation');
      const controlSunInt = document.getElementById('controlSunIntensity');

      const visibilityOverlay = document.getElementById('visibilityOverlay');

      const defaults = {
        windSpeed: 8.0,
        waveHeight: 1.0,
        sunElevation: 35,
        sunIntensity: 0.8
      };

      let params = {
        windSpeed: defaults.windSpeed,
        waveHeight: defaults.waveHeight,
        sunElevation: defaults.sunElevation,
        sunIntensity: defaults.sunIntensity,
        paused: false,
      };

      // Expose fine-grained update with UI signals
      function updateOutputs() {
        windSpeedValue.textContent = Number(params.windSpeed).toFixed(1);
        waveHeightValue.textContent = Number(params.waveHeight).toFixed(2);
        sunElevationValue.textContent = Number(params.sunElevation).toFixed(2);
        sunIntensityValue.textContent = Number(params.sunIntensity).toFixed(2);
        pauseButton.textContent = params.paused ? 'Resume' : 'Pause';
        pauseButton.setAttribute('aria-pressed', params.paused ? 'true' : 'false');
        simulationStatus.textContent = params.paused ? 'paused' : 'running';
        // Update bubbles if active
        setBubble(bubbleWindSpeed, windSpeedSlider, params.windSpeed.toFixed(1) + ' m/s');
        setBubble(bubbleWaveHeight, waveHeightSlider, params.waveHeight.toFixed(2) + ' m');
        setBubble(bubbleSunElevation, sunElevationSlider, params.sunElevation.toFixed(2) + '°');
        setBubble(bubbleSunIntensity, sunIntensitySlider, params.sunIntensity.toFixed(2));
        // MAX labels
        controlWind.dataset.atMax = (params.windSpeed >= parseFloat(windSpeedSlider.max) - 1e-9) ? 'true' : 'false';
        controlWave.dataset.atMax = (params.waveHeight >= parseFloat(waveHeightSlider.max) - 1e-9) ? 'true' : 'false';
        controlSunEl.dataset.atMax = (params.sunElevation >= parseFloat(sunElevationSlider.max) - 1e-9) ? 'true' : 'false';
        controlSunInt.dataset.atMax = (params.sunIntensity >= parseFloat(sunIntensitySlider.max) - 1e-9) ? 'true' : 'false';
        // Overlay for low intensity to maintain visibility (does not clamp input)
        const intensity = params.sunIntensity;
        const overlay = Math.max(0, 0.15 - intensity * 0.15); // 0..0.15 opacity
        visibilityOverlay.style.background = 'rgba(255,255,255,' + overlay.toFixed(3) + ')';
      }

      function syncUniforms() {
        // Wave amplitude scale in world units
        gl.uniform1f(uniforms.ampScale, params.waveHeight * 0.5); // tuned factor
        // Steepness grows with wind, but safely clamped in shader
        const steepness = Math.min(0.1 + 0.03 * params.windSpeed, 1.0);
        gl.uniform1f(uniforms.steepness, steepness);
        gl.uniform1f(uniforms.windSpeed, params.windSpeed);
        gl.uniform1f(uniforms.sunIntensity, params.sunIntensity);

        // Sun direction from elevation and fixed azimuth
        const elev = degToRad(params.sunElevation);
        const az = degToRad(-35); // gentle left azimuth
        const sx = Math.cos(elev) * Math.cos(az);
        const sy = Math.sin(elev);
        const sz = Math.cos(elev) * Math.sin(az);
        const sunDir = new Float32Array([sx, sy, sz]);
        gl.uniform3fv(uniforms.sunDir, sunDir);

        // Fog density scales with wind (more mist with higher wind)
        const fogDensity = 0.010 + params.windSpeed * 0.0006;
        gl.uniform1f(uniforms.fogDensity, fogDensity);
      }

      function setControlValuesToParams() {
        windSpeedSlider.value =
<!DOCTYPE html>
<html lang="en">
<html lang="en">
<head>
<meta charset="utf-8">
<title>Typing Rain</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="description" content="Typing Rain - Type falling words before they hit the ground. Increasing difficulty, accuracy tracker, and score." />
<style>
/* Destylization: simple, high-contrast theme. No gradients, no shadows, no rounded corners. */
:root{
  --bg:#ffffff;
  --fg:#000000;
  --muted:#333333;
  --accent:#0057ff;
  --accent-2:#008cff;
  --ok:#008000;
  --warning:#c47f00;
  --danger:#cc0000;
  --panel:#f2f2f2;
  --line:#000000;
}

*{box-sizing:border-box}
html,body{margin:0; padding:0; height:100%; width:100%; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji", sans-serif; overflow:hidden}

/* Top bar with app title and primary controls */
header{
  position:relative; z-index:10;
  width:100%; padding:8px 12px;
  display:flex; align-items:center; justify-content:space-between; gap:12px;
  background: #fff; border-bottom:1px solid #000;
}
header h1{
  margin:0; font-size: 18px; font-weight: 700; letter-spacing:0.2px; display:flex; align-items:center; gap:10px;
}
header h1 .logo{
  width:24px; height:24px; display:inline-block; border:1px solid #000; background:#fff;
}

/* Controls bar (top) */
nav#controls{
  display:flex; gap:12px; align-items:center; flex-wrap:wrap;
}
button{
  cursor:pointer; min-width:44px; min-height:44px;
  border:1px solid #000; background:#fff; color:#000; padding:8px 12px; font-weight:700; letter-spacing:0.2px;
}
button.primary{ background:#e6f0ff; border-color:#0057ff }
button.warn{ background:#ffecec; border-color:#cc0000 }
button.icon{ width:44px; height:44px; padding:0 }
button[aria-disabled="true"], button:disabled{ opacity:0.5; cursor:not-allowed }

main{ position:relative; height: calc(100% - 62px) }

/* HUD (score/stats) */
#hud{
  position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:8;
  display:flex; gap:12px; align-items:center; flex-wrap:wrap;
  background: var(--panel); border:1px solid #000; padding:8px 12px;
}
.stat{ display:flex; gap:6px; align-items:baseline; font-variant-numeric: tabular-nums; padding:4px 6px; border:1px solid #000; background:#fff }
.stat .label{ color: var(--muted); font-size:12px }
.stat .value{ font-weight:800; font-size:16px; min-width:36px; text-align:right }

/* Status proxies row below HUD */
#statusRow{
  position:absolute; top:66px; left:50%; transform:translateX(-50%); z-index:8;
  display:flex; gap:12px; align-items:center; flex-wrap:wrap;
  background:#fff; border:1px solid #000; padding:6px 8px;
}
.statusItem{ font-size:12px; border:1px solid #000; padding:4px 6px; background:#f8f8f8 }
.statusItem .label{ color:#333 }
.statusItem .val{ font-weight:800 }

/* Playfield */
#playfield{ position:absolute; inset:0; overflow:hidden; z-index:1; border-top:1px solid #000 }

/* Ground line */
#groundLine{
  position:absolute; left:0; right:0; bottom:10px; height:2px; background:#000; z-index:2;
}

/* Input dock area and local control dock */
#dock{
  position:absolute; left:50%; transform:translateX(-50%); bottom:52px; width:min(920px, 96vw);
  display:flex; flex-direction:column; gap:8px; align-items:stretch; justify-content:center; z-index:7;
}
#txtType{
  width:100%;
  font-size:18px; line-height:1.2; padding:10px 12px; border:2px solid #000; outline:none; color:#000; background:#fff;
}
#txtType:focus{ border-color:#0057ff }
#txtType.mistake{ border-color:#cc0000 }
#inputHint{ font-size:12px; color:#333; padding:4px; border:1px solid #000; background:#fff }
#pausedNote{ font-size:12px; color:#000; padding:4px; border:1px solid #000; background:#fff; display:none }
#inputTooltip{ font-size:12px; color:#000; padding:4px; border:1px solid #000; background:#fff; display:none }

#controlsDock{
  display:flex; gap:12px; align-items:center; flex-wrap:wrap;
  border:1px solid #000; background:#fff; padding:6px 8px;
}
#controlsDock .kbdHint{ font-size:12px; color:#333 }

/* Drops: rectangular tiles with plain border */
.drop{
  position:absolute; left:0; top:0;
  transform: translate3d(0,0,0);
  padding:6px 10px;
  border:1px solid #000; background:#fff; color:#000;
  user-select:none; white-space:nowrap; font-weight:700; font-size:16px; z-index:3;
}
.drop .typed{ color:#000 }
.drop .remaining{ color:#333 }
.drop.dimmed{ opacity:0.5 }
.drop.target{ outline:2px solid #0057ff }
.drop.danger{ outline:2px dashed #cc0000 }
.drop.prefix-match{ background:#e6f0ff }
.drop.pop{ opacity:0 }

/* Overlays */
.overlay{
  position:absolute; inset:0; background:rgba(255,255,255,0.9);
  display:none; align-items:center; justify-content:center; z-index:9; padding:20px; border:1px solid #000;
}
.overlay.visible{ display:flex }
.panel{
  width:min(920px, 96vw);
  background:#fff; border:1px solid #000; padding:18px;
}
.panel h2{ margin:0 0 8px; font-size:20px }
.panel p{ color:#000; margin:6px 0 }
.panel .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:8px }
.panel .row{ display:flex; justify-content:space-between }
.panel .val{ font-weight:800 }
.panel .actions{ display:flex; gap:12px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap }
.panel .note{ font-size:12px; color:#333 }
.panel ul{ margin:8px 0; padding-left:20px }

/* Footer */
footer{
  position:absolute; right:8px; bottom:8px; z-index:3; color:#333; font-size:12px; user-select:none;
}

/* Focus lost overlay note */
#overlayFocus .panel{ border:2px solid #cc0000 }

/* Start prompt box (not overlay) near dock */
#startPrompt{
  position:absolute; left:50%; transform:translateX(-50%);
  bottom:8px; width:min(920px, 96vw);
  border:1px solid #000; background:#fff; padding:6px 8px; z-index:7;
  display:flex; align-items:center; gap:8px; flex-wrap:wrap;
}
#startPrompt .msg{ font-size:12px }
#scoreFlash{ font-size:12px; color:#000; border:1px solid #000; padding:4px; background:#fff; display:none }

/* Fullscreen indicator */
#fullscreenStatusBox{
  position:absolute; top:8px; left:8px; z-index:8; border:1px solid #000; background:#fff; padding:4px; font-size:12px
}

/* Accessibility and documentation area (collapsible at bottom for length and clarity) */
#docs{
  position:absolute; left:8px; bottom:8px; z-index:2; width:min(560px, 40vw); max-height:40vh; overflow:auto;
  border:1px solid #000; background:#fff; padding:8px;
}

/* Make sure everything fits in 1280×720; limit dock bottom spacing */
@media (max-height: 720px){
  #dock{ bottom:52px }
  #groundLine{ bottom:10px }
}

/* Simple attention pulse for start buttons (no animation; emulate with class applying/removal via JS by changing background color class) */
.attention{ background:#fffbcc }

/* Hidden yet present skyline placeholders removed in destylization */
.skyline{ display:none }
</style>
</head>
<body data-game-state="idle" data-fullscreen="false">
  <header>
    <h1><span class="logo" aria-hidden="true"></span> Typing Rain</h1>
    <nav id="controls" aria-label="Game controls">
      <button id="btnStart" class="primary" type="button" title="Start (Enter)">Start</button>
      <button id="btnPause" type="button" title="Pause / Resume (Esc)">Pause</button>
      <button id="btnReset" class="warn" type="button" title="Reset">Restart Game</button>
      <button id="btnHelp" class="icon" type="button" aria-label="Help" title="How to play">?</button>
      <button id="btnFullscreen" type="button" title="Toggle Fullscreen">Fullscreen</button>
    </nav>
  </header>

  <main id="game" role="main" aria-label="Typing Rain game area">
    <div id="hud" role="status" aria-live="polite">
      <div class="stat"><span class="label">Score</span><span id="scoreValue" class="value">0</span></div>
      <div class="stat"><span class="label">Accuracy</span><span id="accuracyValue" class="value">100%</span></div>
      <div class="stat"><span class="label">Level</span><span id="levelValue" class="value">1</span></div>
      <div class="stat"><span class="label">Misses</span><span id="missesValue" class="value">0</span></div>
      <div class="stat"><span class="label">WPM</span><span id="wpmValue" class="value">0</span></div>
      <div id="scoreFlash" aria-live="polite">+0</div>
    </div>

    <div id="statusRow" aria-live="polite">
      <div id="gameStatus" class="statusItem"><span class="label">Game</span> <span class="val">idle</span></div>
      <div id="startStatus" class="statusItem"><span class="label">Start</span> <span class="val">ready</span></div>
      <div id="pauseStatus" class="statusItem"><span class="label">Pause</span> <span class="val">idle</span></div>
      <div id="resetStatus" class="statusItem"><span class="label">Reset</span> <span class="val">idle</span></div>
      <div id="inputStatus" class="statusItem"><span class="label">Input</span> <span class="val">enabled</span></div>
      <div id="spawnStatus" class="statusItem"><span class="label">Spawn</span> <span class="val">waiting</span></div>
      <div id="wordPopStatus" class="statusItem"><span class="label">Last</span> <span class="val">none</span></div>
      <div id="bestStatus" class="statusItem"><span class="label">Best</span> <span class="val">0</span></div>
    </div>

    <div id="playfield" aria-label="Playfield">
      <div id="groundLine" aria-hidden="true"></div>
      <!-- Skyline removed (destylization). -->
    </div>

    <div id="dock">
      <div id="controlsDock" aria-label="Local game controls near input">
        <button id="btnStartDock" class="primary" type="button">Start</button>
        <button id="btnPauseDock" type="button">Pause</button>
        <button id="btnResetDock" class="warn" type="button">Restart</button>
        <span class="kbdHint">Enter to Start • Esc to Pause</span>
      </div>
      <input id="txtType" type="text" inputmode="latin" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" aria-label="Type here to catch the falling words" placeholder="Press Start and type here..." />
      <div id="inputHint">Type continuously. The closest matching word is targeted automatically. Backspace does not affect accuracy.</div>
      <div id="pausedNote" aria-live="polite">Game paused: typing disabled</div>
      <div id="inputTooltip" aria-live="polite">Input ignored due to mismatch. Clear the box to retarget.</div>
    </div>

    <div id="startPrompt">
      <span class="msg">Ready to play. Click Start or press Enter.</span>
      <button id="btnStartPrompt" class="primary" type="button">Start Game</button>
    </div>

    <div id="overlayPause" class="overlay" aria-modal="true" role="dialog" aria-labelledby="pauseTitle">
      <div class="panel">
        <h2 id="pauseTitle">Paused</h2>
        <p id="statusMessage">Take a breath. Press Resume to continue.</p>
        <div class="actions">
          <button id="btnResume" class="primary" type="button">Resume</button>
          <button id="btnPauseToReset" class="warn" type="button">Reset</button>
        </div>
      </div>
    </div>

    <div id="overlayGameOver" class="overlay" aria-modal="true" role="dialog" aria-labelledby="overTitle">
      <div class="panel">
        <h2 id="overTitle">Game Over</h2>
        <div class="grid" style="margin-top:8px">
          <div class="row"><span>Score</span><span id="finalScore" class="val">0</span></div>
          <div class="row"><span>Words Cleared</span><span id="finalCleared" class="val">0</span></div>
          <div class="row"><span>Accuracy</span><span id="finalAccuracy" class="val">0%</span></div>
          <div class="row"><span>WPM</span><span id="finalWpm" class="val">0</span></div>
          <div class="row"><span>Best Score</span><span id="finalBest" class="val">0</span></div>
        </div>
        <p class="note">Reset or Play Again to start a new round. Input is disabled while Game Over is visible.</p>
        <div class="actions">
          <button id="btnPlayAgain" class="primary" type="button">Play Again</button>
          <button id="btnGoResetOver" class="warn" type="button">Reset</button>
        </div>
      </div>
    </div>

    <div id="overlayHelp" class="overlay" aria-modal="true" role="dialog" aria-labelledby="helpTitle">
      <div class="panel">
        <h2 id="helpTitle">How To Play</h2>
        <p>Type the words on the falling tiles before they reach the ground line. Clearing words earns points. Let too many fall and the game ends.</p>
        <ul>
          <li>Enter: Start game</li>
          <li>Esc: Pause / Resume</li>
          <li>The input stays focused during play; type continuously</li>
          <li>Accuracy counts only when you add characters (backspace does not affect it)</li>
          <li>The closest word that matches your prefix is automatically targeted</li>
          <li>When paused or game over, input is disabled</li>
          <li>Full-screen can be toggled via the Fullscreen button in the header</li>
        </ul>
        <p>Difficulty increases with your score: words fall faster and appear more frequently. A subtle dashed outline highlights words close to the ground.</p>
        <div class="actions">
          <button id="btnCloseHelp" class="primary" type="button">Close</button>
          <button id="btnInstructionsClose" type="button">Done</button>
        </div>
      </div>
    </div>

    <div id="overlayFocus" class="overlay" aria-modal="true" role="dialog" aria-labelledby="focusTitle">
      <div class="panel">
        <h2 id="focusTitle">Focus Lost</h2>
        <p>Typing is paused because the window lost focus or you clicked outside the game area.</p>
        <p>Click Resume or re-focus the input box to continue.</p>
        <div class="actions">
          <button id="btnFocusResume" class="primary" type="button">Resume</button>
        </div>
      </div>
    </div>

    <div id="fullscreenStatusBox" aria-live="polite">Fullscreen: off</div>

    <details id="docs">
      <summary>Documentation and Accessibility Notes</summary>
      <div>
        <p>This build prioritizes clarity and operator-friendly controls. It removes decorative styling and focuses on predictable behavior. All critical controls are near the input dock and at the top header to minimize mouse travel. The following lists provide guidance and describe edge cases handled by the application:</p>
        <h3>Key Behaviors</h3>
        <ul>
          <li>Start: Click Start or press Enter. The input auto-focuses and words spawn immediately.</li>
          <li>Pause: Click Pause or press Esc. Input is disabled and a pause overlay appears.</li>
          <li>Resume: Click Resume or press Esc while paused. Input is re-enabled without losing progress.</li>
          <li>Reset: Clears all drops and stats. Shows a brief restart status. Input is focused and ready.</li>
          <li>Game Over: Input disabled, overlay appears. Play Again starts a new round; Reset returns to idle.</li>
          <li>Targeting: The closest matching word by prefix and vertical position is targeted with a solid outline.</li>
          <li>Near Ground: Words near the ground line are marked with a dashed outline to signal urgency.</li>
          <li>Mismatch Handling: If a typed character does not match any word prefix, input becomes “mismatched.” Clear the input to retarget.</li>
          <li>Focus Lost: The game auto-pauses and shows a focus overlay. Resume restores state predictably.</li>
          <li>Fullscreen: Toggle fullscreen via the header button. Status updates in the top-left box.</li>
        </ul>
        <h3>Status Proxies</h3>
        <ul>
          <li>#gameStatus shows “idle”, “playing”, “paused”, “over”, or “focus-lost”. The same value is mirrored by body[data-game-state].</li>
          <li>#startStatus shows “ready”, “started”, or “disabled”, and the Start buttons have aria-disabled updated accordingly.</li>
          <li>#pauseStatus toggles between “paused”, “resumed”, or “idle”.</li>
          <li>#resetStatus shows “done” after any reset is completed.</li>
          <li>#inputStatus shows “enabled” or “disabled”. The #txtType element reflects this via the disabled attribute.</li>
          <li>#spawnStatus shows “spawned” when new words appear, otherwise “waiting”.</li>
          <li>#wordPopStatus shows the last cleared word and points gained, like “cleared ‘alpha’ +14”.</li>
          <li>#bestStatus shows the local best score tracked via localStorage.</li>
          <li>#fullscreenStatusBox shows “Fullscreen: on/off” and body[data-fullscreen] mirrors this state.</li>
        </ul>
        <h3>Accessibility</h3>
        <ul>
          <li>All changes are announced via aria-live regions near the HUD and dock where relevant.</li>
          <li>Buttons are large enough for easy clicking, with minimum 44×44 px size.</li>
          <li>Keyboard hints near the input dock guide primary actions (Enter, Esc).</li>
          <li>No input constraints are introduced beyond the original build. Plain text typing remains allowed.</li>
          <li>No flows auto-trigger on load; initial state is neutral (idle).</li>
        </ul>
        <h3>Edge Cases</h3>
        <ul>
          <li>Just-in-time completion: Words that reach the ground have a brief grace window before a miss finalizes, allowing last-moment matches.</li>
          <li>Paused accuracy updates: Accuracy and WPM are not recalculated during pause; they resume upon unpausing.</li>
          <li>Word spawn concurrency: Newly spawned words are highlighted if they share the current input prefix.</li>
          <li>Reset debounce: Reset button is temporarily disabled for 1 second after click to prevent double resets.</li>
        </ul>
        <h3>Changelog Highlights</h3>
        <ul>
          <li>Added local control dock with Start, Pause, Reset near the input.</li>
          <li>Added focus-lost overlay and explicit input disabled state on pause/over.</li>
          <li>Added status proxies (#gameStatus, #startStatus, #pauseStatus, #resetStatus, #inputStatus, #spawnStatus, #wordPopStatus, #bestStatus, #fullscreenStatusBox).</li>
          <li>Improved HUD contrast and ensured consistent visibility at 1280×720.</li>
          <li>Implemented near-ground urgency highlighting and prefix-match spawn highlight.</li>
        </ul>
      </div>
    </details>
  </main>

  <footer>
    Typing Rain • Vanilla JS • Fits 1280×720
  </footer>

  <script>
    (function(){
      "use strict";

      // Elements
      const el = {
        playfield: document.getElementById('playfield'),
        txtType: document.getElementById('txtType'),
        btnStart: document.getElementById('btnStart'),
        btnPause: document.getElementById('btnPause'),
        btnReset: document.getElementById('btnReset'),
        btnHelp: document.getElementById('btnHelp'),
        btnFullscreen: document.getElementById('btnFullscreen'),
        btnResume: document.getElementById('btnResume'),
        btnPauseToReset: document.getElementById('btnPauseToReset'),
        btnPlayAgain: document.getElementById('btnPlayAgain'),
        btnGoResetOver: document.getElementById('btnGoResetOver'),
        btnCloseHelp: document.getElementById('btnCloseHelp'),
        btnInstructionsClose: document.getElementById('btnInstructionsClose'),
        overlayPause: document.getElementById('overlayPause'),
        overlayGameOver: document.getElementById('overlayGameOver'),
        overlayHelp: document.getElementById('overlayHelp'),
        overlayFocus: document.getElementById('overlayFocus'),
        scoreValue: document.getElementById('scoreValue'),
        accuracyValue: document.getElementById('accuracyValue'),
        levelValue: document.getElementById('levelValue'),
        missesValue: document.getElementById('missesValue'),
        wpmValue: document.getElementById('wpmValue'),
        finalScore: document.getElementById('finalScore'),
        finalCleared: document.getElementById('finalCleared'),
        finalAccuracy: document.getElementById('finalAccuracy'),
        finalWpm: document.getElementById('finalWpm'),
        finalBest: document.getElementById('finalBest'),
        scoreFlash: document.getElementById('scoreFlash'),

        // Local dock controls
        btnStartDock: document.getElementById('btnStartDock'),
        btnPauseDock: document.getElementById('btnPauseDock'),
        btnResetDock: document.getElementById('btnResetDock'),

        // Start prompt near dock
        startPrompt: document.getElementById('startPrompt'),
        btnStartPrompt: document.getElementById('btnStartPrompt'),

        // Input notes
        inputHint: document.getElementById('inputHint'),
        pausedNote: document.getElementById('pausedNote'),
        inputTooltip: document.getElementById('inputTooltip'),

        // Status proxies
        gameStatus: document.querySelector('#gameStatus .val'),
        startStatus: document.querySelector('#startStatus .val'),
        pauseStatus: document.querySelector('#pauseStatus .val'),
        resetStatus: document.querySelector('#resetStatus .val'),
        inputStatus: document.querySelector('#inputStatus .val'),
        spawnStatus: document.querySelector('#spawnStatus .val'),
        wordPopStatus: document.querySelector('#wordPopStatus .val'),
        bestStatus: document.querySelector('#bestStatus .val'),
        fullscreenStatusBox: document.getElementById('fullscreenStatusBox')
      };

      // Word bank - large list to ensure variety; extended for visibility and difficulty ramp
      const WORDS = `
      rain city storm cloud night light neon skyline shadow static shimmer glide drift splash flash drop breeze mist river ocean spark shine bright calm quick slow code type keyboard pixel debug build deploy commit branch merge logic array object string number window event focus shift enter escape rhythm melody jazz blues synth drum bass guitar piano violin rocket orbit planet comet galaxy lunar solar void nebula star meteor eclipse tide wave crest summit canyon valley bridge tunnel street avenue station park plaza garden forest desert island coast beach harbor port castle turret palace temple museum library theater cinema studio campus office market coffee pizza burger sushi taco pasta bread apple berry mango banana lemon lime melon cherry peach cocoa sugar salt pepper basil thyme honey oats rice noodle garlic onion carrot potato tomato lettuce mint proud brave smart swift crisp sharp keen kind noble pure true vivid happy lucky magic rapid basic major minor alpha beta gamma delta omega cyber micro macro nano giga tera cloud server client socket cache stack queue graph tree heap hash react scope closure module import export async await fetch json parse local state render mount loop frame spawn score level input pause reset timer tick event target select bind unbind toggle class data aria live focus blur resume restart over clear miss wpm accuracy speed fall drop tile line border status urgent prefix match near ground plain simple exact partial attempt instant just moment grace end best local storage record high streak bonus combo power fast slow medium easy hard expert challenge intense calm steady stable safe fair alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho sigma tau upsilon phi chi psi omega red blue green yellow black white orange purple pink gray silver gold bronze copper iron stone steel wood glass paper fabric nylon cotton silk linen wool noise beep click tap drag scroll zoom key press held release backspace delete space tab shift ctrl alt meta enter escape left right up down page home end apple berry cherry date elder fig grape huckleberry kiwi lime mango nectarine olive peach quince raisin strawberry tomato ugli fruit vanilla watermelon xigua yam zucchini spring summer autumn winter monday tuesday wednesday thursday friday saturday sunday january february march april may june july august september october november december morning noon evening night dawn dusk twilight sunrise sunset polar equator north south east west center middle top bottom left right forward backward inside outside above below near far here there now soon later before after first second third zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty quickstart workflow status proxy dock overlay panel film stage scene script actor viewer system model control reset pause resume help guide docs accessibility keyboard mouse touch pointer click double triple slow fast jitter lag smooth crisp bold faint clear highlight error warn ok good great awesome superb perfect nice cool neat tidy bright dark light heavy soft hard liquid solid gas plasma wave particle field energy power charge voltage current resistance impulse inertia momentum force mass speed time space dimension unit angle curve line point vector matrix tensor scalar logic boolean integer float string literal array list map set queue stack heap tree graph node edge path cycle loop ring star net web mesh grid bit byte word block page frame buffer stream pipe queue tick tock sync async await promise resolve reject settle stable robust safe predictable deterministic consistent repeat torsion torque lever pivot hinge screw valve pump motor engine gear sprocket chain belt bolt nut nail glue tape clamp brace beam plate bar rod joint lock key latch hook ring coil spring clip pin wedge rail track bridge tunnel road path street lane route trail way gate door window wall floor ceiling roof room hall lobby deck yard garden field park plaza court stage pier port dock bay cove lake pond river stream brook creek canal delta basin channel dune ridge hill mountain cliff ledge shelf reef shoal sand silt clay soil dirt mud rock stone pebble gravel boulder magma lava ash smoke fire ember flame heat light glow ray beam flash flair shine twinkle spark glitter glint flare glare glare star nova supernova quasar pulsar nebula galaxy cosmos universe void vacuum ether plasma arc bolt strike storm gust gale breeze squall rain drizzle pour shower flood wave swell surf foam spray bubble droplet cloud mist fog haze smog dew frost snow sleet hail ice glacier iceberg tundra desert oasis savanna prairie steppe forest jungle grove orchard vineyard farm ranch barn stable cabin hut shack shed tent camp lodge inn hotel hostel house home villa manor castle fortress tower keep citadel palace temple shrine church mosque pagoda library museum theater cinema studio gallery school campus college university office market shop store mall plaza bank vault mint court jail prison station depot port harbor pier quay wharf dock slip berth anchor moor buoy beacon light tower lighthouse signal flare siren horn bell chime drum bass guitar piano violin cello trumpet saxophone clarinet flute harp lyre banjo mandolin ukulele sitar tabla djembe gong cymbal tambourine triangle shaker maraca whistle hum buzz click tap tick tock ring ping pong pong blip bleep bloop glitch lag jitter stutter frame rate sync clock timer counter meter gauge dial scale balance index log chart graph plot map canvas screen window pane tile card block chip byte bit nibble word page packet frame bundle set group cluster swarm flock herd pack school shoal pride troop gaggle parliament murder colony hive den lair nest burrow cave cavern grotto tunnel mine shaft pit quarry well spring source outlet inlet pipe drain sewer ditch trench moat canal lock dam levee dyke weir fall cascade cataract rapid rivulet stream brook creek runnel gulf strait sound bay bight cove harbor port roadstead anchorage beach shore strand coast bank littoral littoral dune fetch cliff scarp escarpment plateau mesa butte tor knoll mount peak summit ridge saddle col pass gap notch valley dale dell glen hollow basin bowl plain steppe prairie meadow lea heath moor bog fen marsh mire swamp slough wetland tundra taiga veld karst canyon arroyo gully ravine gorge chasm fissure crack fault rift fold bend arch dome basin monocline syncline anticline antinode node wave crest trough amplitude frequency period phase velocity dispersion diffraction interference reflection refraction polarization coherence resonance standing traveling shock sonic supersonic subsonic hypersonic laminar turbulent viscosity density pressure temperature entropy enthalpy energy work power heat light radiation emission absorption scattering ionization excitation recombination nucleation crystallization dissolution precipitation evaporation condensation sublimation deposition fusion fission decay alpha beta gamma delta epsilon etc
      `.trim().split(/\s+/).filter(Boolean);

      // Game State
      const state = {
        running: false,
        paused: false,
        over: false,
        score: 0,
        misses: 0,
        maxMisses: 10,
        level: 1,
        wordsCleared: 0,
        typedChars: 0,
        correctChars: 0,
        lastTime: 0,
        spawnTimer: 0,
        spawnInterval: 1600,
        baseSpeed: 80, // pixels per second
        startTime: 0,
        targetWordId: null,
        prevInput: '',
        nextId: 1,
        fieldRect: null,
        raf: 0,
        minSpawnInterval: 550,
        maxOnScreen: 10,
        inputMismatched: false,
        graceWindowMs: 160,
        bestScore: 0,
        pausedAt: 0
      };

      const active = new Map(); // id -> wordObj

      function measureField(){
        state.fieldRect = el.playfield.getBoundingClientRect();
      }
      window.addEventListener('resize', measureField);

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
      function randBetween(a,b){ return Math.random()*(b-a)+a; }
      function pickWord(){
        const bias = clamp(state.level-1, 0, 6);
        const pool = WORDS.filter(w => w.length >= Math.min(3+bias, 10) && w.length <= Math.min(7+bias*2, 16));
        return (pool.length ? pool : WORDS)[Math.floor(Math.random()*(pool.length?pool.length:WORDS.length))].toLowerCase();
      }

      function setStatusProxy(id, text){
        const node = document.querySelector(`#${id} .val`);
        if(node){ node.textContent = text; }
      }
      function setBodyState(stateName){
        document.body.setAttribute('data-game-state', stateName);
        if(el.gameStatus) el.gameStatus.textContent = stateName;
      }
      function setStartStatus(text){ if(el.startStatus) el.startStatus.textContent = text; }
      function setPauseStatus(text){ if(el.pauseStatus) el.pauseStatus.textContent = text; }
      function setResetStatus(text){ if(el.resetStatus) el.resetStatus.textContent = text; }
      function setInputStatus(text){ if(el.inputStatus) el.inputStatus.textContent = text; }
      function setSpawnStatus(text){ if(el.spawnStatus) el.spawnStatus.textContent = text; }
      function setWordPopStatus(text){ if(el.wordPopStatus) el.wordPopStatus.textContent = text; }
      function setBestStatus(val){ if(el.bestStatus) el.bestStatus.textContent = String(val); }

      // Best score persistence
      function loadBest(){
        try{
          const v = localStorage.getItem('typingRainBest');
          state.bestScore = v ? parseInt(v, 10) || 0 : 0;
          setBestStatus(state.bestScore);
        }catch(e){}
      }
      function saveBest(){
        if(state.score > state.bestScore){
          state.bestScore = state.score;
          setBestStatus(state.bestScore);
          try{ localStorage.setItem('typingRainBest', String(state.bestScore)); }catch(e){}
        }
      }

      function makeDrop(text){
        const id = state.nextId++;
        const elDrop = document.createElement('div');
        elDrop.className = 'drop';
        elDrop.setAttribute('data-id', id);
        elDrop.setAttribute('aria-label', text);
        elDrop.innerHTML = `<span class="typed"></span><span class="remaining"></span>`;
        el.playfield.appendChild(elDrop);
        const drop = {
          id,
          text,
          x: 0,
          y: -30,
          speed: state.baseSpeed * randBetween(0.95, 1.18),
          el: elDrop,
          width: 0,
          height: 0,
          pendingMissTimer: null
        };
        const margin = 12;
        const fieldWidth = state.fieldRect.width;
        drop.x = Math.floor(randBetween(margin, fieldWidth - margin));
        setDropText(drop, '');
        const r = elDrop.getBoundingClientRect();
        drop.width = r.width;
        drop.height = r.height;
        drop.x = clamp(drop.x, margin, fieldWidth - margin - drop.width);
        setDropPos(drop);

        // Highlight if new word matches current prefix
        if(state.prevInput && drop.text.startsWith(state.prevInput)){
          drop.el.classList.add('prefix-match');
          el.inputHint.textContent = "New word matches your prefix.";
        }

        active.set(id, drop);
        setSpawnStatus('spawned');
      }

      function setDropText(drop, typed){
        const typedSpan = drop.el.querySelector('.typed');
        const remainingSpan = drop.el.querySelector('.remaining');
        const tlen = typed.length;
        typedSpan.textContent = typed;
        remainingSpan.textContent = drop.text.slice(tlen);
      }

      function setDropPos(drop){
        drop.el.style.transform = `translate3d(${drop.x}px, ${drop.y}px, 0)`;
      }

      function removeDrop(drop, popped=false){
        if(!drop || !drop.el) return;
        clearPendingMiss(drop);
        if(popped){
          // Minimal pop: just remove immediately; status proxy will announce
          drop.el.remove();
        }else{
          drop.el.remove();
        }
        active.delete(drop.id);
      }

      function highlightTargets(input){
        const val = input.toLowerCase();
        if(state.inputMismatched && val.length){
          // do not retarget until cleared
          active.forEach(d=>{
            d.el.classList.remove('target');
            setDropText(d, '');
            d.el.classList.toggle('dimmed', true);
          });
          el.inputTooltip.style.display = 'block';
          return;
        }else{
          el.inputTooltip.style.display = 'none';
        }
        let candidates = [];
        active.forEach(d => {
          if(val && d.text.startsWith(val)){
            candidates.push(d);
          }
        });
        let target = null;
        if(candidates.length){
          candidates.sort((a,b)=> (b.y - a.y) || (a.text.length - b.text.length));
          target = candidates[0];
        }
        active.forEach(d=>{
          d.el.classList.remove('target');
          d.el.classList.toggle('dimmed', !!val && !d.text.startsWith(val));
          if(val && d.text.startsWith(val)){
            setDropText(d, val);
          }else{
            setDropText(d, '');
          }
        });
        if(target){
          target.el.classList.add('target');
          state.targetWordId = target.id;
        }else{
          state.targetWordId = null;
        }
      }

      function addScore(wordLen){
        const bonus = Math.floor(state.level*3);
        const pts = 10 + wordLen*2 + bonus;
        state.score += pts;
        state.wordsCleared += 1;
        updateLevelAndPace();
        updateHud();
        // Visual feedback near score
        el.scoreFlash.textContent = `+${pts}`;
        el.scoreFlash.style.display = 'inline-block';
        setTimeout(()=>{ el.scoreFlash.style.display='none'; }, 400);
      }

      function onMiss(){
        state.misses += 1;
        updateHud();
        if(state.misses >= state.maxMisses){
          gameOver();
        }
      }

      function accuracy(){
        if(state.typedChars === 0) return 100;
        return (state.correctChars / state.typedChars) * 100;
      }

      function wpm(){
        const elapsedMs = (performance.now() - state.startTime);
        const minutes = Math.max(elapsedMs / 60000, 0.1);
        return Math.round(state.wordsCleared / minutes);
      }

      function updateHud(){
        el.scoreValue.textContent = state.score.toString();
        el.levelValue.textContent = state.level.toString();
        el.missesValue.textContent = state.misses.toString();
        // Avoid changing accuracy/WPM during pause to meet task requirement
        if(!state.paused){
          el.accuracyValue.textContent = `${accuracy().toFixed(1)}%`;
          el.wpmValue.textContent = wpm().toString();
        }
      }

      function updateLevelAndPace(){
        const newLevel = Math.max(1, Math.floor(state.score / 150) + 1);
        if(newLevel !== state.level){
          state.level = newLevel;
        }
        state.spawnInterval = clamp(1600 - (state.level-1)*120, state.minSpawnInterval, 1600);
        state.baseSpeed = 80 + (state.level-1)*22;
      }

      function scheduleMiss(drop){
        clearPendingMiss(drop);
        drop.pendingMissTimer = setTimeout(()=>{
          // If drop still exists and wasn't popped, finalize miss
          if(active.has(drop.id)){
            removeDrop(drop, false);
            onMiss();
          }
        }, state.graceWindowMs);
      }
      function clearPendingMiss(drop){
        if(drop && drop.pendingMissTimer){
          clearTimeout(drop.pendingMissTimer);
          drop.pendingMissTimer = null;
        }
      }

      function gameLoop(ts){
        if(!state.running) return;
        if(!state.lastTime) state.lastTime = ts;
        const dt = (ts - state.lastTime) / 1000;
        state.lastTime = ts;

        if(!state.paused){
          const groundY = state.fieldRect.height - 14;
          const toDanger = [];
          active.forEach(drop=>{
            const sizeFactor = clamp(drop.text.length / 8, 0.85, 1.25);
            const levelFactor = 1 + (state.level-1)*0.12;
            const dy = drop.speed * levelFactor * sizeFactor * dt;
            drop.y += dy;
            setDropPos(drop);
            // Mark near ground
            if(drop.y + drop.height >= groundY - 40){
              toDanger.push(drop);
            }
            // Grace window before miss
            if(drop.y + drop.height >= groundY){
              scheduleMiss(drop);
            }
          });
          toDanger.forEach(drop => drop.el.classList.add('danger'));

          // Spawn logic
          state.spawnTimer += dt*1000;
          if(state.spawnTimer >= state.spawnInterval && active.size < state.maxOnScreen){
            state.spawnTimer = 0;
            makeDrop(pickWord());
          }
        }

        state.raf = requestAnimationFrame(gameLoop);
      }

      function enableInput(){
        el.txtType.disabled = false;
        setInputStatus('enabled');
        el.pausedNote.style.display = 'none';
      }
      function disableInput(){
        el.txtType.disabled = true;
        setInputStatus('disabled');
      }

      function startGame(){
        if(state.running && !state.over){
          if(state.paused){ resumeGame(); }
          return;
        }
        resetGame(true);
        state.running = true;
        state.paused = false;
        state.over = false;
        state.startTime = performance.now();
        state.lastTime = 0;
        state.spawnTimer = 0;
        setBodyState('playing');
        setStartStatus('started');
        setPauseStatus('idle');
        setResetStatus('idle');
        enableInput();
        el.txtType.placeholder = "Type the falling words...";
        el.txtType.focus();
        setSpawnStatus('waiting');
        // seed words immediately
        makeDrop(pickWord());
        if(active.size<2) makeDrop(pickWord());
        state.raf = requestAnimationFrame(gameLoop);
        // disable start buttons while running
        el.btnStart.setAttribute('aria-disabled','true'); el.btnStart.disabled = true;
        el.btnStartDock.setAttribute('aria-disabled','true'); el.btnStartDock.disabled = true;
        el.btnStartPrompt.setAttribute('aria-disabled','true'); el.btnStartPrompt.disabled = true;
      }

      function pauseGame(){
        if(!state.running || state.paused || state.over) return;
        state.paused = true;
        state.pausedAt = performance.now();
        el.overlayPause.classList.add('visible');
        disableInput();
        el.pausedNote.style.display = 'block';
        setBodyState('paused');
        setPauseStatus('paused');
      }

      function resumeGame(){
        if(!state.running || !state.paused || state.over) return;
        state.paused = false;
        el.overlayPause.classList.remove('visible');
        el.overlayFocus.classList.remove('visible');
        state.lastTime = 0;
        enableInput();
        el.txtType.focus();
        setBodyState('playing');
        setPauseStatus('resumed');
      }

      function resetGame(keepOverlays=false){
        // Clear drops
        active.forEach(d => d.el.remove());
        active.clear();
        cancelAnimationFrame(state.raf);

        // Reset state
        state.running = false;
        state.paused = false;
        state.over = false;
        state.score = 0;
        state.misses = 0;
        state.level = 1;
        state.wordsCleared = 0;
        state.typedChars = 0;
        state.correctChars = 0;
        state.prevInput = '';
        state.lastTime = 0;
        state.spawnTimer = 0;
        state.spawnInterval = 1600;
        state.baseSpeed = 80;
        state.targetWordId = null;
        state.inputMismatched = false;
        updateHud();
        setBodyState('idle');
        setStartStatus('ready');
        setPauseStatus('idle');
        setResetStatus('done');
        setSpawnStatus('waiting');
        setWordPopStatus('none');
        if(!keepOverlays){
          el.overlayPause.classList.remove('visible');
          el.overlayGameOver.classList.remove('visible');
          el.overlayFocus.classList.remove('visible');
        }
        el.txtType.value = '';
        el.txtType.placeholder = "Press Start (or Enter) to play";
        measureField();
        disableInput();
        el.pausedNote.style.display = 'none';
        el.inputTooltip.style.display = 'none';

        // Re-enable start buttons
        el.btnStart.removeAttribute('aria-disabled'); el.btnStart.disabled = false;
        el.btnStartDock.removeAttribute('aria-disabled'); el.btnStartDock.disabled = false;
        el.btnStartPrompt.removeAttribute('aria-disabled'); el.btnStartPrompt.disabled = false;

        // Debounce reset buttons for 1 second
        [el.btnReset, el.btnResetDock].forEach(b=>{
          if(b){
            b.setAttribute('aria-disabled','true'); b.disabled = true;
            setTimeout(()=>{ b.removeAttribute('aria-disabled'); b.disabled = false; }, 1000);
          }
        });
      }

      function gameOver(){
        state.over = true;
        state.running = false;
        cancelAnimationFrame(state.raf);
        // Disable input
        disableInput();
        // Clear remaining drops visually
        active.forEach(d => d.el.classList.add('dimmed'));
        saveBest();
        el.finalScore.textContent = state.score.toString();
        el.finalCleared.textContent = state.wordsCleared.toString();
        el.finalAccuracy.textContent = `${accuracy().toFixed(1)}%`;
        el.finalWpm.textContent = wpm().toString();
        el.finalBest.textContent = String(state.bestScore);
        el.overlayPause.classList.remove('visible');
        el.overlayGameOver.classList.add('visible');
        el.txtType.blur();
        setBodyState('over');
      }

      function onInput(e){
        if(!state.running || state.paused || state.over) return;
        const current = el.txtType.value.toLowerCase().trim();
        const previous = state.prevInput;

        // Added characters tracking
        if(current.length > previous.length){
          const added = current.slice(previous.length);
          for(let i=0;i<added.length;i++){
            const candidate = previous + added.slice(0,i+1);
            state.typedChars += 1;
            const matchesAny = Array.from(active.values()).some(d => d.text.startsWith(candidate));
            if(matchesAny){
              state.correctChars += 1;
              // reset mismatch if previously mismatched but now matches with cleared old content
              if(state.inputMismatched){ state.inputMismatched = false; el.inputTooltip.style.display = 'none'; }
            }else{
              el.txtType.classList.add('mistake');
              setTimeout(()=> el.txtType.classList.remove('mistake'), 160);
              state.inputMismatched = true;
            }
          }
        }else if(current.length === 0){
          // Clearing input resets mismatch
          state.inputMismatched = false;
          el.inputTooltip.style.display = 'none';
        }
        state.prevInput = current;
        highlightTargets(current);

        // If there is a perfect match, pop it
        if(state.targetWordId){
          const target = active.get(state.targetWordId);
          if(target && current === target.text){
            addScore(target.text.length);
            setWordPopStatus(`cleared '${target.text}' +${10 + target.text.length*2 + Math.floor(state.level*3)}`);
            removeDrop(target, true);
            el.txtType.value = '';
            state.prevInput = '';
            state.targetWordId = null;
            highlightTargets('');
          }
        }
        updateHud();
      }

      function onKeyDown(e){
        if(e.key === 'Enter' && !state.running){
          e.preventDefault();
          startGame();
          return;
        }
        if(e.key === 'Escape' && state.running && !state.over){
          e.preventDefault();
          if(state.paused) resumeGame(); else pauseGame();
          return;
        }
        // Keep input focused during play
        if(state.running && !state.paused && document.activeElement !== el.txtType){
          el.txtType.focus({preventScroll:true});
        }
      }

      // Fullscreen toggle
      async function toggleFullscreen(){
        try{
          if(!document.fullscreenElement){
            await document.documentElement.requestFullscreen();
            document.body.setAttribute('data-fullscreen','true');
            el.fullscreenStatusBox.textContent = 'Fullscreen: on';
          }else{
            await document.exitFullscreen();
            document.body.setAttribute('data-fullscreen','false');
            el.fullscreenStatusBox.textContent = 'Fullscreen: off';
          }
        }catch(err){
          // ignore
        }
      }

      // Button events (header)
      el.btnStart.addEventListener('click', startGame);
      el.btnPause.addEventListener('click', ()=> state.paused ? resumeGame() : pauseGame());
      el.btnReset.addEventListener('click', ()=> resetGame());
      el.btnHelp.addEventListener('click', ()=>{ el.overlayHelp.classList.add('visible'); });
      el.btnCloseHelp.addEventListener('click', ()=>{
        el.overlayHelp.classList.remove('visible');
        // Highlight start button for 2 seconds
        [el.btnStart, el.btnStartDock, el.btnStartPrompt].forEach(b=>{
          if(b){ b.classList.add('attention'); setTimeout(()=> b.classList.remove('attention'), 2000); }
        });
        if(state.running && state.paused){ resumeGame(); }
        else if(state.running){ el.txtType.focus(); }
      });
      el.btnInstructionsClose.addEventListener('click', ()=>{
        el.overlayHelp.classList.remove('visible');
        setStatusProxy('gameStatus', 'idle');
      });
      el.btnResume.addEventListener('click', resumeGame);
      el.btnPauseToReset.addEventListener('click', ()=> { resetGame(); });
      el.btnPlayAgain.addEventListener('click', ()=>{
        el.overlayGameOver.classList.remove('visible');
        startGame();
      });
      el.btnGoResetOver.addEventListener('click', ()=>{ el.overlayGameOver.classList.remove('visible'); resetGame(); });
      el.btnFullscreen.addEventListener('click', toggleFullscreen);

      // Button events (dock)
      el.btnStartDock.addEventListener('click', startGame);
      el.btnPauseDock.addEventListener('click', ()=> state.paused ? resumeGame() : pauseGame());
      el.btnResetDock.addEventListener('click', ()=> resetGame());
      el.btnStartPrompt.addEventListener('click', startGame);

      // Focus overlay resume button
      const btnFocus = document.getElementById('btnFocusResume');
      btnFocus.addEventListener('click', ()=> resumeGame());

      // Input events
      el.txtType.addEventListener('input', onInput);
      document.addEventListener('keydown', onKeyDown);

      // Auto-pause on blur
      window.addEventListener('blur', ()=> {
        if(state.running && !state.paused && !state.over){
          pauseGame();
          el.overlayFocus.classList.add('visible');
          setBodyState('focus-lost');
        }
      });

      // Ensure clicking playfield focuses input (safe path)
      el.playfield.addEventListener('pointerdown', ()=> {
        if(state.running && !state.paused && !state.over){
          el.txtType.focus();
        }
      });

      // Initial
      measureField();
      updateHud();
      loadBest();
      setBodyState('idle');
      setStartStatus('ready');
      setPauseStatus('idle');
      setResetStatus('idle');
      setSpawnStatus('waiting');
      setWordPopStatus('none');
      setBestStatus(state.bestScore);
      disableInput();
      el.inputHint.textContent = "Press Start to begin, then type the falling words. Press Esc to pause.";
    })();
  </script>
</body>
</html>